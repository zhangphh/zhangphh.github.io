<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>chat聊天系统消息消费时遇到的问题及优化思路(一)</title>
    <link href="/2024/11/16/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/11/16/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前有段工作经历涉及到了chat相关，而消息的发送 -&gt; 存储 -&gt; 消费是由不同的团队负责的，因此消息如何再多个团队之间流通、以及通过什么介质传递都是需要考虑的问题。</p><p>之前我负责过一些消息消费的相关工作，消息发送团队将消息推送到kafka之后，由我们去订阅topic并消费对应的分区，拿到消息之后做对应的消息类型解析、消息发送双方可见性分析、接收方未读数、推送等业务处理。本文旨在记录之前工作中遇到的相关问题以及从consumer端如何优化处理。</p><p><img src="http://gips0.baidu.com/it/u=1690853528,2506870245&fm=3028&app=3028&f=JPEG&fmt=auto?w=1024&h=1024" alt="在这里插入图片描述"></p><p>可以看到，消息系统中引入了kafka，因此如果kafka出现问题，那整个系统都会出现问题。</p><h3 id="顺序问题"><a href="#顺序问题" class="headerlink" title="顺序问题"></a>顺序问题</h3><h4 id="1、为什么要保证消息的顺序"><a href="#1、为什么要保证消息的顺序" class="headerlink" title="1、为什么要保证消息的顺序"></a>1、为什么要保证消息的顺序</h4><p>我们之所以能够回复对方发过来的消息的依据就是对方消息内容，因此对于chat系统来说，消息的顺序性是必须要求保证的硬核标准，如果消息乱序，那这个chat系统可以说是完全报废。因此对于chat系统来说<strong>必须要保证消息的顺序性</strong> 。</p><h4 id="2、如何保证消息的顺序性"><a href="#2、如何保证消息的顺序性" class="headerlink" title="2、如何保证消息的顺序性"></a>2、如何保证消息的顺序性</h4><p>众所周知，kafka有topic的概念，每个topic可以拥有多个<code>分区(partition)</code>，而每个分区的内部都是有序的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7247ada71b52740fb7e9eb4713e921e0.png" alt="在这里插入图片描述"></p><p>如此一来，如何保证消息的顺序性思路就比较清晰了，完全可以利用<code>partition</code>的特性去做处理，按照一定的规则将消息写到不同的<code>partition</code>中去，然后消费者消费<code>partition</code>中的消息。</p><p>思考这样一个问题：写到<code>partition</code>中的消息要按照什么规则去做呢？试想一下，我们要保证消息的顺序性，有序性是在同一会话的前提下，也就是说不同会话之前不需要保证消息的顺序性，因此我们可以把<code>conversationId</code>去做如取余或哈希操作，将同一个<code>partition</code>会话的消息全都放入一个<code>partition</code>中。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0875a160e32802d14a70183d09e926d1.png" alt="在这里插入图片描述"></p><h3 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h3><p>上述一期方案上线后在项目初期运行一段时间基本没问题，但随着产品推广用户量激增，上述消费架构就出现了问题：消息接收方受消息不够实时，延迟比较高，这对用户来说十分不友好，本来10秒钟几句话的事，到现在可能延迟有1分钟，这谁能忍得了啊。</p><p>虽然可以通过水平扩展增加机器数量来缓解压力，但这不是最优的方案，而且最主要是费钱。</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h5 id="1、消息体"><a href="#1、消息体" class="headerlink" title="1、消息体"></a>1、消息体</h5><p>思考下kafka消息发送到消息消费共经历了几次IO?</p><ul><li>从producer到broker经历一次网络IO</li><li>broker落盘经历一次磁盘IO</li><li>consumer从broker取数据时经历一次网络IO</li><li>broker从磁盘拿数据经历一次磁盘IO</li></ul><p>一共经历四次IO，引用一张如图说明<br><img src="https://i-blog.csdnimg.cn/blog_migrate/37a9910c450eef9c59f1b53bdd3a5a31.png" alt="在这里插入图片描述"></p><p>因此这里有个优化思路就是减少消费者取数据时broker从磁盘取数据时经历的IO耗时，那该如何减少呢？</p><p>试想一下，假设消费者每次取500条数据，如果每条消息的消息体过大，那取500条数据经历IO耗时势必会增加，进而影响生产和消费速度。而且当消息体过大时，还有可能会导致磁盘空间不足的问题。</p><h5 id="2、路由规则"><a href="#2、路由规则" class="headerlink" title="2、路由规则"></a>2、路由规则</h5><p>排除消息体过大的原因之后，我们需要看下kafka是否存在lag，如果存在lag我们要从消费者端解决问题。</p><p>根据监控查看出现lag的具体的分区，如果是同一个topic的特定某几个分区出现lag，那就需要考虑下是不是路由规则不合理的问题。</p><p>一个例子就是对于点餐系统，如果路由规则是根据商家ID来做的，而某些商家订单量一直很大，恰巧这些商家的相关消息都路由到了同一个<code>partition</code>，就导致只有这个<code>partition</code>出现了lag，进而消息处理较慢。</p><p>针对这种路由不合理的问题，解决方案就是选择合理的路由规则或key，如上述点餐系统，可以考虑路由规则根据订单号来做，因为所有订单号都是基于同一套方案生成的，所以基本不会出现个别<code>partition</code> lag太高的情况。</p><p>而chat系统之前也说过路由规则是基于<code>conversationId</code>去做的，而conversationId也是基于相同的方案生成的，所以如果出现lag发生，那理论上会涉及到大多数<code>partition</code>都出现lag。</p><h5 id="3、表过大"><a href="#3、表过大" class="headerlink" title="3、表过大"></a>3、表过大</h5><p>假设现在有1亿conversation存于一张表中，即使有索引，根据conversationId去查询对应会话信息的时候耗时也会很高，一条消息的消费原来可能只有500ms，但是现在可能需要5s甚至更久，因此，当数据量比较大时就要考虑分表了。</p><p>这里提供一种分表思路，基于conversatioId%100去做，或者是对1000取余。</p><h5 id="4、数据库主从延迟"><a href="#4、数据库主从延迟" class="headerlink" title="4、数据库主从延迟"></a>4、数据库主从延迟</h5><p>如果在生产环境数据库采用主从架构，主节点负责写，从节点负责读，在从broker拿到消息并完成解析拿到conversationId，这时候去会话团队拿数据，发现数据返回空，对应我们这边后续消费逻辑直接报错而返回，而会话团队根据conversationId去查是有这个会话的，这种情况第一次遇到时就显得很诡异。</p><p>后来进过分析发现，我们这边调接口时走的是会话团队数据库的从库，而主从同步还没将最新数据写到从库中。</p><p>发现问题后有两个解决方案：</p><ul><li>直接读master节点，这种方案不太可取，这样slave节点只作为备份？而且master节点压力会变大，甚至垮掉，也就失去了主从架构原有的作用。</li><li>加入重试机制，读取到conversation为空时，将此消息加入到<code>重试表</code>，在做后续处理。</li></ul><h5 id="5、并发消费"><a href="#5、并发消费" class="headerlink" title="5、并发消费"></a>5、并发消费</h5><p>上述消费架构是一个分区有一个消费者，既然一个消费者消费速度太慢，那何不增加消费者的数量呢？因此优化思路就有了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/931490e2deb7ca3d158495261f9239e4.png" alt="在这里插入图片描述"></p><p>可以把每个<code>partition</code>中的消息按照conversationId%5然后放入到channel中，然后每个channel在配备一个goroutine去消费，这样既能保证同一会话消息的顺序性，又能提升消费速度尽量避免lag。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/16/hello-world/"/>
    <url>/2024/11/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
