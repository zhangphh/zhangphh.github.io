<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>输入URL到网页显示中间发生了什么</title>
    <link href="/2025/07/25/%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2025/07/25/%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-精简版回答："><a href="#1-精简版回答：" class="headerlink" title="1.精简版回答："></a>1.精简版回答：</h2><p>当浏览器输入 URL 后，整个流程大致如下：</p><ol><li><p><strong>URL 解析</strong>：浏览器解析 URL，提取协议、主机名、端口和路径信息。</p></li><li><p><strong>DNS 解析</strong>：通过本地缓存或 DNS 查询将域名解析为目标服务器的 IP 地址。</p></li><li><p><strong>建立 TCP 连接（三次握手）</strong>：使用解析到的 IP 地址，通过 TCP 协议与目标服务器建立连接。</p></li><li><p><strong>IP 层处理与路由寻址</strong>：TCP 报文封装进 IP 数据报，由 IP 层根据路由表选择路径发往目标地址。</p></li><li><p><strong>MAC 地址解析（ARP）</strong>：在局域网内，IP 包需映射为 MAC 地址；若未知则发起 ARP 请求获取目标或网关 MAC。</p></li><li><p><strong>发送 HTTP 请求</strong>：建立连接后，浏览器发送 HTTP 请求获取网页资源。</p></li><li><p><strong>服务器响应</strong>：服务器处理请求后返回响应（状态码、响应头和响应体）。</p></li><li><p><strong>浏览器渲染页面</strong>：浏览器解析 HTML，构建 DOM，加载 CSS、JS 等资源，并渲染最终页面。</p></li><li><p><strong>TCP 连接断开（四次挥手）</strong>：页面加载完成后，TCP 连接被释放。</p></li></ol><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250725154619013.png" alt="时序图"></p><h2 id="2-DNS解析过程"><a href="#2-DNS解析过程" class="headerlink" title="2.DNS解析过程"></a>2.DNS解析过程</h2><blockquote><p>假设访问 <code>www.example.com</code>，但系统没有缓存，DNS 会经历以下步骤：</p></blockquote><h3 id="2-1-详细过程"><a href="#2-1-详细过程" class="headerlink" title="2.1 详细过程"></a>2.1 详细过程</h3><h4 id="1-浏览器缓存查询"><a href="#1-浏览器缓存查询" class="headerlink" title="1. 浏览器缓存查询"></a>1. <strong>浏览器缓存查询</strong></h4><ul><li>浏览器会先查自己的 DNS 缓存（上次解析过的域名-IP 记录）</li></ul><h4 id="2-操作系统缓存查询"><a href="#2-操作系统缓存查询" class="headerlink" title="2. 操作系统缓存查询"></a>2. <strong>操作系统缓存查询</strong></h4><ul><li>若浏览器无缓存，会查询本地操作系统缓存（如 Windows 的 DNS Client）</li></ul><h4 id="3-hosts-文件"><a href="#3-hosts-文件" class="headerlink" title="3. hosts 文件"></a>3. <strong>hosts 文件</strong></h4><ul><li>如果缓存无命中，操作系统会查 <code>hosts</code> 文件（静态配置域名-IP 对应）</li></ul><h4 id="4-本地-DNS-服务器查询（递归开始）"><a href="#4-本地-DNS-服务器查询（递归开始）" class="headerlink" title="4. 本地 DNS 服务器查询（递归开始）"></a>4. <strong>本地 DNS 服务器查询（递归开始）</strong></h4><ul><li>若本地都查不到，系统向配置的 <strong>本地 DNS（递归解析器）</strong> 发起请求</li><li>一般是运营商或公共 DNS（如 114.114.114.114 &#x2F; 8.8.8.8）</li></ul><h4 id="本地-DNS-执行“递归查询”过程："><a href="#本地-DNS-执行“递归查询”过程：" class="headerlink" title="本地 DNS 执行“递归查询”过程："></a>本地 DNS 执行“递归查询”过程：</h4><h5 id="4-1-根域名服务器（Root-Server）"><a href="#4-1-根域名服务器（Root-Server）" class="headerlink" title="4.1 根域名服务器（Root Server）"></a>4.1 根域名服务器（Root Server）</h5><ul><li>本地 DNS 向 <strong>根服务器</strong> 请求 <code>.com</code> 的解析方式</li><li>根服务器返回 <code>.com</code> 顶级域服务器的 IP</li></ul><h5 id="4-2-顶级域服务器（TLD-Server）"><a href="#4-2-顶级域服务器（TLD-Server）" class="headerlink" title="4.2 顶级域服务器（TLD Server）"></a>4.2 顶级域服务器（TLD Server）</h5><ul><li>本地 DNS 向 <code>.com</code> 服务器请求 <code>example.com</code> 的信息</li><li>TLD 返回 <code>example.com</code> 的权威 DNS 服务器地址</li></ul><h5 id="4-3-权威-DNS-服务器（Authoritative-Server）"><a href="#4-3-权威-DNS-服务器（Authoritative-Server）" class="headerlink" title="4.3 权威 DNS 服务器（Authoritative Server）"></a>4.3 权威 DNS 服务器（Authoritative Server）</h5><ul><li>本地 DNS 向权威 DNS 请求 <code>www.example.com</code> 的 A 记录</li><li>返回对应 IP，如 <code>93.184.216.34</code></li></ul><h4 id="5-结果返回并缓存"><a href="#5-结果返回并缓存" class="headerlink" title="5. 结果返回并缓存"></a>5. <strong>结果返回并缓存</strong></h4><ul><li>本地 DNS 把解析结果返回给操作系统</li><li>操作系统返回给浏览器</li><li>同时结果会被浏览器、操作系统、本地 DNS 分别缓存（通常 60~86400 秒）</li></ul><h3 id="2-2-精简版回答："><a href="#2-2-精简版回答：" class="headerlink" title="2.2 精简版回答："></a>2.2 精简版回答：</h3><p>DNS 解析的过程是将域名转换为 IP 地址，通常包括以下步骤：</p><ol><li>浏览器先查本地缓存；</li><li>如果缓存没有，操作系统会查 <code>hosts</code> 文件，再向配置的本地 DNS 服务器发起请求；</li><li>本地 DNS 服务器采用递归方式查询，过程如下：<ul><li>向根服务器查询 → 得到顶级域服务器地址</li><li>向顶级域服务器查询 → 得到权威 DNS 地址</li><li>向权威 DNS 查询 → 得到目标域名的 IP 地址</li></ul></li><li>本地 DNS 把解析结果返回给客户端，并缓存以加速后续解析。</li></ol><p>如果使用 CDN，还可能解析出 CNAME，再继续查询其对应的 A 记录。</p><p>整个过程基于 UDP（53端口），但若响应过大或需可靠性，则会使用 TCP。</p><hr><h3 id="2-3-DNS递归解析图示"><a href="#2-3-DNS递归解析图示" class="headerlink" title="2.3 DNS递归解析图示"></a>2.3 DNS递归解析图示</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250725155606747.png" alt="DNS递归解析"></p><h2 id="3-DNS-用的是哪种协议？为什么？"><a href="#3-DNS-用的是哪种协议？为什么？" class="headerlink" title="3.DNS 用的是哪种协议？为什么？"></a>3.DNS 用的是哪种协议？为什么？</h2><p>DNS 默认使用的是 <strong>UDP 协议（端口 53）</strong>，因为 DNS 查询本身数据量很小、请求响应模型简单，而且 UDP 无需连接建立，效率更高，适合高并发和实时性强的域名解析场景。</p><p>但在以下情况下 DNS 会使用 <strong>TCP</strong>：</p><ul><li>响应过大导致 UDP 被截断（TC 位被置位）；</li><li>主辅 DNS 区域传输；</li><li>启用安全传输（如 DNS over TLS）；</li><li>或服务端强制 TCP 连接以防攻击等。</li></ul><p>UDP 是无连接的，因此<strong>不需要三次握手和四次挥手</strong>。如果切换为 TCP，则会使用完整的连接建立与关闭流程。</p><h2 id="4-CNAME-出现在-DNS-查询的哪个阶段？它会被缓存吗？"><a href="#4-CNAME-出现在-DNS-查询的哪个阶段？它会被缓存吗？" class="headerlink" title="4.CNAME 出现在 DNS 查询的哪个阶段？它会被缓存吗？"></a>4.CNAME 出现在 DNS 查询的哪个阶段？它会被缓存吗？</h2><p>CNAME（Canonical Name）记录用于将一个域名设置为另一个域名的别名，它本身不指向 IP 地址，而是跳转去解析目标域名的 IP。<br>比如，<a href="http://www.example.com/">www.example.com</a> 设置为 CNAME 指向 example.com，那么解析请求会被转向后者，最终返回 IP 地址。<br>CNAME 的主要作用是统一域名解析管理、接入 CDN 或服务提供商系统等。但它有两个限制：</p><ul><li>不能用于根域名；</li><li>设置 CNAME 的域名不能再配置其他记录（如 A、MX 等）。</li></ul><p>解析 CNAME 时客户端需要多一次 DNS 查询跳转，但带来的灵活性和管理便利在实际生产环境中非常常见和重要。</p><p>CNAME 是一种由 权威 DNS 服务器返回的记录类型，表示某个域名是另一个域名的别名。它不会出现在操作系统或 hosts 缓存中，而是在 DNS 查询过程中由权威服务器返回。<br>当本地 DNS 服务器收到 CNAME 记录时，它会继续递归查询被指向的域名，直到最终解析出 IP 地址（A 或 AAAA 记录），然后把结果返回给客户端。<br>结果包括原始 CNAME 和最终的 IP 地址，一起缓存到本地 DNS 中，以加快后续解析。</p><h2 id="5-IP-协议的主要作用是什么？"><a href="#5-IP-协议的主要作用是什么？" class="headerlink" title="5.IP 协议的主要作用是什么？"></a>5.IP 协议的主要作用是什么？</h2><p>IP 协议工作在 OSI 网络层，主要负责逻辑寻址与数据包的路由转发。它为网络中的每个设备分配唯一的 IP 地址，并将上层（如 TCP&#x2F;UDP）传下来的数据封装为 IP 数据包。<br>IP 协议的核心职责包括：</p><ul><li>提供逻辑地址（源 IP、目标 IP）用于通信寻址；</li><li>根据路由表选择下一跳，跨网络转发数据包；</li><li>若数据包过大，负责分片与接收端重组；</li><li>控制 TTL 防止路由环路；</li><li>配合 ICMP 报文反馈网络错误信息。</li></ul><p>需要注意的是，IP 协议是无连接、尽力而为的，它不保证数据一定送达、也不保证顺序，可靠性由上层协议（如 TCP）来处理。</p><h2 id="6-有了IP协议为什么还要存在MAC协议，它的存在必要性是什么？"><a href="#6-有了IP协议为什么还要存在MAC协议，它的存在必要性是什么？" class="headerlink" title="6.有了IP协议为什么还要存在MAC协议，它的存在必要性是什么？"></a>6.有了IP协议为什么还要存在MAC协议，它的存在必要性是什么？</h2><p>IP 协议虽然提供了<strong>逻辑寻址</strong>（跨网络识别设备），但在<strong>真实的物理网络中，数据最终还是要通过链路层（如以太网）进行传输</strong>。而链路层不认识 IP 地址，它只通过 <strong>MAC 地址进行数据帧的收发</strong>。</p><p>MAC 地址的存在是因为网络通信中：</p><ol><li><p><strong>链路层负责点到点传输</strong></p><ul><li>网络中的数据必须以帧的形式从一台设备“准确送达”到另一台设备；</li><li>而帧的目标只能是设备的 MAC 地址，<strong>这才是真实网络中实际传输使用的地址</strong>。</li><li>MAC头部是每跳更新</li></ul></li><li><p><strong>IP 地址不适用于物理传输</strong></p><ul><li>IP 是逻辑地址，不固定，可能动态变化（如 DHCP）；</li><li>但物理设备识别和收发数据，需要固定的唯一标识（MAC）；</li><li>路由器在不同子网间转发包时会<strong>重写帧头中的 MAC 地址，但保留 IP 地址不变</strong>。</li></ul></li><li><p><strong>MAC + IP 分层设计更灵活</strong></p><ul><li>这种分层使得 IP 层关注逻辑路由、寻址；</li><li>MAC 层负责局部帧传输，分离职责，便于扩展（如 VLAN、ARP、广播隔离等）；</li><li>如果 IP 直接负责物理传输，那每个网络设备都要感知整个链路细节，会极度复杂。</li></ul></li></ol><p>总结起来就是</p><blockquote><p>IP 地址解决“去哪里”（路由），而 MAC 地址解决“怎么到达”（链路层传输） —— 两者缺一不可。</p><p>IP 像是“收件人地址”，MAC 就是“快递员找你门牌号的方式”</p><p>IP 确定目标在哪个城市&#x2F;公司，MAC 是你办公桌的编号，快递送进楼后靠 MAC 找人</p></blockquote><h3 id="那为什么不能直接用MAC传输？"><a href="#那为什么不能直接用MAC传输？" class="headerlink" title="那为什么不能直接用MAC传输？"></a>那为什么不能直接用MAC传输？</h3><p>MAC 地址只能在<strong>同一个局域网</strong>中有效，它<strong>不具备跨网段转发能力</strong>，交换机只能根据 MAC 转发数据，而无法实现多跳传输。</p><p>IP 是为了解决<strong>大规模网络的跨子网通信问题</strong>，支持：</p><ul><li>路由寻址</li><li>子网划分</li><li>动态分配</li><li>网络层转发控制</li></ul><p>因此，<strong>IP + MAC 是 OSI 模型中跨网络通信 + 物理交付的最佳组合设计。</strong><br><img src="https://gitee.com/zhangphh/images-collections/raw/master/mac.png" alt="IP 寻址 + MAC 传输（跨局域网转发）"></p><h2 id="7-ARP寻址过程是什么？"><a href="#7-ARP寻址过程是什么？" class="headerlink" title="7.ARP寻址过程是什么？"></a>7.ARP寻址过程是什么？</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/arp.png" alt="ARP寻址过程"><br>ARP（地址解析协议）工作在数据链路层与网络层之间，主要作用是：将 IP 地址解析为对应的 MAC 地址。</p><p>当一台主机要发送数据时，它会先检查本地 ARP 缓存是否有目标 IP 的 MAC。如果没有，就会发送一个 ARP 请求广播，询问：“谁是这个 IP？请告诉我你的 MAC 地址”。</p><p>网络中拥有该 IP 的主机会单播回复自己的 MAC 地址。主机收到响应后更新 ARP 缓存，并用该 MAC 地址封装以太网帧完成通信。</p><p>ARP 是<strong>局域网</strong>中 IP 和 MAC 协同工作的关键机制。<br>ARP 使用 以太网帧直接传输，不依赖 IP，不属于 TCP&#x2F;UDP 之上</p><h2 id="8-ARP-是否可以跨网段？如果目标-IP-不在局域网中怎么办？"><a href="#8-ARP-是否可以跨网段？如果目标-IP-不在局域网中怎么办？" class="headerlink" title="8.ARP 是否可以跨网段？如果目标 IP 不在局域网中怎么办？"></a>8.ARP 是否可以跨网段？如果目标 IP 不在局域网中怎么办？</h2><p>ARP 只能在同一个局域网中工作，因为它使用的是二层广播，而广播帧不会被路由器转发。</p><p>当目标 IP 不在本地子网中时，主机会将数据交给默认网关。此时主机会先通过 ARP 获取网关的 MAC 地址，然后把封装好的数据帧（目标 MAC 是网关的）发送给路由器。</p><p>路由器再根据目标 IP 的路由信息，转发到目标网络。整个过程中，ARP 始终只在本地子网中使用，用来解析“下一跳”的 MAC。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/cross_arp.png" alt="跨网段ARP"></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL innodb锁机制原理</title>
    <link href="/2025/06/07/MySQL-innodb%E9%94%81%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/07/MySQL-innodb%E9%94%81%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/zhangphh/images-collections/raw/master/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%A8%E6%99%AF%E5%9B%BE.png" alt="MySQL锁机制全景图"></p><h1 id="1-锁的类型"><a href="#1-锁的类型" class="headerlink" title="1.锁的类型"></a>1.锁的类型</h1><h2 id="1-1-占有模式"><a href="#1-1-占有模式" class="headerlink" title="1.1 占有模式"></a>1.1 占有模式</h2><ul><li>共享锁 Share Lock&#x2F;S锁</li><li>排他锁 Exclusive Lock&#x2F;X锁</li></ul><table><thead><tr><th></th><th>S</th><th>X</th></tr></thead><tbody><tr><td>S</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><ul><li>对行记录加X锁<br>insert、update、delete以及显式的 for update 语句都会对行记录加X锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;test&#x27;</span>);<br><span class="hljs-keyword">update</span> table_name <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>S锁<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> lock <span class="hljs-keyword">in</span> share mode;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-2-锁的类型"><a href="#1-2-锁的类型" class="headerlink" title="1.2 锁的类型"></a>1.2 锁的类型</h2><ul><li>记录锁 Record Lock: 锁定具体的行，依赖于索引，分为独占和共享两种<ul><li>依附于索引，因此查询时命中所以尤为关键</li></ul></li><li>间隙锁 Gap Lock: 对记录行之间的空隙加锁<ul><li>间隙锁不存在共享或排他的概念，它的目标就是拦截间隙范围内即将到来的insert行为，因此间隙锁生效的前提依赖于insert行为</li><li>间隙锁也是依附于索引而存在，具体载体是间隙所在范围右边界遇到的第一条记录对应的索引，倘若右边界不存在则使用无穷大进行补齐</li></ul></li><li>临键锁 Next-Key Lock: 行锁和间隙锁的组合，本质上为间隙锁加右边界形成的组合<ul><li>Gap Lock + 右边界首条记录的行锁(Record Lock)形成的组合锁，锁定的是左开右闭的区间</li></ul></li><li>表级意向锁 Intention Lock: 在具体操作行为之前进行意向声明，用于判断是否可以进行操作<ul><li>为了提高粗粒度所性能而设置的一种预判机制，所有申请行锁的操作都要申请到相同占有模式下的表级意向锁</li><li>表级意向共享锁(IS Lock)</li><li>表级意向排他锁(IX Lock)</li></ul></li><li>插入意向锁 Insert Intention Lock: 插入前置校验步骤，配合间隙锁使用</li><li>死锁<ul><li>超时回滚：产生死锁的直接导火索是等锁行为，因此当等待时间超过一定阈值之后就超时回滚可避免</li><li>等待图wait-for<br>graph机制：这是innodb主动探测死锁的一种机制，针对事务的等锁依赖关系构筑一条链表，当链表成环时表示存在死锁。此时innodb会选择事务进行回滚以破坏死锁，这里选择事务时会选择最小权重的，即事务涉及修改和锁住的行记录数最小</li></ul></li></ul><h1 id="2-隔离级别与锁之间的关系"><a href="#2-隔离级别与锁之间的关系" class="headerlink" title="2.隔离级别与锁之间的关系"></a>2.隔离级别与锁之间的关系</h1><h2 id="2-1-一致性非锁定读"><a href="#2-1-一致性非锁定读" class="headerlink" title="2.1 一致性非锁定读"></a>2.1 一致性非锁定读</h2><p>innodb针对commited-read 和 repeatable-read 两种隔离级采用MVCC机制作为应对策略<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/mvcc2.png" alt="版本链"></p><p>MVCC实现上可以拆分为<strong>版本连结构</strong>与<strong>版本策略选择</strong>两个部分</p><ul><li>版本链结构：每当事务修改一行数据时，会基于写时复制机制生成一个副本，并通过指针指向上一个版本，如此形成一个链表状的数据结构，即版本链</li><li>版本选择策略：针对普通非锁定select操作本质上是便利版本连选择合适的版本进行读取，以保证查询视角的一致性</li></ul><p>因此不同的隔离级别其实是在版本连中的选择策略不同</p><h3 id="2-1-1-版本链"><a href="#2-1-1-版本链" class="headerlink" title="2.1.1 版本链"></a>2.1.1 版本链</h3><ul><li>row_id: 非必须，innodb采用非聚簇索引，必须存在主键作为数据的存储载体，如果未现实的声明主键，则会使用此隐藏字段row_id作为主键索引</li><li>transaction_id: 事务id，表示一个版本是哪个事务生成的，是全局递增ID</li><li>roll_pointer: 回滚指针，指向上一个版本，用于版本链的构建</li></ul><p>innodb中为了支持事务的回滚启用了undo-log机制，这也天然支持了版本链而不需额外的成本开销。只不过为了保证MVCC中数据视图的一致性，针对undo-log中老版本日志回收需要适当延后，保证知道不存在更小的活跃事务id存在时才能回收</p><h3 id="2-2-2-选择策略"><a href="#2-2-2-选择策略" class="headerlink" title="2.2.2 选择策略"></a>2.2.2 选择策略</h3><p>ReadView机制：在事务启动时会生成一个ReadView，用于描述当前事务的可见性范围，在事务执行过程中会根据ReadView中的信息来选择合适的版本进行读取，ReadView包含以下几部分信息</p><ul><li>m_ids: 当前处于活跃状态的事务ID列表<ul><li>所谓活跃即是未提交，用于遍历版本链时判断是正式数据还是草稿数据</li></ul></li><li>up_limit_id: m_ids中最小活跃事务ID<ul><li>undo-log版本链中，对于id &lt; up_limit_id的老版本数据可以及进行回收</li></ul></li><li>low_limit_id: 分配给下一个事务的ID，全局唯一递增</li><li>creator_trx_id: 指的是创建该 Read View 的事务的事务 id</li></ul><p>在RC与RR隔离级别下，非锁定读(即普通select)都会获取ReadView，并遍历版本链选择合适的版本进行读取</p><ul><li>RC下每次select都会生成一个新的ReadView，因此每次select读取的都是当前时刻的最新数据</li><li>RR下只在事务开启时获取一次ReadView，并在整个生命周期内进行复用。同时还需保证所选的事务id要小于low_limit_id，即选择的事务id要在事务开启之前，否则会读取到未来的事务数据，这就保证了事务的可重复读</li></ul><h3 id="2-2-3-RC与RR隔离级别下的一致性非锁定读"><a href="#2-2-3-RC与RR隔离级别下的一致性非锁定读" class="headerlink" title="2.2.3 RC与RR隔离级别下的一致性非锁定读"></a>2.2.3 RC与RR隔离级别下的一致性非锁定读</h3><h4 id="2-2-3-1-RC隔离级别"><a href="#2-2-3-1-RC隔离级别" class="headerlink" title="2.2.3.1 RC隔离级别"></a>2.2.3.1 RC隔离级别</h4><p>假设某一时刻A、B两个事务开启后生成的ReadView如下</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250605161525487.png" alt="RC隔离级别"></p><p>事务A先于事务B提交，此时如果事务B再执行普通select操作，在当前隔离级别下事务B生成新的的ReadView如下所示</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250605162517358.png" alt="事务B ReadView"></p><p>此时事务A的事务Id不在当前事务B的ReadView中的活跃事务id列表中，因此事务A的版本链中的数据对事务B可见，因此事务B可以读取到事务A的修改数据<br>也就是读取已提交</p><h4 id="2-2-3-2-RR隔离级别"><a href="#2-2-3-2-RR隔离级别" class="headerlink" title="2.2.3.2 RR隔离级别"></a>2.2.3.2 RR隔离级别</h4><p>假设某一时刻A、B两个事务开启后生成的ReadView如下</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250605161525487.png" alt="RC隔离级别"></p><p>事务A先于事务B提交，此时如果事务B再执行普通select操作，并不会生成新的ReadView<br>因此事务A的Id&#x3D;101还在事务B的m_ids中，处于活跃的事务id列表中，因此事务A的版本链中的数据对事务B不可见，因此事务B无法读取到事务A的提交数据<br>这就保证了事务B在整个事务生命周期内读取到的都是同一份数据，即可重复读</p><h2 id="2-2-一致性锁定读-RR"><a href="#2-2-一致性锁定读-RR" class="headerlink" title="2.2 一致性锁定读(RR)"></a>2.2 一致性锁定读(RR)</h2><ul><li>插入阻塞：插入之前定位到该记录在B+树的位置，如果该记录的下一条记录上存在间隙锁，则此记录插入会阻塞</li><li>幻读：在同一个事务中，两次查询的结果集不同</li><li>行级锁：记录所、间隙锁、临键锁</li></ul><p>根据上述三个条件即可分析在各种事务中的锁的使用情况：</p><p><strong>注意事项</strong>：所有的select均在事务中(begin&#x2F;commit&#x2F;rollback)执行</p><h3 id="2-2-1-唯一索引"><a href="#2-2-1-唯一索引" class="headerlink" title="2.2.1 唯一索引"></a>2.2.1 唯一索引</h3><p>测试的user表如下</p><table><thead><tr><th>id主键索引</th><th>1</th><th>5</th><th>10</th><th>15</th><th>20</th></tr></thead><tbody><tr><td>name列</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td></tr><tr><td>age列</td><td>19</td><td>21</td><td>22</td><td>20</td><td>39</td></tr></tbody></table><ul><li>等值查询记录存在<ul><li>sql: <code>select * from user where id = 1 for update;</code></li><li>锁<ul><li>id&#x3D;1的X锁(记录锁)，仅需对这个记录上锁即可避免幻读(如被其他事务删除)</li></ul></li></ul></li><li>等值查询记录不存在<ul><li>sql: <code>select * from user where id = 2 for update;</code></li><li>锁<ul><li>(1,5)-&gt;间隙锁，加在了id&#x3D;5上，避免其他事务插入id&#x3D;2的记录，其他id&#x3D;3、4的记录插入时同样会被阻塞</li></ul></li></ul></li><li>范围查询<ul><li>大于<ul><li>sql: <code>select * from user where id &gt; 15 for update;</code></li><li>锁<ul><li>(15,20]-&gt; 临键锁，加在了20上. (20,+∞]-&gt; 临键锁</li></ul></li><li>大于时，比较值存不存在其实是不影响的，如果这里id取了17，加锁情况还是不变的，可以仔细想一下</li></ul></li><li>大于等于<ul><li>sql: <code>select * from user where id &gt;= 15 for update;</code></li><li>锁<ul><li>id&#x3D;15 -&gt; 记录锁, (15,20]-&gt; 临键锁，加在了20上. (20,+∞]-&gt; 临键锁</li></ul></li><li>大于等于时如果比较值不存在时，如id取17，则会加(15,20]-&gt; 临键锁，加在了20上. (20,+∞]-&gt; 临键锁</li></ul></li><li>小于<ul><li>sql: <code>select * from user where id &lt; 7 for update;</code></li><li>锁<ul><li>(-∞,1]-&gt; 临键锁，加在了1上. (1,5]-&gt; 临键锁, (5,10)-&gt;间隙锁，加在了10上</li></ul></li><li>如果比较值(id&#x3D;7)存在的话，加锁情况就变成了：(-∞,1]-&gt; 临键锁，加在了1上. (1,5]-&gt; 临键锁, (5,7)-&gt;间隙锁, 7即使被删除也不会导致当前事务产生幻读，因此5-7是间隙锁</li></ul></li><li>小于等于<ul><li>sql: <code>select * from user where id &lt;= 5 for update;</code></li><li>锁<ul><li>(-∞,1]-&gt; 临键锁，加在了1上. (1,5]-&gt; 临键锁，加在5上</li></ul></li><li>如果比较值不存在，假设比较值为7，则加锁情况为：(-∞,1]-&gt; 临键锁，加在了1上. (1,5]-&gt; 临键锁，加在5上. (5,10)-&gt;间隙锁，加在了10上</li></ul></li><li>小于<ul><li>sql: <code>select * from user where id &lt; 5 for update;</code></li><li>锁<ul><li>(-∞,1]-&gt; 临键锁，加在了1上. (1,5)-&gt; 临键锁，加在5上</li></ul></li><li>如果比较值不存在，假设比较值为7，则加锁情况为：(-∞,1]-&gt; 临键锁，加在了1上. (1,5]-&gt; 临键锁，加在5上. (5,10)-&gt;间隙锁，加在了10上</li></ul></li></ul></li></ul><p><strong>总结</strong><br>至此，唯一键索引在RR隔离级别下的一致性锁定读的锁情况就分析完了，有几点需要注意的：</p><ul><li>唯一索引如果是二级索引，那么加锁时不仅锁住二级索引，而且会对对应的主键索引值也进行加锁</li><li>唯一索引如果是主键索引，那么加锁时只会对主键索引进行加锁</li><li>分析事务的加锁情况要带着问题去分析，即如何通过行级锁解决幻读的问题，需要怎么设计才可以避免幻读</li></ul><h3 id="2-2-2-非唯一索引"><a href="#2-2-2-非唯一索引" class="headerlink" title="2.2.2 非唯一索引"></a>2.2.2 非唯一索引</h3><p>user表测试数据如下</p><table><thead><tr><th>age非唯一索引</th><th>19</th><th>20</th><th>21</th><th>22</th><th>39</th></tr></thead><tbody><tr><td>id主键索引</td><td>1</td><td>15</td><td>5</td><td>10</td><td>20</td></tr><tr><td>name列</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td></tr></tbody></table><ul><li>等值查询值不存在<ul><li>sql: <code>select * from user where age = 25 for update;</code></li><li>锁<ul><li>age索引: (22,39)-&gt; 间隙锁，加在了39上</li><li>这会导致age为22和39的新记录在某些情况被阻塞下不可插入，不能插入的情况就是当前记录的下一个记录上存在间隙锁<ul><li>age&#x3D;22,id&#x3D;5 -&gt; 下一条记录为age&#x3D;22,id&#x3D;10，不存在间隙锁，可以插入</li><li>age&#x3D;22,id&#x3D;12 -&gt; 下一条记录为age&#x3D;39,id&#x3D;20，存在间隙锁，不能插入</li><li>age&#x3D;39,id&#x3D;15 -&gt; 下一条记录为age&#x3D;39,id&#x3D;20，存在间隙锁，不能插入</li><li>age&#x3D;39,id&#x3D;22 -&gt; 下一条记录不存在，不存在间隙锁，能插入</li></ul></li></ul></li></ul></li><li>等值查询值存在<ul><li>sql: <code>select * from user where age = 22 for update;</code></li><li>锁<ul><li>age索引: (21,22]-&gt; 临键锁，加在了22上. (22,39)-&gt; 间隙锁，加在了39上, id&#x3D;10-&gt;记录锁，加在了id&#x3D;10上</li><li>同样对于age&#x3D;21和age&#x3D;39也是存在一些可以插入和不能插入的情况，同上</li></ul></li></ul></li><li>范围查询<ul><li>大于等于<ul><li>sql: <code>select * from user where age &gt;= 22  for update;</code></li><li>锁<ul><li>(21,22]-&gt; 临键锁，加在了22上. (22,39]-&gt; 临键锁，加在了39上,(39,+∞]临键锁, id&#x3D;10和id&#x3D;20-&gt;记录锁，加在了id&#x3D;10和id&#x3D;20上</li><li>同样对于age&#x3D;21和age&#x3D;39也是存在一些可以插入和不能插入的情况，同上</li></ul></li><li>如果比较值不存在，假设比较值为23，则加锁情况为：(22,39]-&gt; 临键锁，加在了39上,(39,+∞]临键锁, id&#x3D;20-&gt;记录锁，加在了id&#x3D;20上</li></ul></li><li>小于等于<ul><li>sql: <code>select * from user where age &lt;= 20  for update;</code></li><li>锁<ul><li>(-∞,19]-&gt; 临键锁，加在了19上. (19,20]-&gt; 临键锁，加在20上，(20,21)-&gt;间隙锁，加在了21上,id&#x3D;1,id&#x3D;15-&gt;记录锁，加在了id&#x3D;1,id&#x3D;15上</li></ul></li></ul></li><li>其他情况<ul><li>按照上述方式分析即可，不做过多描述</li></ul></li></ul></li></ul><h1 id="3-MySQL的RR级别完全解决了幻读问题吗？"><a href="#3-MySQL的RR级别完全解决了幻读问题吗？" class="headerlink" title="3.MySQL的RR级别完全解决了幻读问题吗？"></a>3.MySQL的RR级别完全解决了幻读问题吗？</h1><p>答案是没有，只是在很大程度上避免了幻读<br>考虑下面情况：</p><table><thead><tr><th></th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>时刻1</td><td>begin;<br>select * from user where id &gt; 5;&#x2F;&#x2F; 无结果</td><td></td></tr><tr><td>时刻2</td><td></td><td>begin;<br> insert into user (5,19,’a’);<br>commit;</td></tr><tr><td>时刻3</td><td>update user set name &#x3D; ‘b’ where id&#x3D;5;</td><td></td></tr><tr><td>时刻4</td><td>select * from user where id &gt; 5; &#x2F;&#x2F; 输出id&#x3D;5的记录</td><td></td></tr></tbody></table><ul><li>时刻3事务A更新id&#x3D;5的记录，那这条记录的隐藏列trx_id将会变成事务A的事务Id，这样这条记录在事务A的ReadView中就变得可见，因此时刻4事务A的查询就可以查得到</li><li>此中情况也就导致了幻读</li></ul><p>如何解决这种问题？<br>答案是在事务A里尽可能早的加锁处理，如在时刻1：<code>select * from user where id &gt; 5 for update;</code><br>这样事务B的插入就会被阻塞，直到事务A提交或回滚，这样就避免了幻读的问题</p><h1 id="4-死锁构建"><a href="#4-死锁构建" class="headerlink" title="4.死锁构建"></a>4.死锁构建</h1><p>order表测试数据如下</p><table><thead><tr><th>id</th><th>order_id</th><th>desc</th></tr></thead><tbody><tr><td>1</td><td>1001</td><td>aaa</td></tr><tr><td>2</td><td>1002</td><td>bbb</td></tr><tr><td>3</td><td>1003</td><td>ccc</td></tr><tr><td>4</td><td>1004</td><td>ddd</td></tr><tr><td>5</td><td>1005</td><td>eee</td></tr><tr><td>6</td><td>1006</td><td>fff</td></tr></tbody></table><h2 id="4-1-死锁构建"><a href="#4-1-死锁构建" class="headerlink" title="4.1 死锁构建"></a>4.1 死锁构建</h2><table><thead><tr><th></th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>时刻1</td><td>begin;</td><td>begin;</td></tr><tr><td>时刻2</td><td>select id from order where order_id &#x3D; 1007 for update;</td><td></td></tr><tr><td>时刻3</td><td></td><td>select id from order where order_id &#x3D; 1008 for update;</td></tr><tr><td>时刻4</td><td>insert into order value(7,1007,’ggg’);</td><td></td></tr><tr><td>时刻5</td><td></td><td>insert into order value(8,1008,’ggg’);</td></tr></tbody></table><ul><li>上述情况下时刻2与时刻3都进行当前读，会获取到(1006,+∞]的临键锁，因为临键锁是相互兼容的，因此时刻2与时刻3都可以获取到(1006,+∞]的临键锁</li><li>时刻4事务A进行插入，发现存在(1006,+∞]的临键锁，因此事务A会被阻塞，等待事务B释放锁</li><li>时刻5事务B进行插入，发现存在(1006,+∞]的临键锁，因此事务B也会被阻塞，等待事务A释放锁</li><li>此时就会出现死锁</li></ul><h2 id="4-2-同一事务锁冲突问题"><a href="#4-2-同一事务锁冲突问题" class="headerlink" title="4.2 同一事务锁冲突问题"></a>4.2 同一事务锁冲突问题</h2><p>继续4.1事务执行情况，仅考虑事务A</p><ul><li>时刻2进行当前读，获取到(1006,+∞]的临键锁</li><li>时刻4插入，获取插入意向锁，发现待插入位置存在临键锁，会发生锁冲突，但是因为两个操作是同一事务的，所以时刻4在A事务中是能正常执行的，即MySQL允许同一事务内的操作获取冲突的锁。</li></ul><h2 id="4-3-死锁避免"><a href="#4-3-死锁避免" class="headerlink" title="4.3 死锁避免"></a>4.3 死锁避免</h2><ul><li>等待超时</li><li>主动死锁检测，通过wait-for图检测死锁，发现死锁后选择一个事务进行回滚，释放锁，避免死锁</li><li>业务上避免死锁，进行预防</li></ul><h1 id="5-insert加锁-RR隔离级别"><a href="#5-insert加锁-RR隔离级别" class="headerlink" title="5.insert加锁(RR隔离级别)"></a>5.insert加锁(RR隔离级别)</h1><p>插入是会检查待插入记录的下一条记录是否存在间隙锁，如果存在就生成插入意向锁，锁的状态设置为等待，对外表现即为插入阻塞。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606174307783.png" alt="基本加锁流程"><br>获取表级IX锁 → 获取插入意向锁 → 检查唯一约束 → 根据情况加X锁或S锁</p><h2 id="5-1-唯一键冲突加锁机制"><a href="#5-1-唯一键冲突加锁机制" class="headerlink" title="5.1 唯一键冲突加锁机制"></a>5.1 唯一键冲突加锁机制</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606174520154.png" alt="唯一键冲突加锁机制"></p><p>唯一键冲突时会加上S锁，而不是简单的返回错误</p><h2 id="5-2-唯一键冲突加S锁原因"><a href="#5-2-唯一键冲突加S锁原因" class="headerlink" title="5.2 唯一键冲突加S锁原因"></a>5.2 唯一键冲突加S锁原因</h2><h3 id="5-2-1-防止幻读"><a href="#5-2-1-防止幻读" class="headerlink" title="5.2.1 防止幻读"></a>5.2.1 防止幻读</h3><p>防止在当前事务第一次插入失败，记录被其他事务删除后本事务重试插入成功导致幻读问题<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606174756779.png" alt="防止幻读"></p><h3 id="5-2-2-确保唯一性约束的正确性"><a href="#5-2-2-确保唯一性约束的正确性" class="headerlink" title="5.2.2 确保唯一性约束的正确性"></a>5.2.2 确保唯一性约束的正确性</h3><p>唯一键冲突时加上S锁让其他事务按顺序处理，避免两者都成功<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606174924946.png" alt="确保唯一性约束的正确性"></p><h3 id="5-2-3-与间隙锁协同工作"><a href="#5-2-3-与间隙锁协同工作" class="headerlink" title="5.2.3 与间隙锁协同工作"></a>5.2.3 与间隙锁协同工作</h3><p>与间隙锁协同工作增强隔离性<br>在非主键的唯一索引发生冲突时除了对记录加S锁还会加上间隙锁，即S类型临键锁，对与主键导致的唯一键冲突会对此记录加上记录锁<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606175135370.png" alt="与间隙锁协同工作"></p><h2 id="5-3-S锁的工作过程"><a href="#5-3-S锁的工作过程" class="headerlink" title="5.3 S锁的工作过程"></a>5.3 S锁的工作过程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606175850610.png" alt="S锁的工作过程"></p><h2 id="5-4-具体示例"><a href="#5-4-具体示例" class="headerlink" title="5.4 具体示例"></a>5.4 具体示例</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250606175917203.png" alt="具体示例"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka分区重分配与Rebalance过程</title>
    <link href="/2025/05/31/kafka%E5%88%86%E5%8C%BA%E9%87%8D%E5%88%86%E9%85%8D%E4%B8%8ERebalance%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/05/31/kafka%E5%88%86%E5%8C%BA%E9%87%8D%E5%88%86%E9%85%8D%E4%B8%8ERebalance%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Kafka分区重分配"><a href="#1-Kafka分区重分配" class="headerlink" title="1.Kafka分区重分配"></a>1.Kafka分区重分配</h1><p>Kafka分区重分配是Kafka集群管理中的一个重要操作，它涉及将分区从一组broker移动到另一组broker。下面我将详细分析分区重分配的触发场景、策略以及可能带来的问题。</p><h2 id="1-1-分区重分配的触发场景"><a href="#1-1-分区重分配的触发场景" class="headerlink" title="1.1 分区重分配的触发场景"></a>1.1 分区重分配的触发场景</h2><ol><li>集群扩容 ：当向Kafka集群添加新的broker节点时，需要将现有分区重新分配到新节点上以实现负载均衡</li><li>broker下线 ：当需要下线某个broker时，需要将该broker上的分区迁移到其他broker上</li><li>broker故障 ：当broker发生故障且无法在短时间内恢复时，可能需要将其上的分区重新分配</li><li>负载不均衡 ：当集群中各broker负载不均衡时，可以通过重分配来平衡负载</li><li>机架感知调整 ：为了提高可用性，可能需要将分区分布在不同的机架上</li><li>硬件升级&#x2F;降级 ：当某些broker的硬件配置发生变化时，可能需要调整分区分配</li><li>网络拓扑变化 ：当数据中心网络拓扑发生变化时，可能需要调整分区分布</li><li>业务需求变化 ：某些topic的重要性或流量模式发生变化，需要调整其分区分配</li><li>磁盘空间不足 ：某些broker的磁盘空间接近阈值，需要将部分分区迁移出去</li></ol><h2 id="1-2-分区重分配策略"><a href="#1-2-分区重分配策略" class="headerlink" title="1.2 分区重分配策略"></a>1.2 分区重分配策略</h2><ol><li><p>均衡分配策略 ：</p><ul><li>尽量使每个broker上的分区数量相等</li><li>尽量使每个broker上的leader分区数量相等</li><li>尽量使每个broker上的数据量均衡</li></ul></li><li><p>机架感知策略 ：</p><ul><li>将同一分区的副本分布在不同的机架上，提高容灾能力</li><li>避免将同一分区的所有副本放在同一机架上</li></ul></li><li><p>自定义策略 ：</p><ul><li>基于broker的资源情况（CPU、内存、磁盘、网络）进行分配</li><li>基于topic的重要性进行优先级分配</li></ul></li><li><p>最小移动策略 ：</p><ul><li>在满足均衡目标的前提下，尽量减少数据迁移量</li><li>优先移动小分区，减少网络和磁盘I&#x2F;O压力</li></ul></li></ol><h2 id="1-3-重分配过程"><a href="#1-3-重分配过程" class="headerlink" title="1.3 重分配过程"></a>1.3 重分配过程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162223.png" alt="重分配过程"></p><h2 id="1-4-重分配可能导致的问题"><a href="#1-4-重分配可能导致的问题" class="headerlink" title="1.4 重分配可能导致的问题"></a>1.4 重分配可能导致的问题</h2><h3 id="1-性能影响"><a href="#1-性能影响" class="headerlink" title="1. 性能影响"></a>1. 性能影响</h3><ul><li>增加网络负载 ：数据复制会占用大量网络带宽</li><li>增加磁盘I&#x2F;O ：源broker需要读取数据，目标broker需要写入数据</li><li>增加CPU负载 ：数据复制和验证会消耗CPU资源</li><li>可能影响生产者和消费者性能 ：重分配期间可能导致延迟增加</li></ul><h3 id="2-可用性风险"><a href="#2-可用性风险" class="headerlink" title="2. 可用性风险"></a>2. 可用性风险</h3><ul><li>Leader切换增多 ：重分配过程中可能发生多次leader切换，影响服务稳定性</li><li>ISR收缩 ：如果新副本追赶速度慢，可能导致ISR收缩，增加数据丢失风险</li><li>临时不一致 ：在重分配过程中，可能出现数据临时不一致的情况</li></ul><h3 id="3-资源竞争"><a href="#3-资源竞争" class="headerlink" title="3. 资源竞争"></a>3. 资源竞争</h3><ul><li>与正常业务竞争资源 ：重分配会与正常的生产和消费操作竞争资源</li><li>可能触发限流 ：为了保护集群，可能需要对重分配进行限流，延长完成时间</li></ul><h3 id="4-操作风险"><a href="#4-操作风险" class="headerlink" title="4. 操作风险"></a>4. 操作风险</h3><ul><li>重分配失败 ：如果重分配过程中出现问题，可能需要手动干预</li><li>元数据不一致 ：如果ZooKeeper操作失败，可能导致元数据不一致</li><li>连锁反应 ：一个分区的重分配问题可能影响其他分区的重分配</li></ul><h2 id="1-5-重分配过程中的数据流向"><a href="#1-5-重分配过程中的数据流向" class="headerlink" title="1.5 重分配过程中的数据流向"></a>1.5 重分配过程中的数据流向</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162248.png" alt="重分配过程中的数据流向"></p><h2 id="1-6-减轻重分配影响的策略"><a href="#1-6-减轻重分配影响的策略" class="headerlink" title="1.6 减轻重分配影响的策略"></a>1.6 减轻重分配影响的策略</h2><ol><li>分批进行 ：不要同时重分配太多分区，分批进行以减轻影响</li><li>选择低峰时段 ：在业务低峰期进行重分配</li><li>设置限流 ：限制重分配的带宽使用，避免影响正常业务</li><li>监控关键指标 ：密切监控集群状态，发现异常及时调整</li><li>准备回滚方案 ：制定重分配失败时的回滚策略</li><li>优先处理小分区 ：先重分配数据量小的分区，减少影响</li></ol><h2 id="1-7-重分配前的准备工作"><a href="#1-7-重分配前的准备工作" class="headerlink" title="1.7 重分配前的准备工作"></a>1.7 重分配前的准备工作</h2><ol><li>评估数据量 ：评估需要迁移的数据总量</li><li>评估网络带宽 ：确保网络带宽足够支持数据迁移</li><li>检查磁盘空间 ：确保目标broker有足够的磁盘空间</li><li>制定详细计划 ：包括分批策略、时间安排和回滚方案</li><li>通知相关团队 ：提前通知可能受影响的业务团队<br>通过合理规划和执行分区重分配，可以在保证集群稳定性的同时，实现资源的有效利用和负载的均衡分布。</li></ol><h1 id="2-Kafka的Rebalance过程详解"><a href="#2-Kafka的Rebalance过程详解" class="headerlink" title="2.Kafka的Rebalance过程详解"></a>2.Kafka的Rebalance过程详解</h1><p>Kafka的Rebalance是消费者组（Consumer Group）中的一个重要机制，它负责在消费者加入或离开消费者组时重新分配分区。下面我将详细分析Rebalance的触发条件、过程和策略。</p><h2 id="2-1-Rebalance的触发条件"><a href="#2-1-Rebalance的触发条件" class="headerlink" title="2.1 Rebalance的触发条件"></a>2.1 Rebalance的触发条件</h2><ol><li><strong>消费者加入消费者组</strong>：新消费者启动并加入组时</li><li><strong>消费者离开消费者组</strong>：消费者正常关闭或崩溃时</li><li><strong>消费者会话超时</strong>：消费者未能及时发送心跳，被视为死亡</li><li><strong>消费者主动离开</strong>：消费者调用<code>unsubscribe()</code>方法</li><li><strong>订阅的Topic变化</strong>：消费者组订阅的Topic列表发生变化</li><li><strong>Topic的分区数量变化</strong>：管理员增加了Topic的分区数</li><li><strong>消费者组配置变更</strong>：某些配置变更可能触发Rebalance</li></ol><h2 id="2-2-Rebalance过程"><a href="#2-2-Rebalance过程" class="headerlink" title="2.2 Rebalance过程"></a>2.2 Rebalance过程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162328.png" alt="Rebalance过程"></p><h2 id="2-3-详细的Rebalance流程"><a href="#2-3-详细的Rebalance流程" class="headerlink" title="2.3 详细的Rebalance流程"></a>2.3 详细的Rebalance流程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162356.png" alt="详细的Rebalance流程"></p><h2 id="2-4-Rebalance策略"><a href="#2-4-Rebalance策略" class="headerlink" title="2.4 Rebalance策略"></a>2.4 Rebalance策略</h2><p>Kafka提供了多种分区分配策略，可以通过<code>partition.assignment.strategy</code>配置：</p><h3 id="1-Range策略（默认）"><a href="#1-Range策略（默认）" class="headerlink" title="1. Range策略（默认）"></a>1. Range策略（默认）</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162416.png" alt="Range策略"></p><h3 id="2-RoundRobin策略"><a href="#2-RoundRobin策略" class="headerlink" title="2. RoundRobin策略"></a>2. RoundRobin策略</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162438.png" alt="RoundRobin策略"></p><h3 id="3-Sticky策略"><a href="#3-Sticky策略" class="headerlink" title="3. Sticky策略"></a>3. Sticky策略</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162457.png" alt="Sticky策略"></p><h3 id="4-合作式Rebalance策略（Cooperative-Rebalance）"><a href="#4-合作式Rebalance策略（Cooperative-Rebalance）" class="headerlink" title="4. 合作式Rebalance策略（Cooperative Rebalance）"></a>4. 合作式Rebalance策略（Cooperative Rebalance）</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162517.png" alt="合作式Rebalance策略"></p><h2 id="2-5-Rebalance的问题与优化"><a href="#2-5-Rebalance的问题与优化" class="headerlink" title="2.5 Rebalance的问题与优化"></a>2.5 Rebalance的问题与优化</h2><ol><li><strong>停止消费问题</strong>：传统Rebalance期间，所有消费者都会停止消费，导致服务暂时不可用</li><li><strong>重复消费问题</strong>：如果消费者没有及时提交偏移量，Rebalance后可能导致重复消费</li><li><strong>消费延迟问题</strong>：频繁的Rebalance会导致消费延迟增加</li></ol><p>优化方法：</p><ul><li>使用静态成员ID（<code>group.instance.id</code>）减少不必要的Rebalance</li><li>使用合作式Rebalance策略（<code>partition.assignment.strategy=cooperative-sticky</code>）</li><li>合理设置<code>session.timeout.ms</code>和<code>heartbeat.interval.ms</code></li><li>避免消费者处理时间过长导致心跳超时</li></ul><p>通过合理配置和选择适当的分配策略，可以显著减少Rebalance对系统的影响，提高Kafka消费者的稳定性和效率。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka Controller控制器</title>
    <link href="/2025/05/31/Kafka-Controller%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>/2025/05/31/Kafka-Controller%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka-Controller控制器职责"><a href="#Kafka-Controller控制器职责" class="headerlink" title="Kafka Controller控制器职责"></a>Kafka Controller控制器职责</h1><p>Kafka Controller是Kafka集群中的一个核心组件，负责管理和协调整个集群的状态。在Kafka集群中，只有一个broker会被选举为Controller，它承担着集群管理的重要职责。</p><h2 id="1-Controller的主要职责"><a href="#1-Controller的主要职责" class="headerlink" title="1.Controller的主要职责"></a>1.Controller的主要职责</h2><h3 id="1-1-Broker管理"><a href="#1-1-Broker管理" class="headerlink" title="1.1 Broker管理"></a>1.1 Broker管理</h3><ul><li><strong>监控Broker状态</strong>：实时监控集群中所有Broker的上线和下线状态</li><li><strong>处理Broker故障</strong>：当Broker宕机时，负责重新分配该Broker上的分区leader</li><li><strong>维护集群成员信息</strong>：管理集群中的Broker列表和元数据</li></ul><h3 id="1-2-Topic管理"><a href="#1-2-Topic管理" class="headerlink" title="1.2 Topic管理"></a>1.2 Topic管理</h3><ul><li><strong>创建Topic</strong>：处理创建Topic的请求，分配分区和副本</li><li><strong>删除Topic</strong>：协调Topic的删除过程</li><li><strong>修改Topic配置</strong>：处理Topic配置变更，如分区数量的增加</li><li><strong>Topic元数据管理</strong>：维护Topic的分区分配信息</li></ul><h3 id="1-3-分区和副本管理"><a href="#1-3-分区和副本管理" class="headerlink" title="1.3 分区和副本管理"></a>1.3 分区和副本管理</h3><ul><li><strong>分区Leader选举</strong>：当分区Leader副本不可用时，从ISR(In-Sync Replicas)中选举新的Leader</li><li><strong>副本状态管理</strong>：跟踪所有分区副本的同步状态</li><li><strong>重新分配分区</strong>：处理分区重分配请求，实现负载均衡</li><li><strong>管理ISR列表</strong>：维护每个分区的ISR列表</li><li><strong>管理ISR列表</strong>：Preferred leader选举</li></ul><h3 id="1-4-集群元数据管理"><a href="#1-4-集群元数据管理" class="headerlink" title="1.4 集群元数据管理"></a>1.4 集群元数据管理</h3><ul><li><strong>管理集群元数据</strong>：在ZooKeeper中存储和更新集群元数据</li><li><strong>处理元数据变更</strong>：监听ZooKeeper中的元数据变更，并通知相关Broker</li></ul><h2 id="2-Controller的工作流程"><a href="#2-Controller的工作流程" class="headerlink" title="2.Controller的工作流程"></a>2.Controller的工作流程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161824.png" alt="Controller的工作流程"></p><h2 id="3-Controller选举过程"><a href="#3-Controller选举过程" class="headerlink" title="3.Controller选举过程"></a>3.Controller选举过程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161853.png" alt="Controller选举过程"></p><h2 id="4-分区Leader选举过程"><a href="#4-分区Leader选举过程" class="headerlink" title="4.分区Leader选举过程"></a>4.分区Leader选举过程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161919.png" alt="分区Leader选举过程"></p><h2 id="5-Topic创建流程"><a href="#5-Topic创建流程" class="headerlink" title="5.Topic创建流程"></a>5.Topic创建流程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161941.png" alt="Topic创建流程"></p><p>通过以上分析，我们可以看到Kafka Controller在整个集群中扮演着”大脑”的角色，负责协调和管理集群的各个方面，确保集群的稳定运行和高可用性。Controller的设计体现了Kafka在分布式系统设计上的精妙之处，通过单一控制点简化了复杂的分布式协调问题。</p><h2 id="6-Kafka的Prefer-Leader机制详解"><a href="#6-Kafka的Prefer-Leader机制详解" class="headerlink" title="6.Kafka的Prefer Leader机制详解"></a>6.Kafka的Prefer Leader机制详解</h2><p>Kafka 的 Prefer Leader 机制（优先副本选举机制）是 Kafka 用于维持分区 Leader 分布均衡的核心策略，其核心思想是优先将分区的第一个副本（即AR列表中的第一个副本）选举为 Leader，从而避免集群负载倾斜。</p><h3 id="6-1-Prefer-Leader的意义"><a href="#6-1-Prefer-Leader的意义" class="headerlink" title="6.1 Prefer Leader的意义"></a>6.1 Prefer Leader的意义</h3><ol><li>负载均衡：Kafka希望集群中的各个Broker能够均衡地承担Leader角色，以分散负载</li><li>数据本地性：通过合理设置Prefer Leader，可以使得读写操作尽可能在本地完成，减少网络传输</li><li>故障恢复：当原Leader故障恢复后，Prefer Leader机制可以帮助将Leader角色重新分配回原来的首选节点</li></ol><h3 id="6-2-Leader-Election（Leader选举）过程"><a href="#6-2-Leader-Election（Leader选举）过程" class="headerlink" title="6.2 Leader Election（Leader选举）过程"></a>6.2 Leader Election（Leader选举）过程</h3><p>Kafka的Leader选举主要发生在以下几种情况：</p><ol><li>Topic创建时 ：初始分配Leader</li><li>Broker故障时 ：需要为受影响的分区选举新Leader</li><li>Preferred Leader选举 ：定期或手动触发的Leader重平衡</li></ol><h3 id="6-3-Leader选举流程"><a href="#6-3-Leader选举流程" class="headerlink" title="6.3 Leader选举流程"></a>6.3 Leader选举流程</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162007.png" alt="Leader选举流程"></p><h3 id="6-4-Preferred-Leader-Election（首选Leader选举）"><a href="#6-4-Preferred-Leader-Election（首选Leader选举）" class="headerlink" title="6.4 Preferred Leader Election（首选Leader选举）"></a>6.4 Preferred Leader Election（首选Leader选举）</h3><p>Kafka提供了一个名为 auto.leader.rebalance.enable 的配置项，当设置为true时，Kafka会定期检查并尝试将Leader角色重新分配给Prefer Leader。这个过程称为Preferred Leader Election。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-162028.png" alt="Preferred Leader Election（首选Leader选举）"></p><h3 id="6-5-Preferred-Leader-Election的触发方式"><a href="#6-5-Preferred-Leader-Election的触发方式" class="headerlink" title="6.5 Preferred Leader Election的触发方式"></a>6.5 Preferred Leader Election的触发方式</h3><ol><li>自动触发 ：通过 auto.leader.rebalance.enable&#x3D;true 配置启用自动Leader重平衡</li><li>手动触发 ：通过Kafka管理工具手动执行Preferred Leader Election</li></ol><h3 id="6-6-Preferred-Leader-Election的优势"><a href="#6-6-Preferred-Leader-Election的优势" class="headerlink" title="6.6 Preferred Leader Election的优势"></a>6.6 Preferred Leader Election的优势</h3><ol><li>恢复原有负载分布 ：当Broker故障恢复后，可以将Leader角色重新分配回原来的首选节点</li><li>优化数据本地性 ：通过将Leader分配给首选副本，可以优化读写性能</li><li>避免Leader倾斜 ：防止某些Broker承担过多的Leader角色，导致负载不均衡</li></ol><h3 id="6-7-注意事项"><a href="#6-7-注意事项" class="headerlink" title="6.7 注意事项"></a>6.7 注意事项</h3><ol><li>性能影响 ：Leader切换过程会短暂影响分区的可用性</li><li>ISR要求 ：只有当Preferred Leader在ISR中时，才会进行Leader切换</li><li>频率控制 ：过于频繁的Leader切换会影响集群稳定性，应合理设置 leader.imbalance.check.interval.seconds 参数<br>通过Prefer Leader机制，Kafka能够在保证高可用性的同时，实现集群负载的均衡分布，提高整体性能和稳定性。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc-go底层实现三：grpc客户端头帧发送过程</title>
    <link href="/2025/05/31/grpc-go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%89%EF%BC%9Agrpc%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%B4%E5%B8%A7%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/05/31/grpc-go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%89%EF%BC%9Agrpc%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%B4%E5%B8%A7%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="newClientStreamWithParams-方法详细分析"><a href="#newClientStreamWithParams-方法详细分析" class="headerlink" title="newClientStreamWithParams 方法详细分析"></a><code>newClientStreamWithParams</code> 方法详细分析</h1><p><code>newClientStreamWithParams</code> 方法位于 <code>stream.go</code> 文件的第260-404行，是 gRPC 客户端创建流式连接的核心方法。这个方法负责初始化客户端流，设置上下文、超时、压缩选项，并创建与服务器的连接。下面我将详细分析这个方法的功能及其调用关系。</p><h2 id="方法功能分析"><a href="#方法功能分析" class="headerlink" title="方法功能分析"></a>方法功能分析</h2><h3 id="1-上下文和超时处理"><a href="#1-上下文和超时处理" class="headerlink" title="1. 上下文和超时处理"></a>1. 上下文和超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> cancel context.CancelFunc<br><span class="hljs-keyword">if</span> mc.Timeout != <span class="hljs-literal">nil</span> &amp;&amp; *mc.Timeout &gt;= <span class="hljs-number">0</span> &#123;<br>    ctx, cancel = context.WithTimeout(ctx, *mc.Timeout)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    ctx, cancel = context.WithCancel(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码创建了一个子上下文，如果配置了超时，则设置超时时间；否则创建一个可取消的上下文。这确保了 RPC 调用可以被超时或手动取消。</p><h3 id="2-执行用户自定义的前置方法"><a href="#2-执行用户自定义的前置方法" class="headerlink" title="2. 执行用户自定义的前置方法"></a>2. 执行用户自定义的前置方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts &#123;<br>    <span class="hljs-keyword">if</span> err := o.before(callInfo); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, toRPCErr(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码执行用户通过 <code>CallOption</code> 提供的前置方法，允许用户在 RPC 调用前进行自定义操作。</p><h3 id="3-设置消息大小限制"><a href="#3-设置消息大小限制" class="headerlink" title="3. 设置消息大小限制"></a>3. 设置消息大小限制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">callInfo.maxSendMessageSize = getMaxSize(mc.MaxReqSize, callInfo.maxSendMessageSize, defaultClientMaxSendMessageSize)<br>callInfo.maxReceiveMessageSize = getMaxSize(mc.MaxRespSize, callInfo.maxReceiveMessageSize, defaultClientMaxReceiveMessageSize)<br></code></pre></td></tr></table></figure><p>这段代码设置了发送和接收消息的最大大小，确保消息不会超过限制。</p><h3 id="4-设置编解码器"><a href="#4-设置编解码器" class="headerlink" title="4. 设置编解码器"></a>4. 设置编解码器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := setCallInfoCodec(callInfo); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码设置了用于序列化和反序列化消息的编解码器。</p><h3 id="5-创建调用头部"><a href="#5-创建调用头部" class="headerlink" title="5. 创建调用头部"></a>5. 创建调用头部</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">callHdr := &amp;transport.CallHdr&#123;<br>    Host:           cc.authority,<br>    Method:         method,<br>    ContentSubtype: callInfo.contentSubtype,<br>    DoneFunc:       doneFunc,<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码创建了一个调用头部，包含主机、方法、内容子类型和完成回调函数。</p><h3 id="6-设置压缩选项"><a href="#6-设置压缩选项" class="headerlink" title="6. 设置压缩选项"></a>6. 设置压缩选项</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> compressorV0 Compressor<br><span class="hljs-keyword">var</span> compressorV1 encoding.Compressor<br><span class="hljs-keyword">if</span> ct := callInfo.compressorName; ct != <span class="hljs-string">&quot;&quot;</span> &#123;<br>    callHdr.SendCompress = ct<br>    <span class="hljs-keyword">if</span> ct != encoding.Identity &#123;<br>        compressorV1 = encoding.GetCompressor(ct)<br>        <span class="hljs-keyword">if</span> compressorV1 == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Errorf(codes.Internal, <span class="hljs-string">&quot;grpc: Compressor is not installed for requested grpc-encoding %q&quot;</span>, ct)<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cc.dopts.compressorV0 != <span class="hljs-literal">nil</span> &#123;<br>    callHdr.SendCompress = cc.dopts.compressorV0.Type()<br>    compressorV0 = cc.dopts.compressorV0<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码设置了发送压缩选项，如果用户指定了压缩器，则使用用户指定的；否则使用连接默认的压缩器。</p><h3 id="7-设置凭证"><a href="#7-设置凭证" class="headerlink" title="7. 设置凭证"></a>7. 设置凭证</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> callInfo.creds != <span class="hljs-literal">nil</span> &#123;<br>    callHdr.Creds = callInfo.creds<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码设置了调用凭证，用于认证。</p><h3 id="8-创建客户端流"><a href="#8-创建客户端流" class="headerlink" title="8. 创建客户端流"></a>8. 创建客户端流</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">cs := &amp;clientStream&#123;<br>    callHdr:      callHdr,<br>    ctx:          ctx,<br>    methodConfig: &amp;mc,<br>    opts:         opts,<br>    callInfo:     callInfo,<br>    cc:           cc,<br>    desc:         desc,<br>    codec:        callInfo.codec,<br>    compressorV0: compressorV0,<br>    compressorV1: compressorV1,<br>    cancel:       cancel,<br>    firstAttempt: <span class="hljs-literal">true</span>,<br>    onCommit:     onCommit,<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码创建了一个客户端流对象，包含了所有必要的信息。</p><h3 id="9-设置重试节流器"><a href="#9-设置重试节流器" class="headerlink" title="9. 设置重试节流器"></a>9. 设置重试节流器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> !cc.dopts.disableRetry &#123;<br>    cs.retryThrottler = cc.retryThrottler.Load().(*retryThrottler)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码设置了重试节流器，用于控制重试频率。</p><h3 id="10-设置二进制日志"><a href="#10-设置二进制日志" class="headerlink" title="10. 设置二进制日志"></a>10. 设置二进制日志</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> ml := binarylog.GetMethodLogger(method); ml != <span class="hljs-literal">nil</span> &#123;<br>    cs.binlogs = <span class="hljs-built_in">append</span>(cs.binlogs, ml)<br>&#125;<br><span class="hljs-keyword">if</span> cc.dopts.binaryLogger != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">if</span> ml := cc.dopts.binaryLogger.GetMethodLogger(method); ml != <span class="hljs-literal">nil</span> &#123;<br>        cs.binlogs = <span class="hljs-built_in">append</span>(cs.binlogs, ml)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码设置了二进制日志记录器，用于记录 RPC 调用的二进制日志。</p><h3 id="11-选择传输并创建新流"><a href="#11-选择传输并创建新流" class="headerlink" title="11. 选择传输并创建新流"></a>11. 选择传输并创建新流</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">op := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a *csAttempt)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> err := a.getTransport(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> err := a.newStream(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    cs.attempt = a<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> err := cs.withRetry(op, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; cs.bufferForRetryLocked(<span class="hljs-number">0</span>, op, <span class="hljs-literal">nil</span>) &#125;); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码定义了一个操作函数，该函数获取传输、创建新流，并将尝试对象赋值给客户端流。然后使用 <code>withRetry</code> 方法执行这个操作，如果失败则重试。</p><h3 id="12-记录二进制日志"><a href="#12-记录二进制日志" class="headerlink" title="12. 记录二进制日志"></a>12. 记录二进制日志</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cs.binlogs) != <span class="hljs-number">0</span> &#123;<br>    md, _ := metadata.FromOutgoingContext(ctx)<br>    logEntry := &amp;binarylog.ClientHeader&#123;<br>        OnClientSide: <span class="hljs-literal">true</span>,<br>        Header:       md,<br>        MethodName:   method,<br>        Authority:    cs.cc.authority,<br>    &#125;<br>    <span class="hljs-keyword">if</span> deadline, ok := ctx.Deadline(); ok &#123;<br>        logEntry.Timeout = time.Until(deadline)<br>        <span class="hljs-keyword">if</span> logEntry.Timeout &lt; <span class="hljs-number">0</span> &#123;<br>            logEntry.Timeout = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, binlog := <span class="hljs-keyword">range</span> cs.binlogs &#123;<br>        binlog.Log(cs.ctx, logEntry)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码记录了客户端头部的二进制日志。</p><h3 id="13-设置上下文清理"><a href="#13-设置上下文清理" class="headerlink" title="13. 设置上下文清理"></a>13. 设置上下文清理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> desc != unaryStreamDesc &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-cc.ctx.Done():<br>            cs.finish(ErrClientConnClosing)<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            cs.finish(toRPCErr(ctx.Err()))<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码为非一元流设置了上下文清理，当连接关闭或上下文取消时，结束客户端流。</p><h2 id="关键调用方法分析"><a href="#关键调用方法分析" class="headerlink" title="关键调用方法分析"></a>关键调用方法分析</h2><h3 id="1-withRetry-方法"><a href="#1-withRetry-方法" class="headerlink" title="1. withRetry 方法"></a>1. <code>withRetry</code> 方法</h3><p><code>withRetry</code> 方法是客户端流重试机制的核心，它接受一个操作函数和一个成功回调函数，执行操作并在失败时重试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *clientStream)</span></span> withRetry(op <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a *csAttempt)</span></span> <span class="hljs-type">error</span>, onSuccess <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br>    cs.mu.Lock()<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> cs.committed &#123;<br>            cs.mu.Unlock()<br>            <span class="hljs-keyword">return</span> toRPCErr(op(cs.attempt))<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cs.replayBuffer) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>            <span class="hljs-keyword">if</span> cs.attempt, err = cs.newAttemptLocked(<span class="hljs-literal">false</span> <span class="hljs-comment">/* isTransparent */</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                cs.mu.Unlock()<br>                cs.finish(err)<br>                <span class="hljs-keyword">return</span> err<br>            &#125;<br>        &#125;<br>        a := cs.attempt<br>        cs.mu.Unlock()<br>        err := op(a)<br>        cs.mu.Lock()<br>        <span class="hljs-keyword">if</span> a != cs.attempt &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>            &lt;-a.transportStream.Done()<br>        &#125;<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> || (err == io.EOF &amp;&amp; a.transportStream.Status().Code() == codes.OK) &#123;<br>            onSuccess()<br>            cs.mu.Unlock()<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">if</span> err := cs.retryLocked(a, err); err != <span class="hljs-literal">nil</span> &#123;<br>            cs.mu.Unlock()<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-newAttemptLocked-方法"><a href="#2-newAttemptLocked-方法" class="headerlink" title="2. newAttemptLocked 方法"></a>2. <code>newAttemptLocked</code> 方法</h3><p><code>newAttemptLocked</code> 方法创建一个新的客户端流尝试对象，包含上下文、统计处理器和跟踪信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *clientStream)</span></span> newAttemptLocked(isTransparent <span class="hljs-type">bool</span>) (*csAttempt, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> err := cs.ctx.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, toRPCErr(err)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err := cs.cc.ctx.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrClientConnClosing<br>    &#125;<br><br>    ctx := newContextWithRPCInfo(cs.ctx, cs.callInfo.failFast, cs.callInfo.codec, cs.compressorV0, cs.compressorV1)<br>    method := cs.callHdr.Method<br>    <span class="hljs-keyword">var</span> beginTime time.Time<br>    shs := cs.cc.dopts.copts.StatsHandlers<br>    <span class="hljs-keyword">for</span> _, sh := <span class="hljs-keyword">range</span> shs &#123;<br>        ctx = sh.TagRPC(ctx, &amp;stats.RPCTagInfo&#123;FullMethodName: method, FailFast: cs.callInfo.failFast&#125;)<br>        beginTime = time.Now()<br>        begin := &amp;stats.Begin&#123;<br>            Client:                    <span class="hljs-literal">true</span>,<br>            BeginTime:                 beginTime,<br>            FailFast:                  cs.callInfo.failFast,<br>            IsClientStream:            cs.desc.ClientStreams,<br>            IsServerStream:            cs.desc.ServerStreams,<br>            IsTransparentRetryAttempt: isTransparent,<br>        &#125;<br>        sh.HandleRPC(ctx, begin)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> trInfo *traceInfo<br>    <span class="hljs-keyword">if</span> EnableTracing &#123;<br>        trInfo = &amp;traceInfo&#123;<br>            tr: newTrace(<span class="hljs-string">&quot;grpc.Sent.&quot;</span>+methodFamily(method), method),<br>            firstLine: firstLine&#123;<br>                client: <span class="hljs-literal">true</span>,<br>            &#125;,<br>        &#125;<br>        <span class="hljs-keyword">if</span> deadline, ok := ctx.Deadline(); ok &#123;<br>            trInfo.firstLine.deadline = time.Until(deadline)<br>        &#125;<br>        trInfo.tr.LazyLog(&amp;trInfo.firstLine, <span class="hljs-literal">false</span>)<br>        ctx = newTraceContext(ctx, trInfo.tr)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;csAttempt&#123;<br>        ctx:            ctx,<br>        beginTime:      beginTime,<br>        cs:             cs,<br>        decompressorV0: cs.cc.dopts.dc,<br>        statsHandlers:  shs,<br>        trInfo:         trInfo,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-getTransport-方法"><a href="#3-getTransport-方法" class="headerlink" title="3. getTransport 方法"></a>3. <code>getTransport</code> 方法</h3><p><code>getTransport</code> 方法获取用于传输的客户端传输对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *csAttempt)</span></span> getTransport() <span class="hljs-type">error</span> &#123;<br>    cs := a.cs<br><br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    a.transport, a.pickResult, err = cs.cc.getTransport(a.ctx, cs.callInfo.failFast, cs.callHdr.Method)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> de, ok := err.(dropError); ok &#123;<br>            err = de.<span class="hljs-type">error</span><br>            a.drop = <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> a.trInfo != <span class="hljs-literal">nil</span> &#123;<br>        a.trInfo.firstLine.SetRemoteAddr(a.transport.RemoteAddr())<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-newStream-方法"><a href="#4-newStream-方法" class="headerlink" title="4. newStream 方法"></a>4. <code>newStream</code> 方法</h3><p><code>newStream</code> 方法在传输上创建一个新的流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *csAttempt)</span></span> newStream() <span class="hljs-type">error</span> &#123;<br>    cs := a.cs<br>    cs.callHdr.PreviousAttempts = cs.numRetries<br><br>    <span class="hljs-comment">// 合并 PickResult 中的元数据</span><br>    <span class="hljs-keyword">if</span> a.pickResult.Metadata != <span class="hljs-literal">nil</span> &#123;<br>        md, _ := metadata.FromOutgoingContext(a.ctx)<br>        md = metadata.Join(md, a.pickResult.Metadata)<br>        a.ctx = metadata.NewOutgoingContext(a.ctx, md)<br>    &#125;<br><br>    s, err := a.transport.NewStream(a.ctx, cs.callHdr)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        nse, ok := err.(*transport.NewStreamError)<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> nse.AllowTransparentRetry &#123;<br>            a.allowTransparentRetry = <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> toRPCErr(nse.Err)<br>    &#125;<br>    a.transportStream = s<br>    a.ctx = s.Context()<br>    a.parser = &amp;parser&#123;r: s, bufferPool: a.cs.cc.dopts.copts.BufferPool&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-shouldRetry-方法"><a href="#5-shouldRetry-方法" class="headerlink" title="5. shouldRetry 方法"></a>5. <code>shouldRetry</code> 方法</h3><p><code>shouldRetry</code> 方法决定是否应该重试 RPC 调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *csAttempt)</span></span> shouldRetry(err <span class="hljs-type">error</span>) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>    cs := a.cs<br><br>    <span class="hljs-keyword">if</span> cs.finished || cs.committed || a.drop &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>    &#125;<br>    <span class="hljs-keyword">if</span> a.transportStream == <span class="hljs-literal">nil</span> &amp;&amp; a.allowTransparentRetry &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 等待尾部元数据</span><br>    unprocessed := <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> a.transportStream != <span class="hljs-literal">nil</span> &#123;<br>        &lt;-a.transportStream.Done()<br>        unprocessed = a.transportStream.Unprocessed()<br>    &#125;<br>    <span class="hljs-keyword">if</span> cs.firstAttempt &amp;&amp; unprocessed &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> cs.cc.dopts.disableRetry &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 检查服务器推回</span><br>    pushback := <span class="hljs-number">0</span><br>    hasPushback := <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> a.transportStream != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> !a.transportStream.TrailersOnly() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>        &#125;<br><br>        sps := a.transportStream.Trailer()[<span class="hljs-string">&quot;grpc-retry-pushback-ms&quot;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sps) == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">var</span> e <span class="hljs-type">error</span><br>            <span class="hljs-keyword">if</span> pushback, e = strconv.Atoi(sps[<span class="hljs-number">0</span>]); e != <span class="hljs-literal">nil</span> || pushback &lt; <span class="hljs-number">0</span> &#123;<br>                cs.retryThrottler.throttle()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>            &#125;<br>            hasPushback = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sps) &gt; <span class="hljs-number">1</span> &#123;<br>            cs.retryThrottler.throttle()<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查状态码是否可重试</span><br>    <span class="hljs-keyword">var</span> code codes.Code<br>    <span class="hljs-keyword">if</span> a.transportStream != <span class="hljs-literal">nil</span> &#123;<br>        code = a.transportStream.Status().Code()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        code = status.Code(err)<br>    &#125;<br><br>    rp := cs.methodConfig.RetryPolicy<br>    <span class="hljs-keyword">if</span> rp == <span class="hljs-literal">nil</span> || !rp.RetryableStatusCodes[code] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 检查重试节流</span><br>    <span class="hljs-keyword">if</span> cs.retryThrottler.throttle() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 检查重试次数</span><br>    <span class="hljs-keyword">if</span> cs.numRetries+<span class="hljs-number">1</span> &gt;= rp.MaxAttempts &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 计算重试延迟</span><br>    <span class="hljs-keyword">var</span> dur time.Duration<br>    <span class="hljs-keyword">if</span> hasPushback &#123;<br>        dur = time.Millisecond * time.Duration(pushback)<br>        cs.numRetriesSincePushback = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fact := math.Pow(rp.BackoffMultiplier, <span class="hljs-type">float64</span>(cs.numRetriesSincePushback))<br>        cur := min(<span class="hljs-type">float64</span>(rp.InitialBackoff)*fact, <span class="hljs-type">float64</span>(rp.MaxBackoff))<br>        cur *= <span class="hljs-number">0.8</span> + <span class="hljs-number">0.4</span>*rand.Float64()<br>        dur = time.Duration(<span class="hljs-type">int64</span>(cur))<br>        cs.numRetriesSincePushback++<br>    &#125;<br><br>    <span class="hljs-comment">// 等待重试延迟</span><br>    t := time.NewTimer(dur)<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-t.C:<br>        cs.numRetries++<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> &lt;-cs.ctx.Done():<br>        t.Stop()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, status.FromContextError(cs.ctx.Err()).Err()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161501.png" alt="整体流程图"></p><h2 id="详细调用关系"><a href="#详细调用关系" class="headerlink" title="详细调用关系"></a>详细调用关系</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161554.png" alt="详细调用关系"></p><h2 id="重试机制详细流程"><a href="#重试机制详细流程" class="headerlink" title="重试机制详细流程"></a>重试机制详细流程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161626.png" alt="重试机制详细流程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>newClientStreamWithParams</code> 方法是 gRPC 客户端创建流式连接的核心方法，它负责初始化客户端流，设置各种参数，并创建与服务器的连接。该方法通过 <code>withRetry</code> 机制提供了强大的重试功能，确保在网络不稳定的情况下仍能可靠地完成 RPC 调用。</p><p>整个流程涉及多个组件的协作，包括：</p><ol><li>上下文和超时管理</li><li>用户自定义选项处理</li><li>消息大小限制设置</li><li>编解码器和压缩选项配置</li><li>传输层选择和流创建</li><li>重试机制</li><li>二进制日志记录</li><li>上下文清理</li></ol><p>这些组件共同工作，提供了一个功能完善、可靠的 gRPC 客户端流实现。        </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc-go底层实现二：客户端与服务端建立连接过程</title>
    <link href="/2025/05/26/grpc-go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BA%8C%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/05/26/grpc-go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BA%8C%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="NewHTTP2Client-方法详细分析"><a href="#NewHTTP2Client-方法详细分析" class="headerlink" title="NewHTTP2Client 方法详细分析"></a><code>NewHTTP2Client</code> 方法详细分析</h1><p><code>NewHTTP2Client</code> 方法是 gRPC 客户端创建 HTTP&#x2F;2 传输层连接的核心方法，负责建立与服务器的 HTTP&#x2F;2 连接，并设置相关参数。下面我将详细分析这个方法的功能、流程以及头帧发送与连接建立的过程。</p><h2 id="方法功能概述"><a href="#方法功能概述" class="headerlink" title="方法功能概述"></a>方法功能概述</h2><p><code>NewHTTP2Client</code> 方法位于 <code>internal/transport/http2_client.go</code> 文件中，其主要功能是：</p><ol><li>创建与服务器的网络连接</li><li>配置 HTTP&#x2F;2 连接参数</li><li>执行 TLS 握手（如果启用了安全连接）</li><li>发送 HTTP&#x2F;2 客户端前言和设置帧</li><li>启动读写协程处理数据交换</li><li>返回可用的 HTTP&#x2F;2 客户端传输对象</li></ol><h2 id="详细流程分析"><a href="#详细流程分析" class="headerlink" title="详细流程分析"></a>详细流程分析</h2><h3 id="1-上下文和取消处理"><a href="#1-上下文和取消处理" class="headerlink" title="1. 上下文和取消处理"></a>1. 上下文和取消处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        cancel()<br>    &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>这段代码创建了一个可取消的上下文，如果函数返回错误，则取消上下文，确保资源被正确释放。</p><h3 id="2-建立网络连接"><a href="#2-建立网络连接" class="headerlink" title="2. 建立网络连接"></a>2. 建立网络连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">connectCtx = icredentials.NewClientHandshakeInfoContext(connectCtx, credentials.ClientHandshakeInfo&#123;Attributes: addr.Attributes&#125;)<br>conn, err := dial(connectCtx, opts.Dialer, addr, opts.UserAgent)<br></code></pre></td></tr></table></figure><p>这段代码使用提供的拨号器建立与服务器的网络连接，并将地址属性添加到连接上下文中。</p><h3 id="3-上下文监控"><a href="#3-上下文监控" class="headerlink" title="3. 上下文监控"></a>3. 上下文监控</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">ctxMonitorDone := grpcsync.NewEvent()<br>newClientCtx, newClientDone := context.WithCancel(connectCtx)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    newClientDone()         <span class="hljs-comment">// 如果 connectCtx 未过期，唤醒下面的协程</span><br>    &lt;-ctxMonitorDone.Done() <span class="hljs-comment">// 等待下面的协程退出</span><br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> ctxMonitorDone.Fire() <span class="hljs-comment">// 发出信号表示协程已退出</span><br>    &lt;-newClientCtx.Done()      <span class="hljs-comment">// 阻塞直到 connectCtx 过期或上面的 defer 执行</span><br>    <span class="hljs-keyword">if</span> err := connectCtx.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// connectCtx 在函数退出前过期，强制关闭连接</span><br>        conn.Close()<br>    &#125;<br>&#125;(conn)<br></code></pre></td></tr></table></figure><p>这段代码启动一个协程监控连接上下文，如果上下文过期，则强制关闭连接。</p><h3 id="4-配置保活参数"><a href="#4-配置保活参数" class="headerlink" title="4. 配置保活参数"></a>4. 配置保活参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">kp := opts.KeepaliveParams<br><span class="hljs-keyword">if</span> kp.Time == <span class="hljs-number">0</span> &#123;<br>    kp.Time = defaultClientKeepaliveTime<br>&#125;<br><span class="hljs-keyword">if</span> kp.Timeout == <span class="hljs-number">0</span> &#123;<br>    kp.Timeout = defaultClientKeepaliveTimeout<br>&#125;<br>keepaliveEnabled := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> kp.Time != infinity &#123;<br>    <span class="hljs-keyword">if</span> err = isyscall.SetTCPUserTimeout(conn, kp.Timeout); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, connectionErrorf(<span class="hljs-literal">false</span>, err, <span class="hljs-string">&quot;transport: failed to set TCP_USER_TIMEOUT: %v&quot;</span>, err)<br>    &#125;<br>    keepaliveEnabled = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码配置了 TCP 保活参数，确保长连接的稳定性。</p><h3 id="5-安全连接处理"><a href="#5-安全连接处理" class="headerlink" title="5. 安全连接处理"></a>5. 安全连接处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> transportCreds != <span class="hljs-literal">nil</span> &#123;<br>    conn, authInfo, err = transportCreds.ClientHandshake(connectCtx, addr.ServerName, conn)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, connectionErrorf(isTemporary(err), err, <span class="hljs-string">&quot;transport: authentication handshake failed: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">// 检查凭证安全级别</span><br>    isSecure = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">if</span> transportCreds.Info().SecurityProtocol == <span class="hljs-string">&quot;tls&quot;</span> &#123;<br>        scheme = <span class="hljs-string">&quot;https&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码执行 TLS 握手（如果启用了安全连接），并验证安全级别是否满足要求。</p><h3 id="6-创建-HTTP-2-客户端对象"><a href="#6-创建-HTTP-2-客户端对象" class="headerlink" title="6. 创建 HTTP&#x2F;2 客户端对象"></a>6. 创建 HTTP&#x2F;2 客户端对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">t := &amp;http2Client&#123;<br>    ctx:                   ctx,<br>    ctxDone:               ctx.Done(), <span class="hljs-comment">// 缓存 Done 通道</span><br>    cancel:                cancel,<br>    userAgent:             opts.UserAgent,<br>    registeredCompressors: grpcutil.RegisteredCompressors(),<br>    address:               addr,<br>    conn:                  conn,<br>    <span class="hljs-comment">// ... 其他字段初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码创建了 HTTP&#x2F;2 客户端对象，并初始化各种字段。</p><h3 id="7-启动读取协程"><a href="#7-启动读取协程" class="headerlink" title="7. 启动读取协程"></a>7. 启动读取协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">readerErrCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> t.reader(readerErrCh)<br></code></pre></td></tr></table></figure><p>这段代码启动了一个协程读取来自服务器的 HTTP&#x2F;2 帧，并将错误发送到 <code>readerErrCh</code> 通道。</p><h3 id="8-发送客户端前言和设置帧（关键部分）"><a href="#8-发送客户端前言和设置帧（关键部分）" class="headerlink" title="8. 发送客户端前言和设置帧（关键部分）"></a>8. 发送客户端前言和设置帧（关键部分）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送客户端前言到服务器</span><br>n, err := t.conn.Write(clientPreface)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    err = connectionErrorf(<span class="hljs-literal">true</span>, err, <span class="hljs-string">&quot;transport: failed to write client preface: %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> n != <span class="hljs-built_in">len</span>(clientPreface) &#123;<br>    err = connectionErrorf(<span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;transport: preface mismatch, wrote %d bytes; want %d&quot;</span>, n, <span class="hljs-built_in">len</span>(clientPreface))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">var</span> ss []http2.Setting<br><br><span class="hljs-keyword">if</span> t.initialWindowSize != defaultWindowSize &#123;<br>    ss = <span class="hljs-built_in">append</span>(ss, http2.Setting&#123;<br>        ID:  http2.SettingInitialWindowSize,<br>        Val: <span class="hljs-type">uint32</span>(t.initialWindowSize),<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">if</span> opts.MaxHeaderListSize != <span class="hljs-literal">nil</span> &#123;<br>    ss = <span class="hljs-built_in">append</span>(ss, http2.Setting&#123;<br>        ID:  http2.SettingMaxHeaderListSize,<br>        Val: *opts.MaxHeaderListSize,<br>    &#125;)<br>&#125;<br>err = t.framer.fr.WriteSettings(ss...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    err = connectionErrorf(<span class="hljs-literal">true</span>, err, <span class="hljs-string">&quot;transport: failed to write initial settings frame: %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 如果需要，调整连接流控窗口</span><br><span class="hljs-keyword">if</span> delta := <span class="hljs-type">uint32</span>(icwz - defaultWindowSize); delta &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">if</span> err := t.framer.fr.WriteWindowUpdate(<span class="hljs-number">0</span>, delta); err != <span class="hljs-literal">nil</span> &#123;<br>        err = connectionErrorf(<span class="hljs-literal">true</span>, err, <span class="hljs-string">&quot;transport: failed to write window update: %v&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是建立 HTTP&#x2F;2 连接的核心部分，包括：</p><ol><li><p>发送客户端前言（<code>clientPreface</code>）：这是 HTTP&#x2F;2 连接的起始标记，固定为 “PRI * HTTP&#x2F;2.0\r\n\r\nSM\r\n\r\n”，表示这是一个 HTTP&#x2F;2 连接。</p></li><li><p>发送 SETTINGS 帧：配置连接参数，包括：</p><ul><li>初始窗口大小（如果与默认值不同）</li><li>最大头部列表大小（如果指定了）</li></ul></li><li><p>发送 WINDOW_UPDATE 帧：如果需要，调整连接流控窗口大小。</p></li></ol><h3 id="9-等待服务器前言"><a href="#9-等待服务器前言" class="headerlink" title="9. 等待服务器前言"></a>9. 等待服务器前言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := t.framer.writer.Flush(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 阻塞直到成功接收到服务器前言或发生错误</span><br><span class="hljs-keyword">if</span> err = &lt;-readerErrCh; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码刷新写入缓冲区，并等待服务器前言的接收。服务器前言包括 SETTINGS 帧，表示服务器接受了连接。</p><h3 id="10-启动写入协程"><a href="#10-启动写入协程" class="headerlink" title="10. 启动写入协程"></a>10. 启动写入协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    t.loopy = newLoopyWriter(clientSide, t.framer, t.controlBuf, t.bdpEst, t.conn, t.logger, t.outgoingGoAwayHandler, t.bufferPool)<br>    <span class="hljs-keyword">if</span> err := t.loopy.run(); !isIOError(err) &#123;<br>        t.conn.Close()<br>    &#125;<br>    <span class="hljs-built_in">close</span>(t.writerDone)<br>&#125;()<br></code></pre></td></tr></table></figure><p>这段代码启动了一个协程处理数据写入，使用 <code>loopyWriter</code> 管理帧的发送。</p><h2 id="HTTP-2-头帧发送与连接建立详解"><a href="#HTTP-2-头帧发送与连接建立详解" class="headerlink" title="HTTP&#x2F;2 头帧发送与连接建立详解"></a>HTTP&#x2F;2 头帧发送与连接建立详解</h2><p>HTTP&#x2F;2 连接建立过程包括以下几个关键步骤：</p><h3 id="1-客户端前言"><a href="#1-客户端前言" class="headerlink" title="1. 客户端前言"></a>1. 客户端前言</h3><p>客户端首先发送一个固定的字节序列（客户端前言），表明这是一个 HTTP&#x2F;2 连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">PRI * HTTP/<span class="hljs-number">2.0</span>\r\n\r\nSM\r\n\r\n<br></code></pre></td></tr></table></figure><p>这个前言不是一个 HTTP&#x2F;2 帧，而是一个特殊的字节序列，用于区分 HTTP&#x2F;2 和 HTTP&#x2F;1.x 连接。</p><h3 id="2-SETTINGS-帧"><a href="#2-SETTINGS-帧" class="headerlink" title="2. SETTINGS 帧"></a>2. SETTINGS 帧</h3><p>紧接着客户端前言，客户端发送一个 SETTINGS 帧，包含客户端的连接参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ss []http2.Setting<br><br><span class="hljs-keyword">if</span> t.initialWindowSize != defaultWindowSize &#123;<br>    ss = <span class="hljs-built_in">append</span>(ss, http2.Setting&#123;<br>        ID:  http2.SettingInitialWindowSize,<br>        Val: <span class="hljs-type">uint32</span>(t.initialWindowSize),<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">if</span> opts.MaxHeaderListSize != <span class="hljs-literal">nil</span> &#123;<br>    ss = <span class="hljs-built_in">append</span>(ss, http2.Setting&#123;<br>        ID:  http2.SettingMaxHeaderListSize,<br>        Val: *opts.MaxHeaderListSize,<br>    &#125;)<br>&#125;<br>err = t.framer.fr.WriteSettings(ss...)<br></code></pre></td></tr></table></figure><p>这个 SETTINGS 帧可能包含以下参数：</p><ul><li><code>SETTINGS_INITIAL_WINDOW_SIZE</code>：流控窗口的初始大小</li><li><code>SETTINGS_MAX_HEADER_LIST_SIZE</code>：头部列表的最大大小</li></ul><h3 id="3-WINDOW-UPDATE-帧"><a href="#3-WINDOW-UPDATE-帧" class="headerlink" title="3. WINDOW_UPDATE 帧"></a>3. WINDOW_UPDATE 帧</h3><p>如果需要调整连接级别的流控窗口，客户端会发送一个 WINDOW_UPDATE 帧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> delta := <span class="hljs-type">uint32</span>(icwz - defaultWindowSize); delta &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">if</span> err := t.framer.fr.WriteWindowUpdate(<span class="hljs-number">0</span>, delta); err != <span class="hljs-literal">nil</span> &#123;<br>        err = connectionErrorf(<span class="hljs-literal">true</span>, err, <span class="hljs-string">&quot;transport: failed to write window update: %v&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个帧用于增加连接级别（流 ID 为 0）的流控窗口大小。</p><h3 id="4-等待服务器响应"><a href="#4-等待服务器响应" class="headerlink" title="4. 等待服务器响应"></a>4. 等待服务器响应</h3><p>客户端发送完前言和设置帧后，会等待服务器的响应：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err = &lt;-readerErrCh; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器应该响应一个 SETTINGS 帧，表示接受了连接。这个响应由 <code>reader</code> 协程处理，如果成功接收到服务器前言，<code>readerErrCh</code> 通道会被关闭；如果发生错误，错误会被发送到通道。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161108.png" alt="整体流程"></p><h3 id="HTTP-2-连接建立详细流程"><a href="#HTTP-2-连接建立详细流程" class="headerlink" title="HTTP&#x2F;2 连接建立详细流程"></a>HTTP&#x2F;2 连接建立详细流程</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161158.png" alt="HTTP/2 连接建立详细流程"></p><h3 id="头帧发送流程"><a href="#头帧发送流程" class="headerlink" title="头帧发送流程"></a>头帧发送流程</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-161238.png" alt="头帧发送流程"></p><h2 id="关键代码解释"><a href="#关键代码解释" class="headerlink" title="关键代码解释"></a>关键代码解释</h2><h3 id="1-客户端前言-1"><a href="#1-客户端前言-1" class="headerlink" title="1. 客户端前言"></a>1. 客户端前言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 客户端前言是一个固定的字节序列</span><br><span class="hljs-keyword">const</span> clientPreface = <span class="hljs-string">&quot;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;</span><br><br><span class="hljs-comment">// 发送客户端前言到服务器</span><br>n, err := t.conn.Write(clientPreface)<br></code></pre></td></tr></table></figure><p>这段代码发送 HTTP&#x2F;2 客户端前言，这是 HTTP&#x2F;2 连接的起始标记。</p><h3 id="2-SETTINGS-帧-1"><a href="#2-SETTINGS-帧-1" class="headerlink" title="2. SETTINGS 帧"></a>2. SETTINGS 帧</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ss []http2.Setting<br><br><span class="hljs-keyword">if</span> t.initialWindowSize != defaultWindowSize &#123;<br>    ss = <span class="hljs-built_in">append</span>(ss, http2.Setting&#123;<br>        ID:  http2.SettingInitialWindowSize,<br>        Val: <span class="hljs-type">uint32</span>(t.initialWindowSize),<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">if</span> opts.MaxHeaderListSize != <span class="hljs-literal">nil</span> &#123;<br>    ss = <span class="hljs-built_in">append</span>(ss, http2.Setting&#123;<br>        ID:  http2.SettingMaxHeaderListSize,<br>        Val: *opts.MaxHeaderListSize,<br>    &#125;)<br>&#125;<br>err = t.framer.fr.WriteSettings(ss...)<br></code></pre></td></tr></table></figure><p>这段代码创建并发送 SETTINGS 帧，配置 HTTP&#x2F;2 连接参数。</p><h3 id="3-WINDOW-UPDATE-帧-1"><a href="#3-WINDOW-UPDATE-帧-1" class="headerlink" title="3. WINDOW_UPDATE 帧"></a>3. WINDOW_UPDATE 帧</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> delta := <span class="hljs-type">uint32</span>(icwz - defaultWindowSize); delta &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">if</span> err := t.framer.fr.WriteWindowUpdate(<span class="hljs-number">0</span>, delta); err != <span class="hljs-literal">nil</span> &#123;<br>        err = connectionErrorf(<span class="hljs-literal">true</span>, err, <span class="hljs-string">&quot;transport: failed to write window update: %v&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码发送 WINDOW_UPDATE 帧，调整连接级别的流控窗口大小。</p><h3 id="4-读取协程"><a href="#4-读取协程" class="headerlink" title="4. 读取协程"></a>4. 读取协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> t.reader(readerErrCh)<br></code></pre></td></tr></table></figure><p>这段代码启动一个协程读取来自服务器的 HTTP&#x2F;2 帧，包括服务器的 SETTINGS 帧。</p><h3 id="5-写入协程"><a href="#5-写入协程" class="headerlink" title="5. 写入协程"></a>5. 写入协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    t.loopy = newLoopyWriter(clientSide, t.framer, t.controlBuf, t.bdpEst, t.conn, t.logger, t.outgoingGoAwayHandler, t.bufferPool)<br>    <span class="hljs-keyword">if</span> err := t.loopy.run(); !isIOError(err) &#123;<br>        t.conn.Close()<br>    &#125;<br>    <span class="hljs-built_in">close</span>(t.writerDone)<br>&#125;()<br></code></pre></td></tr></table></figure><p>这段代码启动一个协程处理数据写入，使用 <code>loopyWriter</code> 管理帧的发送。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>NewHTTP2Client</code> 方法是 gRPC 客户端创建 HTTP&#x2F;2 传输层连接的核心方法，它通过以下步骤建立与服务器的连接：</p><ol><li>建立网络连接（TCP 或 TLS）</li><li>发送 HTTP&#x2F;2 客户端前言</li><li>发送 SETTINGS 帧配置连接参数</li><li>发送 WINDOW_UPDATE 帧调整流控窗口（如果需要）</li><li>等待服务器响应前言</li><li>启动读写协程处理数据交换</li></ol><p>这个过程遵循 HTTP&#x2F;2 协议规范，确保客户端和服务器之间建立了正确的 HTTP&#x2F;2 连接，为后续的 gRPC 调用提供基础。        </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc-go底层实现一：gRPC Client初始化与连接建立准备工作</title>
    <link href="/2025/05/26/grpc-go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%EF%BC%9AgRPC%20Client%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <url>/2025/05/26/grpc-go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%EF%BC%9AgRPC%20Client%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于grpc-go 的v1.72.0</p></blockquote><h1 id="gRPC-客户端创建过程分析"><a href="#gRPC-客户端创建过程分析" class="headerlink" title="gRPC 客户端创建过程分析"></a>gRPC 客户端创建过程分析</h1><p>分析 <code>clientconn.go</code> 中的 <code>NewClient</code> 方法及其调用的方法，详细阐述 gRPC 在创建客户端时的工作流程。</p><h2 id="1-客户端创建流程概述"><a href="#1-客户端创建流程概述" class="headerlink" title="1. 客户端创建流程概述"></a>1. 客户端创建流程概述</h2><p>gRPC 客户端创建主要通过 <code>NewClient</code> 方法完成，该方法创建一个 <code>ClientConn</code> 对象，这是 gRPC 客户端的核心组件。整个创建过程可以分为以下几个主要阶段：</p><ol><li>初始化 <code>ClientConn</code> 结构体</li><li>应用拨号选项（Dial Options）</li><li>解析目标地址并获取解析器构建器</li><li>设置拦截器链</li><li>验证传输凭证</li><li>解析服务配置</li><li>初始化权限信息</li><li>注册 Channelz</li><li>初始化连接状态管理器和选择器</li></ol><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-160813.png" alt="客户端创建流程概述"></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs roboconf"><br><span class="hljs-comment">## 2. `NewClient` 方法详细分析</span><br><br><span class="hljs-comment">### 2.1 初始化 ClientConn 结构体</span><br><br>```go<br>cc := &amp;ClientConn&#123;<br>    <span class="hljs-attribute">target</span>: target,<br>    conns:  make(map[*addrConn]struct&#123;&#125;),<br>    dopts:  defaultDialOptions(), // 默认使用dns解析器<br>&#125;<br><br>cc<span class="hljs-variable">.retryThrottler</span><span class="hljs-variable">.Store</span>((*retryThrottler)(nil))<br>cc<span class="hljs-variable">.safeConfigSelector</span><span class="hljs-variable">.UpdateConfigSelector</span>(&amp;defaultConfigSelector&#123;nil&#125;)<br>cc<span class="hljs-variable">.ctx</span>, cc<span class="hljs-variable">.cancel</span> = context<span class="hljs-variable">.WithCancel</span>(context<span class="hljs-variable">.Background</span>())<br></code></pre></td></tr></table></figure><p>这一步创建了 <code>ClientConn</code> 结构体，并初始化了基本字段：</p><ul><li><code>target</code>: 目标服务地址</li><li><code>conns</code>: 存储所有子连接的映射</li><li><code>dopts</code>: 默认拨号选项，包括默认使用 DNS 解析器</li><li>初始化重试限流器、配置选择器和上下文</li></ul><h3 id="2-2-应用拨号选项"><a href="#2-2-应用拨号选项" class="headerlink" title="2.2 应用拨号选项"></a>2.2 应用拨号选项</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 应用全局拨号选项</span><br><span class="hljs-keyword">if</span> !disableGlobalOpts &#123;<br>    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> globalDialOptions &#123;<br>        opt.apply(&amp;cc.dopts)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 应用用户提供的拨号选项</span><br><span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts &#123;<br>    opt.apply(&amp;cc.dopts)<br>&#125;<br></code></pre></td></tr></table></figure><p>gRPC 使用选项模式来配置客户端连接。这一步应用了两类选项：</p><ul><li>全局拨号选项：适用于所有客户端连接的默认选项</li><li>用户提供的拨号选项：用户在创建连接时指定的特定选项</li></ul><h3 id="2-3-解析目标地址并获取解析器构建器"><a href="#2-3-解析目标地址并获取解析器构建器" class="headerlink" title="2.3 解析目标地址并获取解析器构建器"></a>2.3 解析目标地址并获取解析器构建器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := cc.initParsedTargetAndResolverBuilder(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p><code>initParsedTargetAndResolverBuilder</code> 方法解析目标地址并获取相应的解析器构建器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> initParsedTargetAndResolverBuilder() <span class="hljs-type">error</span> &#123;<br>    logger.Infof(<span class="hljs-string">&quot;original dial target is: %q&quot;</span>, cc.target)<br><br>    <span class="hljs-keyword">var</span> rb resolver.Builder<br>    parsedTarget, err := parseTarget(cc.target)<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        rb = cc.getResolver(parsedTarget.URL.Scheme) <span class="hljs-comment">// 获取具体resolverBuilder, 如自定义等</span><br>        <span class="hljs-keyword">if</span> rb != <span class="hljs-literal">nil</span> &#123;<br>            cc.parsedTarget = parsedTarget<br>            cc.resolverBuilder = rb<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果目标地址没有包含方案或指定了未注册的方案，则使用默认方案</span><br>    defScheme := cc.dopts.defaultScheme <span class="hljs-comment">// 默认使用dns</span><br>    <span class="hljs-keyword">if</span> internal.UserSetDefaultScheme &#123;<br>        defScheme = resolver.GetDefaultScheme()<br>    &#125;<br><br>    canonicalTarget := defScheme + <span class="hljs-string">&quot;://&quot;</span> + <span class="hljs-string">&quot;/&quot;</span> + cc.target<br><br>    parsedTarget, err = parseTarget(canonicalTarget)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    rb = cc.getResolver(parsedTarget.URL.Scheme) <span class="hljs-comment">// 获取默认的dns resolverBuilder</span><br>    <span class="hljs-keyword">if</span> rb == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;could not get resolver for default scheme: %q&quot;</span>, parsedTarget.URL.Scheme)<br>    &#125;<br>    cc.parsedTarget = parsedTarget<br>    cc.resolverBuilder = rb<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的主要功能是：</p><ol><li>尝试解析用户提供的目标地址，获取其中的方案（scheme）</li><li>如果解析成功且能找到对应的解析器构建器，则使用它</li><li>如果解析失败或找不到对应的解析器构建器，则使用默认方案（通常是 DNS）</li><li>最终将解析后的目标地址和解析器构建器存储在 <code>ClientConn</code> 中</li></ol><h3 id="2-4-设置拦截器链"><a href="#2-4-设置拦截器链" class="headerlink" title="2.4 设置拦截器链"></a>2.4 设置拦截器链</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">chainUnaryClientInterceptors(cc)  <span class="hljs-comment">// 设置一元拦截器</span><br>chainStreamClientInterceptors(cc) <span class="hljs-comment">// 设置流式拦截器</span><br></code></pre></td></tr></table></figure><p>这一步设置了两种类型的拦截器链：</p><ul><li>一元拦截器：用于拦截普通 RPC 调用</li><li>流式拦截器：用于拦截流式 RPC 调用</li></ul><p>拦截器允许在 RPC 调用前后执行自定义逻辑，如日志记录、认证、监控等。</p><h3 id="2-5-验证传输凭证"><a href="#2-5-验证传输凭证" class="headerlink" title="2.5 验证传输凭证"></a>2.5 验证传输凭证</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := cc.validateTransportCredentials(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p><code>validateTransportCredentials</code> 方法验证传输凭证的有效性，确保：</p><ol><li>至少配置了传输凭证或凭证包</li><li>不同时配置传输凭证和凭证包</li><li>如果配置了凭证包，其中包含有效的传输凭证</li><li>如果使用不安全传输，确保没有需要传输层安全的调用凭证</li></ol><h3 id="2-6-解析服务配置"><a href="#2-6-解析服务配置" class="headerlink" title="2.6 解析服务配置"></a>2.6 解析服务配置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cc.dopts.defaultServiceConfigRawJSON != <span class="hljs-literal">nil</span> &#123;<br>    scpr := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON, cc.dopts.maxCallAttempts)<br>    <span class="hljs-keyword">if</span> scpr.Err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, invalidDefaultServiceConfigErrPrefix, scpr.Err)<br>    &#125;<br>    cc.dopts.defaultServiceConfig, _ = scpr.Config.(*ServiceConfig)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户提供了默认服务配置（如超时设置、重试策略、负载均衡策略等），这一步会解析该配置并存储在 <code>ClientConn</code> 中。</p><h3 id="2-7-初始化权限信息"><a href="#2-7-初始化权限信息" class="headerlink" title="2.7 初始化权限信息"></a>2.7 初始化权限信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err = cc.initAuthority(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p><code>initAuthority</code> 方法确定通道的权限信息，按以下优先级：</p><ol><li>用户通过 <code>WithAuthority</code> 拨号选项指定的权限覆盖</li><li>凭证对认证握手的服务器名称的概念</li><li>拨号目标中的端点形式 “scheme:&#x2F;&#x2F;[authority]&#x2F;endpoint”</li></ol><h3 id="2-8-注册-Channelz-和初始化连接状态管理器"><a href="#2-8-注册-Channelz-和初始化连接状态管理器" class="headerlink" title="2.8 注册 Channelz 和初始化连接状态管理器"></a>2.8 注册 Channelz 和初始化连接状态管理器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">cc.channelzRegistration(target)<br>cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz)<br>cc.pickerWrapper = newPickerWrapper(cc.dopts.copts.StatsHandlers)<br></code></pre></td></tr></table></figure><p>这些步骤完成了：</p><ul><li>向 Channelz 注册 ClientConn，用于监控和调试</li><li>创建连接状态管理器，管理连接的状态变化</li><li>创建选择器包装器，用于选择子连接进行 RPC 调用</li></ul><h3 id="2-9-初始化空闲状态"><a href="#2-9-初始化空闲状态" class="headerlink" title="2.9 初始化空闲状态"></a>2.9 初始化空闲状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">cc.initIdleStateLocked()<br>cc.idlenessMgr = idle.NewManager((*idler)(cc), cc.dopts.idleTimeout)<br></code></pre></td></tr></table></figure><p>这一步初始化了空闲状态相关的组件，包括：</p><ul><li>初始化解析器包装器、负载均衡器包装器和首次解析事件</li><li>创建空闲管理器，管理连接的空闲状态</li></ul><h2 id="3-连接建立过程"><a href="#3-连接建立过程" class="headerlink" title="3. 连接建立过程"></a>3. 连接建立过程</h2><p><code>NewClient</code> 方法只创建了 <code>ClientConn</code> 对象，但并未实际建立连接。实际连接是在需要时（如进行 RPC 调用时，这里以<code>SayHello</code>方法为例）通过 <code>Connect</code> 方法建立的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> Connect() &#123;<br>    <span class="hljs-keyword">if</span> err := cc.idlenessMgr.ExitIdleMode(); err != <span class="hljs-literal">nil</span> &#123;<br>        cc.addTraceEvent(err.Error())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 如果 ClientConn 不处于空闲模式，需要调用负载均衡策略的 ExitIdle 方法来创建连接</span><br>    cc.mu.Lock()<br>    cc.balancerWrapper.exitIdle()<br>    cc.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Connect</code> 方法的主要功能是：</p><ol><li>退出空闲模式，这会重新创建名称解析器和负载均衡器</li><li>调用负载均衡器的 <code>exitIdle</code> 方法，触发连接创建</li></ol><h3 id="3-1-退出空闲模式"><a href="#3-1-退出空闲模式" class="headerlink" title="3.1 退出空闲模式"></a>3.1 退出空闲模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> exitIdleMode() (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> err := cc.resolverWrapper.start(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    cc.addTraceEvent(<span class="hljs-string">&quot;exiting idle mode&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>退出空闲模式的关键是启动解析器包装器，这会触发名称解析过程。</p><h3 id="3-2-解析器包装器启动"><a href="#3-2-解析器包装器启动" class="headerlink" title="3.2 解析器包装器启动"></a>3.2 解析器包装器启动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ccr *ccResolverWrapper)</span></span> start() <span class="hljs-type">error</span> &#123;<br>    errCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>)<br>    ccr.serializer.TrySchedule(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        opts := resolver.BuildOptions&#123;...&#125;<br>        <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>        <span class="hljs-keyword">if</span> ccr.cc.dopts.copts.Dialer != <span class="hljs-literal">nil</span> || !ccr.cc.dopts.useProxy &#123;<br>            ccr.resolver, err = ccr.cc.resolverBuilder.Build(ccr.cc.parsedTarget, ccr, opts)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ccr.resolver, err = delegatingresolver.New(ccr.cc.parsedTarget, ccr, opts, ccr.cc.resolverBuilder, ccr.cc.dopts.enableLocalDNSResolution)<br>        &#125;<br>        errCh &lt;- err<br>    &#125;)<br>    <span class="hljs-keyword">return</span> &lt;-errCh<br>&#125;<br></code></pre></td></tr></table></figure><p>解析器包装器启动时，会根据配置创建适当的解析器：</p><ol><li>如果配置了自定义拨号器或禁用代理，则直接使用解析器构建器创建解析器</li><li>否则，创建委托解析器，支持代理功能</li></ol><h3 id="3-3-解析器更新状态"><a href="#3-3-解析器更新状态" class="headerlink" title="3.3 解析器更新状态"></a>3.3 解析器更新状态</h3><p>解析器解析目标地址后，会通过 <code>UpdateState</code> 方法将解析结果通知给 <code>ClientConn</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ccr *ccResolverWrapper)</span></span> UpdateState(s resolver.State) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    ccr.curState = s<br>    <span class="hljs-keyword">return</span> ccr.cc.updateResolverStateAndUnlock(s, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-更新解析器状态"><a href="#3-4-更新解析器状态" class="headerlink" title="3.4 更新解析器状态"></a>3.4 更新解析器状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> updateResolverStateAndUnlock(s resolver.State, err <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">var</span> ret <span class="hljs-type">error</span><br>    <span class="hljs-keyword">var</span> balCfg serviceconfig.LoadBalancingConfig<br>    <span class="hljs-keyword">if</span> sc != <span class="hljs-literal">nil</span> &#123;<br>        balCfg, ret = cc.applyServiceConfigAndBalancer(sc, s, err)<br>    &#125;<br>    bw := cc.balancerWrapper<br>    uccsErr := bw.updateClientConnState(&amp;balancer.ClientConnState&#123;ResolverState: s, BalancerConfig: balCfg&#125;)<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的主要功能是：</p><ol><li>应用服务配置和负载均衡器</li><li>更新负载均衡器的客户端连接状态</li></ol><h3 id="3-5-负载均衡器更新状态"><a href="#3-5-负载均衡器更新状态" class="headerlink" title="3.5 负载均衡器更新状态"></a>3.5 负载均衡器更新状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ccb *ccBalancerWrapper)</span></span> updateClientConnState(ccs *balancer.ClientConnState) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    name := gracefulswitch.ChildName(ccs.BalancerConfig)<br>    <span class="hljs-keyword">if</span> ccb.curBalancerName != name &#123;<br>        ccb.curBalancerName = name<br>        channelz.Infof(logger, ccb.cc.channelz, <span class="hljs-string">&quot;Channel switches to new LB policy %q&quot;</span>, name)<br>    &#125;<br>    err := ccb.balancer.UpdateClientConnState(*ccs)<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>负载均衡器更新状态时，会：</p><ol><li>确定要使用的负载均衡策略名称</li><li>如果需要，切换到新的负载均衡策略</li><li>更新负载均衡器的客户端连接状态</li></ol><h2 id="4-负载均衡器创建子连接"><a href="#4-负载均衡器创建子连接" class="headerlink" title="4. 负载均衡器创建子连接"></a>4. 负载均衡器创建子连接</h2><p>负载均衡器根据解析器提供的地址创建子连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ccb *ccBalancerWrapper)</span></span> NewSubConn(addrs []resolver.Address, opts balancer.NewSubConnOptions) (balancer.SubConn, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ac, err := ccb.cc.newAddrConnLocked(addrs, opts)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    acbw := &amp;acBalancerWrapper&#123;...&#125;<br>    ac.acbw = acbw<br>    <span class="hljs-keyword">return</span> acbw, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-创建地址连接"><a href="#4-1-创建地址连接" class="headerlink" title="4.1 创建地址连接"></a>4.1 创建地址连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> newAddrConnLocked(addrs []resolver.Address, opts balancer.NewSubConnOptions) (*addrConn, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ac := &amp;addrConn&#123;<br>        state:        connectivity.Idle,<br>        cc:           cc,<br>        addrs:        copyAddresses(addrs),<br>        scopts:       opts,<br>        dopts:        cc.dopts,<br>        channelz:     channelz.RegisterSubChannel(cc.channelz, <span class="hljs-string">&quot;&quot;</span>),<br>        resetBackoff: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>    &#125;<br>    ac.ctx, ac.cancel = context.WithCancel(cc.ctx)<br>    <span class="hljs-comment">// ...</span><br>    cc.conns[ac] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">return</span> ac, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建地址连接时：</p><ol><li>创建 <code>addrConn</code> 对象，初始状态为 <code>Idle</code></li><li>设置地址、选项和上下文</li><li>注册子通道到 Channelz</li><li>将地址连接添加到 <code>ClientConn</code> 的连接映射中</li></ol><h3 id="4-2-连接地址"><a href="#4-2-连接地址" class="headerlink" title="4.2 连接地址"></a>4.2 连接地址</h3><p>当负载均衡器调用 <code>Connect</code> 方法时，地址连接开始实际建立连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(acbw *acBalancerWrapper)</span></span> Connect() &#123;<br>    <span class="hljs-keyword">go</span> acbw.ac.connect()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ac *addrConn)</span></span> connect() &#123;<br>    <span class="hljs-comment">// ...</span><br>    ac.mu.Lock()<br>    <span class="hljs-keyword">if</span> ac.state == connectivity.Shutdown &#123;<br>        ac.mu.Unlock()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 设置状态为 Connecting</span><br>    ac.updateConnectivityState(connectivity.Connecting, <span class="hljs-literal">nil</span>)<br>    ac.mu.Unlock()<br><br>    <span class="hljs-comment">// 尝试所有地址</span><br>    err := ac.tryAllAddrs(addrs, connectDeadline)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-尝试所有地址"><a href="#4-3-尝试所有地址" class="headerlink" title="4.3 尝试所有地址"></a>4.3 尝试所有地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ac *addrConn)</span></span> tryAllAddrs(addrs []resolver.Address, connectDeadline time.Time) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> _, addr := <span class="hljs-keyword">range</span> addrs &#123;<br>        err := ac.createTransport(addr, connectDeadline, <span class="hljs-literal">true</span>)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法尝试连接所有解析到的地址，直到成功或全部失败。</p><h3 id="4-4-创建传输"><a href="#4-4-创建传输" class="headerlink" title="4.4 创建传输"></a>4.4 创建传输</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ac *addrConn)</span></span> createTransport(addr resolver.Address, connectDeadline time.Time, skipReset <span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    newTr, err := transport.NewClientTransport(connectCtx, ac.cc.ctx, addr, ac.cc.dopts, ac)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    ac.mu.Lock()<br>    <span class="hljs-keyword">if</span> ac.state == connectivity.Shutdown &#123;<br>        ac.mu.Unlock()<br>        newTr.Close()<br>        <span class="hljs-keyword">return</span> errConnClosing<br>    &#125;<br>    ac.curAddr = addr<br>    ac.transport = newTr<br>    ac.updateConnectivityState(connectivity.Ready, <span class="hljs-literal">nil</span>)<br>    ac.mu.Unlock()<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建传输时：</p><ol><li>调用 <code>transport.NewClientTransport</code> 创建客户端传输</li><li>如果成功，更新当前地址和传输</li><li>将连接状态更新为 <code>Ready</code></li></ol><h2 id="5-pickFirst-负载均衡策略"><a href="#5-pickFirst-负载均衡策略" class="headerlink" title="5. pickFirst 负载均衡策略"></a>5. pickFirst 负载均衡策略</h2><p><code>pickFirst</code> 是 gRPC 的默认负载均衡策略，它的实现位于 <code>balancer/pickfirst/pickfirst.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pickfirstBalancer <span class="hljs-keyword">struct</span> &#123;<br>    cc      balancer.ClientConn<br>    subConn balancer.SubConn<br><br>    resolverErr <span class="hljs-type">error</span> <span class="hljs-comment">// the last error reported by the resolver; cleared on successful resolution</span><br>    connErr     <span class="hljs-type">error</span> <span class="hljs-comment">// the last connection error; cleared upon leaving TransientFailure</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-更新客户端连接状态"><a href="#5-1-更新客户端连接状态" class="headerlink" title="5.1 更新客户端连接状态"></a>5.1 更新客户端连接状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *pickfirstBalancer)</span></span> UpdateClientConnState(state balancer.ClientConnState) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(state.ResolverState.Endpoints) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> balancer.ErrBadResolverState<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> b.subConn != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 更新现有子连接的地址</span><br>        b.cc.UpdateAddresses(b.subConn, state.ResolverState.Endpoints[<span class="hljs-number">0</span>].Addresses)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 创建新的子连接</span><br>    sc, err := b.cc.NewSubConn(state.ResolverState.Endpoints[<span class="hljs-number">0</span>].Addresses, balancer.NewSubConnOptions&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    b.subConn = sc<br>    b.subConn.Connect()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>pickFirst</code> 策略的特点是：</p><ol><li>只使用解析器提供的第一个端点</li><li>只创建一个子连接</li><li>如果已有子连接，则只更新其地址</li></ol><h3 id="5-2-更新子连接状态"><a href="#5-2-更新子连接状态" class="headerlink" title="5.2 更新子连接状态"></a>5.2 更新子连接状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *pickfirstBalancer)</span></span> updateSubConnState(sc balancer.SubConn, state balancer.SubConnState) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">switch</span> state.ConnectivityState &#123;<br>    <span class="hljs-keyword">case</span> connectivity.Ready:<br>        b.resolverErr = <span class="hljs-literal">nil</span><br>        b.connErr = <span class="hljs-literal">nil</span><br>        b.cc.UpdateState(balancer.State&#123;<br>            ConnectivityState: connectivity.Ready,<br>            Picker:            &amp;picker&#123;sc: sc&#125;,<br>        &#125;)<br>    <span class="hljs-keyword">case</span> connectivity.Connecting:<br>        b.cc.UpdateState(balancer.State&#123;<br>            ConnectivityState: connectivity.Connecting,<br>            Picker:            &amp;picker&#123;err: balancer.ErrNoSubConnAvailable&#125;,<br>        &#125;)<br>    <span class="hljs-keyword">case</span> connectivity.Idle:<br>        b.cc.UpdateState(balancer.State&#123;<br>            ConnectivityState: connectivity.Idle,<br>            Picker:            &amp;idlePicker&#123;sc: sc&#125;,<br>        &#125;)<br>    <span class="hljs-keyword">case</span> connectivity.TransientFailure:<br>        b.connErr = state.ConnectionError<br>        b.cc.UpdateState(balancer.State&#123;<br>            ConnectivityState: connectivity.TransientFailure,<br>            Picker:            &amp;picker&#123;err: state.ConnectionError&#125;,<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子连接状态变化时，<code>pickFirst</code> 策略会：</p><ol><li>更新连接错误状态</li><li>根据子连接状态创建相应的选择器</li><li>更新客户端连接状态</li></ol><h3 id="5-3-选择器实现"><a href="#5-3-选择器实现" class="headerlink" title="5.3 选择器实现"></a>5.3 选择器实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> picker <span class="hljs-keyword">struct</span> &#123;<br>    sc  balancer.SubConn<br>    err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *picker)</span></span> Pick(balancer.PickInfo) (balancer.PickResult, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> balancer.PickResult&#123;&#125;, p.err<br>    &#125;<br>    <span class="hljs-keyword">return</span> balancer.PickResult&#123;SubConn: p.sc&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>pickFirst</code> 策略的选择器非常简单：</p><ol><li>如果有错误，返回错误</li><li>否则，始终返回同一个子连接</li></ol><h2 id="6-完整的客户端创建和连接流程"><a href="#6-完整的客户端创建和连接流程" class="headerlink" title="6. 完整的客户端创建和连接流程"></a>6. 完整的客户端创建和连接流程</h2><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/mermaid-diagram-2025-05-31-160928.png" alt="完整客户端创建和连接流程"></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>gRPC 客户端创建过程是一个复杂而精心设计的流程，主要包括以下几个关键部分：</p><ol><li><p><strong>ClientConn 初始化</strong>：创建并配置 ClientConn 对象，应用各种拨号选项。</p></li><li><p><strong>名称解析</strong>：通过解析器将目标地址解析为具体的网络地址。</p></li><li><p><strong>负载均衡</strong>：使用负载均衡策略（默认为 pickFirst）选择要连接的地址。</p></li><li><p><strong>连接建立</strong>：创建子连接并建立实际的网络连接。</p></li><li><p><strong>状态管理</strong>：管理连接的各种状态变化，如 Idle、Connecting、Ready、TransientFailure 等。</p></li></ol><p>这种设计使得 gRPC 能够支持各种复杂的连接场景，如名称解析、负载均衡、故障恢复等，同时保持了良好的可扩展性和可配置性。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HighWaterMark与副本同步机制</title>
    <link href="/2025/04/12/HighWaterMark%E4%B8%8E%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/12/HighWaterMark%E4%B8%8E%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>0.11版本之前依赖于HW实现副本同步备份，0.11之后通过Leader epoch实现副本同步备份。</p><p>两个概念：</p><ul><li>LEO：log end offset，日志末端位移，记录了该副本底层日志下一条消息应存放的位置。</li><li>HW，高水位值，小于等于HW的消息是被认为已经备份的。</li></ul><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222000602.png" alt="HW与LEO"><br>[0, 7]的消息是已经完全备份，[8, 15)的数据为尚未完全备份的。</p><p>kafka中所有的副本都保有自己的HW值和LEO值，但leader副本中还保存有其他副本的HW值和LEO值，如下图：<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222023299.png" alt="leader HW"><br>leader中保存的副本的HW值和LEO值得作用是用来更新leader副本的HW值。</p><h3 id="1、更新HW值的时机"><a href="#1、更新HW值的时机" class="headerlink" title="1、更新HW值的时机"></a>1、更新HW值的时机</h3><ul><li>follower副本：follower副本会在更新LEO值之后尝试更新HW值。</li><li>leader副本：<ul><li>当某个follower副本成为leader副本时；</li><li>broker崩溃导致副本被踢出ISR</li><li>producer向leader副本写消息时，由于LEO会被更改，因此会检查下HW是否需要更新；</li><li>leader处理follower的fetch请求时，首先会从log取数据，然后会尝试更新HW值</li></ul></li></ul><h4 id="1-1、leader副本更新HW"><a href="#1-1、leader副本更新HW" class="headerlink" title="1.1、leader副本更新HW"></a>1.1、leader副本更新HW</h4><p>处理生产者请求的逻辑：</p><ul><li>写入消息到本次磁盘</li><li>更新分区高水位<ul><li>获取leader副本所在broker端保存的所有远程副本LEO值(LEO-0, LEO-1,… … LEO-n)</li><li>获取leader副本高水位值，currentHW</li><li>更新currentHW&#x3D;max{currentHW，min(LEO-1,LEO-2,…..,LEO-n)}</li></ul></li></ul><p>处理follower副本拉取消息的处理逻辑：</p><ul><li>读取磁盘或页缓存中的数据</li><li>使用follower副本发送请求中位移值更新leader副本LEO值</li><li>更新分区高水位值，具体步骤与处理生产者请求的步骤相同</li></ul><h4 id="1-2、follower副本更新HW"><a href="#1-2、follower副本更新HW" class="headerlink" title="1.2、follower副本更新HW"></a>1.2、follower副本更新HW</h4><ul><li>写入消息到log文件</li><li>更新LEO值</li><li>更新高水位<ul><li>获取leader的高水位值：currentHW</li><li>获取步骤2刚才更新的LEO值，currentLEO</li><li>更新高水位值，min(currnetHW，currentLEO)</li></ul></li></ul><h3 id="2、副本同步机制"><a href="#2、副本同步机制" class="headerlink" title="2、副本同步机制"></a>2、副本同步机制</h3><p>当生产者生产一条消息，leader和follower副本高水位更新如下：<br>初始状态时，所有的值都为0<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222046779.png" alt="副本同步机制-初始"><br>生产者发送一条消息后<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222106099.png" alt="新消息到来"><br>当leader副本将消息写入磁盘后LEO值变为1<br>follower再次从leader拉取消息，有消息拉取到，则状态进一步更新<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222133099.png" alt="leader LEO更新"><br>可以看到此时的副本LEO也被更新为1，但是leader副本和follower副本的HW仍然没有更新，这会在下一次follower的fetch请求时更新。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222213179.png" alt="副本LEO"><br>在新一轮的拉取中，由于位移值时0的消息已经拉取成功，则本次拉取会拉去位移值为1的消息，leader副本接收到请求后，会将remote LEO值更新为1，然后更新HW值为1，将更新后的HW值发送到follower，follower将HW值更新为1，致辞一个完整的同步过程完成。</p><p>上述的拉取流程可以看到kafka使用HW来决定副本备份的进度，而HW值的更新需要新一轮的Fetch请求才能实现，这种设计是有问题的，可能会引起备份数据丢失和备份数据不一致的问题。</p><h3 id="3、Leader-epoch"><a href="#3、Leader-epoch" class="headerlink" title="3、Leader epoch"></a>3、Leader epoch</h3><p><strong>备份数据丢失的问题</strong><br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222234243.png" alt="备份数据丢失"><br>当生产者发送两条消息leader副本都完成落盘，而且follower副本B的HW已经更新为1，在第二条消息的同步时，fetch请求的响应失败，则B的HW就不会被更新到2，如果此时B重启，则B在重启后会重新加载之前的HW值，也就是1，此时副本B会做日志截断把2的消息删除，并调整LEO为1。<br>B会向A的leader副本发出同步消息的fetch请求，如果此时A恰好宕机，则B升级为leader，而当A重启回来后也会执行日志截断，将HW调整回1与B相同。这样，位移&#x3D;1的消息就从两个副本的log中被删除，即永远地丢失了。</p><p> <strong>备份数据不一致问题</strong></p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222300602.png" alt="备份数据不一致"><br>A为leader，B为follower，B的HW只更新到1，此时A、B同事宕机，但是B先恢复，此时B为leader，在A恢复之前又向B写入了新的消息2，此时B的HW为2，此时A恢复，A的HW与B的HW相等，不会出现日志截断，之后会正常的执行下去，但是副本A与leader副本B数据存在不一致的地方。</p><p>针对上述的两个问题，kafka 0.11版本对此进行了优化，采用leader epoch技术来解决上述问题。</p><p>epoch，单调递增的版本号，每当副本领导权发生改变时都会增加该版本号，小版本号的leader被认为是过期的leader，不能再行使leader的权力。它其实是一对值，即(epoch, offset)，offset为该epoch版本对应的leader写入的第一条消息的位移。<br>(0, 0)<br>(1, 120)<br>则表示第一个leader从位移0开始写入消息；共写了120条[0, 119]；而第二个leader版本号是1，从位移120处开始写入消息.</p><p>​​leader broker中会保存这样的一个缓存，并定期地写入到一个checkpoint文件中。</p><p>当leader写底层log时它会尝试更新整个缓存——如果这个leader首次写消息，则会在缓存中增加一个条目；否则就不做更新。而每次副本重新成为leader时会查询这部分缓存，获取出对应leader版本的位移，这就不会发生数据不一致和丢失的情况。<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222318395.png" alt="leader epoch1"><br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526222334411.png" alt="leader epoch2"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka日志存储</title>
    <link href="/2025/04/12/kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/"/>
    <url>/2025/04/12/kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>kafka中的topic是逻辑上的概念，而真正存储消息的是分区，更具体点来说是分区中的segment，每个分区可分为多个segment，存储的消息称为日志。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221250788.png" alt="索引文件"></p><h3 id="1、LogSegment"><a href="#1、LogSegment" class="headerlink" title="1、LogSegment"></a>1、LogSegment</h3><p>一个partition分区拥有多个logsegment，kafka日志追加是顺序写入的，把分区分为多个日志段可减小日志文件的大小，在进行日志删除和数据读取的时候也可以快速定位。需要注意的是只有活跃的日志段拥有文件的写入权限，其余的都只有读取权限。</p><p>日志文件存在多个后缀的文件，重点需要关注的有.index，.timeindex，.log三个。每个LogSegment都有一个基准偏移量，用于表示当前LogSegment文件的第一条消息的offset，固定长度是20位数字，长度未达到用0填充，索引文件和日志文件都由此命名规则命名如000000000000000000100.index、00000000000000000100.timeindex、00000000000000000100.log。</p><h3 id="2、日志格式演变"><a href="#2、日志格式演变" class="headerlink" title="2、日志格式演变"></a>2、日志格式演变</h3><h4 id="2-1、v0版本"><a href="#2-1、v0版本" class="headerlink" title="2.1、v0版本"></a>2.1、v0版本</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221319410.png" alt="v0版本"></p><p>上图RECORD部分即为v0版本的消息格式，在0.10.0版本之前都是采用的此种消息格式。LOG_OVERHEAD和RECORD一期来描述一条消息，与消息对应的是消息集的概念，消息集中包含多条消息，消息集不仅是存储于磁盘以及在网络上传输(Produce和Fetch)的基本形式，而且是kafka中压缩的基本单元。</p><ul><li>crc32， 4字节，crc32校验值，校验范围从magic到value</li><li>magic，1字节，消息格式版本号，此版本magic值为0</li><li>attributes，1字节，表示消息的属性，第三位表示消息的压缩类型，0为NONE，1为GZIP，2为SNAPPY，3为LZ4，其余位保留</li><li>key length，消息的key的长度，如果值为-1，表示此消息无key，即key&#x3D;null</li><li>key，可选，如果没有key则无此字段</li><li>value length，实际消息体的长度，如果为-1，表示消息为空</li><li>value，消息体，可以为空。</li></ul><p>v0版本的消息最小长度为crc32+magic+attributes+key length+value length &#x3D; 4+1+1+4+4&#x3D;14B，当消息的长度小于这个值，则可认为这条消息是破损的而不被接受。</p><h4 id="2-2、v1版本"><a href="#2-2、v1版本" class="headerlink" title="2.2、v1版本"></a>2.2、v1版本</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221348299.png" alt="v1版本"><br>v1版本的magic值为1，v1版本的消息最小长度为14+8&#x3D;22B，kafka从0.10.0版本开始到0.11.0之前使用的消息格式都是v1</p><p><strong>消息压缩</strong></p><p>kafka发送消息并不是一条一条发送的，而是通过消息集(message set)批量发送的，为了提高性能，kafka支持压缩消息的功能，具体来说就是压缩消息集。压缩解压过程是：生产者发送压缩消息集，broker端保存压缩的消息集，消费者解压消息集进行消费。这样就能减少网络IO消耗提升性能。</p><p>生产者可以通过配置compression.type来开启压缩功能，支持的压缩算法有GZIP、LZ4、SNAPPY三种。压缩消息时，将整个消息集进行压缩作为一个内层消息，这个内层消息作为外层消息的value，并将原来消息集最大的offset作为外层消息的offset，而内层消息的offset永远从0开始，如下图：<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221407322.png" alt="消息压缩"><br>对于压缩的情形，外层消息的timestamp设置为：</p><ul><li>如果timestamp类型是CreateTime，那么设置的是内层消息中最大的时间戳(the max timestamp of inner messages if CreateTime is used)</li><li>如果timestamp类型是LogAppendTime，那么设置的是kafka服务器当前的时间戳。</li></ul><p>内层消息的timestamp设置为：</p><ul><li>如果外层消息的timestamp类型是CreateTime，那么设置的是生产者创建消息时的时间戳</li><li>如果外层消息的timestamp类型是LogAppendTime，那么所有的内层消息时间戳都将被忽略</li></ul><h4 id="2-3、v2版本"><a href="#2-3、v2版本" class="headerlink" title="2.3、v2版本"></a>2.3、v2版本</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221428826.png" alt="v2版本"></p><p>kafka从0.11.0版本开始使用v2版本的消息格式，v2版本引入了变长整型(Varints)和ZigZag编码，Varints是使用一个或多个字节来序列化整数的一种方法，数值越小，其所占用的字节数就越少。ZigZag编码以一种锯齿状的方式来回穿梭于正负整数之间，以使得带符号整数映射为无符号整数，这样可使得绝对值较小的负数仍享有较小的Varints编码值。</p><p>如果没有使用Varints编码，如v0和v1，当key length &#x3D; -1时，int类型的需要4个字节来保存，而使用Varints只需要一个字节，根据Varints的规则可以推导出0-63之间的数字占1个字节，64-8191之间的数字占2个字节，8192-1048575之间的数字占3个字节。而kafka broker的配置message.max.bytes的默认大小为1000012（Varints编码占3个字节），如果消息格式中与长度有关的字段采用Varints的编码的话，绝大多数情况下都会节省空间，而v2版本的消息格式也正是这样做的。</p><p>v2版本引入了新的概念Record Batch，而摒弃了先前的Message Set，在消息压缩的情形下，Record Batch Header部分（从first offset到records count字段）是不被压缩的，而被压缩的是records字段中的所有内容。</p><p>关于Record字段描述：</p><ul><li>length：消息总长度</li><li>attributes：弃用，但是还是在消息格式中占据1B的大小，以备未来的格式扩展</li><li>timestamp delta：时间戳增量。通常一个timestamp需要占用8个字节，如果像这里保存与RecordBatch的其实时间戳的差值的话可以进一步的节省占用的字节数</li><li>offset delta：位移增量。保存与RecordBatch起始位移的差值，可以节省占用的字节数</li><li>headers：这个字段用来支持应用级别的扩展，而不需要像v0和v1版本一样不得不将一些应用级别的属性值嵌入在消息体里面。Header的格式如上图最有，包含key和value，一个Record里面可以包含0至多个Header</li></ul><p>RecordBatch字段描述：</p><ul><li>first offset：表示当前RecordBatch的起始位移</li><li>length：计算partition leader epoch到headers之间的长度</li><li>partition leader epoch：用来确保数据可靠性</li><li>magic：消息格式的版本号，对于v2版本而言，magic等于2</li><li>attributes，消息属性，注意这里占用了两个字节。低3位表示压缩格式，可以参考v0和v1；第4位表示时间戳类型；第5位表示此RecordBatch是否处于事务中，0表示非事务，1表示事务。第6位表示是否是Control消息，0表示非Control消息，而1表示是Control消息，Control消息用来支持事务功能</li><li>last offset delta：RecordBatch中最后一个Record的offset与first offset的差值。主要被broker用来确认RecordBatch中Records的组装正确性</li><li>first timestamp：RecordBatch中第一条Record的时间戳</li><li>max timestamp：RecordBatch中最大的时间戳，一般情况下是指最后一个Record的时间戳，和last offset delta的作用一样，用来确保消息组装的正确性</li><li>producer id：用来支持幂等性</li><li>producer epoch：和producer id一样，用来支持幂等性</li><li>first sequence：和producer id、producer epoch一样，用来支持幂等性</li><li>records count：RecordBatch中Record的个数</li></ul><h3 id="3、日志索引"><a href="#3、日志索引" class="headerlink" title="3、日志索引"></a>3、日志索引</h3><p>kafka的日志分段文件包括了两个索引文件：偏移量索引文件和时间戳索引文件。其中偏移量索引文件是为了建立消息偏移量与物理地址之间的映射关系，时间戳索引文件则是用来建立时间戳与偏移量的映射关系。索引文件都是以稀疏索引的方式构建的。</p><p>偏移量索引文件是单调递增的，查询时通过二分查找的方式快速定位到小于制定偏移量的最大偏移量，然后根据对应的物理地址找到对应的消息。时间索引文件中的时间戳也是单调递增的，查询时先定位到小于指定时间的最大时间戳，根据此时间戳对应的偏移量去偏移量索引文件中找到对应的消息。</p><h4 id="3-1、偏移量索引"><a href="#3-1、偏移量索引" class="headerlink" title="3.1、偏移量索引"></a>3.1、偏移量索引</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221452331.png" alt="偏移量索引"><br>偏移量索引文件中的每个索引占8个字节，分为两部分</p><ul><li>relative offset，相对偏移量，占4字节，表示消息相对于baseOffsset的偏移量，这个baseOffset即为此日志文件的名</li><li>position，物理地址，占4字节，表示消息在分段日志文件中的物理地址</li></ul><p>使用偏移量索引查找消息过程：</p><ul><li>因为偏移量索引文件文件名是baseOffset，所以可以使用二分法快速定位到指定的偏移量索引文件</li><li>找到索引文件后，在索引文件中利用二分法找到特定的索引项(小于当前偏移量的最大偏移量)，进而找到此索引相对应的物理地址，最后顺序查找出对应偏移量的消息。</li></ul><h4 id="3-2、时间戳索引"><a href="#3-2、时间戳索引" class="headerlink" title="3.2、时间戳索引"></a>3.2、时间戳索引</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221507594.png" alt="时间戳索引"><br>时间戳索引占12个字节，分为两部分</p><ul><li>timestamp，当前日志分段的最大时间戳</li><li>relative offset，时间戳对应的消息相对偏移量</li></ul><p>根据时间戳查找对应消息过程</p><ul><li>根据时间戳找到每个日志分段的文件中最大的时间戳逐一比较，定位到时间戳索引文件。由于时间戳索引文件也是根据baseOffset命名的，所以这一步无法使用二分法</li><li>在时间戳索引文件中使用二分法定位到时间戳索引项</li><li>根据时间戳索引项对应的偏移量使用偏移量索引找出对应的消息。</li></ul><h4 id="3-3、二分查找算法"><a href="#3-3、二分查找算法" class="headerlink" title="3.3、二分查找算法"></a>3.3、二分查找算法</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221523067.png" alt="二分查找算法"><br>kafka写入索引文件的方式是在文件末尾追加写入的，而几乎所有的索引查询都发生在索引尾部。kafka原本的二分查找并没有考虑到缓存的问题，可能会导致一些不必要的缺页中断，kafka线程会被阻塞等待索引项从磁盘读取并放入页缓存中。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221547106.png" alt="缺页中断"><br>上图kafka的某个索引占用了操作系统页缓存的13个页，如果待查找的位移值在最后一个页上则二分查找会一次读取编号为0、6、9、11、12的页。</p><p>通常情况下，一个页会存放成百上千的索引项，锁着索引文件被不断写入，page 12被不断地填充新的索引项。如果此时索引查询方都来自ISR副本集合或Lag很小的消费者，那么这些查询大都集中在对page 12 的查询上，此时page 0、6、9、11、12页一定或被经常性的访问，所以要把他们保存在页缓存上。</p><p>当page 12 空间被使用完了之后，会出现新的页，记为page 13，此时要查询最新的索引项所使用的页缓存为page 0、7、10、12、13，由于page 7和10很长时间没有使用过了，所以很可能会不在页缓存中，因此会出现缺页异常需要从磁盘中加载进页缓存中，这个过程可能会造成几毫秒至一秒的延迟。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221624202.png" alt="缺页中断"><br>基于上述问题，提出了缓存友好的二分算法，整体思路就是将所有索引项分为两个部分：热区和冷区。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221655730.png" alt="缓存友好的二分算法"><br>这个改进版算法的最大的优点在于查询最热那部分数据所遍历的page永远是固定的，因此大概率在页缓存中，从而避免无意义的缺页异常。</p><p>改进版二分查找算法流程：</p><ul><li>如果索引为空，直接返回&lt;-1, -1&gt;对；</li><li>确认热区第一个索引项位于哪个槽，_warmEntries参数就是所谓的分割线，目前固定为8192字节处，如果是OffsetIndex，_warmEntries &#x3D; 8192 &#x2F; 8 &#x3D; 1024，即第1024个槽，如果是TimeIndex，_warmEntries &#x3D; 8192 &#x2F; 12 &#x3D; 682，即第682个槽；</li><li>判断target位移在热区还是在冷区；</li><li>确保target位移值不能小于当前最小位移值；</li><li>如果在冷区，搜索冷区。</li></ul><p>通过索引查找消息复杂度为 O(log2n)+O(m)， n是索引文件里索引的个数，m为稀疏程度。</p><h3 id="4、日志清理之Log-Deletion"><a href="#4、日志清理之Log-Deletion" class="headerlink" title="4、日志清理之Log Deletion"></a>4、日志清理之Log Deletion</h3><p>可以通过设置broker端的参数log.cleanup.policy值来设置日志清理策略，此参数默认值为delete，当然也可设置为compact，如果将log.cleanup.policy设置为compact，还需要将log.cleanup.enable(默认为true)设置为true。除此之外，log.cleanup.policy的值还可设置为“delete,compact”同时支持日志删除和日志压缩。</p><p>kafka日志管理器中有一个专门的日志删除任务来周期性检测和删除不符合保留条件的日志分段文件，这个周期可以通过broker端的参数log.retention.check.interval.ms来配置，默认为300000，也即是5分钟检测一次。当前的日志分段保留策略有三种：基于时间、基于日志大小和基于日志起始偏移量的保留策略。</p><h4 id="4-1、基于时间"><a href="#4-1、基于时间" class="headerlink" title="4.1、基于时间"></a>4.1、基于时间</h4><p>基于此策略的日志删除会检查当前日志文件中是否保留有超过了设定的阈值(retentionMs)来寻找可删除的日志分段文件集合deletableSegments。retentionMs可以通过broker端参数log.retention.hours、log.retention.minutes、log.retention.ms来配置，其中ms优先级最高，minute次之，hour最低，默认情况下配置了hour为168，也就是默认情况下日志分段文件会被保留7天。</p><p>查找过期的日志分段文件，并不是简单的根据日志分段的最近修改时间lastModifyTime来计算，而是根据日志分段中最大的时间戳largestTimeStamp来计算。因为日志分段的lastModifyTime可以被修改，如分区副本被重新分配。获取largestTimeStamp要先查询该日志分段对应的时间戳索引文件，查找时间戳索引文件的最后一条索引项，若最后一条索引项的时间戳字段值大于0，则取其值，否则设置为lastModifyTime</p><p>如果此分区所有的日志分段文件都被标记为删除，此时会先切分出一个新的日志分段作为activeSegment勇于接受新消息的写入，然后在执行之前的删除操作。</p><p>日志分段删除流程如下：</p><ul><li>从日志对象文件中所维护的跳表中移除待删除的日志分段，以确保没有线程对这些日志分段进行读取操作</li><li>将待删除的日志分段文件加上“.delete”后缀，包括其对应的索引文件</li><li>最后交由一个以”delete-file”命名的延迟任务来删除这些“.delete”为后缀的文件，这个延迟任务可以通过file.delete.delay.ms来设置，默认为60000，即1min</li></ul><h4 id="4-2、基于日志大小"><a href="#4-2、基于日志大小" class="headerlink" title="4.2、基于日志大小"></a>4.2、基于日志大小</h4><p>broker端可以设置log.retention.bytes的值来设置一个分区日志文件的大小，默认为-1表示无穷大，这个值设置的是总的日志分段大小，而不是一个日志分段。</p><p>此策略的删除过程首先会计算需要删除的日志大小，然后从日志文件中的第一个日志分段开始进行查找可删除的日志分段的文件集合deletableSegments，然后删除，删除操作如4.1</p><h4 id="4-3、基于日志起始偏移量"><a href="#4-3、基于日志起始偏移量" class="headerlink" title="4.3、基于日志起始偏移量"></a>4.3、基于日志起始偏移量</h4><p>基于日志起始偏移量的删除策略的判断依据是某日志分段的下一个日志分段的起始偏移量baseOffset是否小于等于logStartOffset，若是则可以删除此日志分段。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221751634.png" alt="基于日志起始偏移量清除"><br>如上图，此时会删除前两个日志分段</p><h3 id="5、日志清理之Log-Compaction"><a href="#5、日志清理之Log-Compaction" class="headerlink" title="5、日志清理之Log Compaction"></a>5、日志清理之Log Compaction</h3><p>Log Compaction是日志压紧、压实，相同key的不同value值只保留最后一个版本，也就是kafka定期将相同key的消息进行合并，只保留最新的value值。</p><h3 id="6、切分文件的时机"><a href="#6、切分文件的时机" class="headerlink" title="6、切分文件的时机"></a>6、切分文件的时机</h3><p>日志文件和索引文件都会存在多个文件，组成多个SegmentLog，其切分规则如下：</p><ul><li>当前日志分段文件的大小超过了broker端参数log.segment.bytes配置的值，默认值为1G</li><li>当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于log.roll.ms或log.roll.hours参数配置的值，默认只配置了hour为186，即7天</li><li>偏移量索引文件或时间戳索引文件的大小达到了broker端参数log.index.size.max.bytes配置的值，默认为10MB</li><li>追加消息的偏移量与当前日志分段的偏移量之间的差值大于Integer.MAX_VALUE(4字节)，即要追加的消息的偏移量不能转变为相对偏移量。</li></ul><h3 id="7、零拷贝"><a href="#7、零拷贝" class="headerlink" title="7、零拷贝"></a>7、零拷贝</h3><p>kafka速度快的原因：</p><ul><li>多个partition可被并行读取</li><li>顺序写磁盘</li><li>”零拷贝“</li></ul><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221813770.png" alt="零拷贝"><br>DMA(Direct Memory Access)：直接存储器访问，一种可让某些硬件子系统去直接访问系统主内存，而不用依赖CPU的计算机系统的功能。也就是跳过CPU，直接访问主内存。传统的内存访问都需要通过CPU的调度来完成，DMA技术出现后使系统 CPU 从实际的 I&#x2F;O 数据传输过程中摆脱出来，从而大大提高系统的吞吐率。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221834154.png" alt="DMA"><br>很多硬件都支持DMA，其中就包括网卡。实际IO读写，需要进行IO中断，需要CPU响应中断(带来上下文切换)，尽管后来引入DMA来接管CPU的中断请求，但四次copy是存在“不必要的拷贝”的。在这两次CPU拷贝中，应用缓存除了缓存数据并将其传输回socket缓冲区之外并没有实际做什么，所以这两步是可以做优化的，传统IO方式，会注意到实际上并不需要第二个和第三个数据副本。</p><p>说明：这种优化掉两次cpu拷贝的场景，是在读取磁盘的文件后不需要进一步的处理，直接通过网络发送出去，kafka落盘操作就是这种情况，只是把数据写入磁盘，而不对数据进行操作。如果读取到的磁盘数据需要应用程序进一步处理的话，则必须要经过第二次和第三次拷贝，让数据在应用缓冲区处理。</p><p><strong>Memory Mapped Files</strong>，简称为mmap，他的作用就是将磁盘文件映射到内存，通过修改内存就能修改磁盘文件。实现方式就是通过页表的方式实现文件到内存的映射，映射完成后对物理内存的操作会被同步到磁盘上(在合适的时候有操作系统完成)。</p><p>通过mmap，进程想读写硬盘一样读写内存，这个内存是虚拟内存，所以不必担心实际内存的大小，因为有虚拟内存兜底。使用这种方式I&#x2F;O提升很大，省去了内核空间到用户空间复制的开销。<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221908291.png" alt="mmap"></p><p>mmap实现的”零拷贝”将上下文的切换次数从4次减少为了两次，拷贝次数从4次降低到了3次。</p><p><strong>sendfile函数</strong>，Linux从2.1开始引入此函数用于将文件通过socket发送，刚开始时和mmap没有区别，Linux2.4做了进一步的优化。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221932274.png" alt="sendfile函数"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka消费者</title>
    <link href="/2025/04/12/kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <url>/2025/04/12/kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、消费者与消费组"><a href="#1、消费者与消费组" class="headerlink" title="1、消费者与消费组"></a>1、消费者与消费组</h3><p>消费组是kafka提供的可扩展且具有容错性的消费者机制，同一个消费组的消费者共有一个groupId，一个分区只能被同一个消费组中的一个消费者消费。</p><p>消费组解决了什么问题：</p><ul><li>消费模式灵活，假设三个消费者订阅了一个主题，当使用三个消费组时，每个消费组有一个消费者，利用分区在不同消费组间共享的特性，就实现了发布订阅(广播)模式；当把这三个消费者放在一个消费组中时利用分区在消费组成员间互斥的特性实现了队列(单播)模式；</li><li>故障容灾，引进了消费组的概念，当消费组中的某个消费者出现故障时消费组会执行在平衡操作。</li></ul><h3 id="2、push-or-pull"><a href="#2、push-or-pull" class="headerlink" title="2、push or pull"></a>2、push or pull</h3><p>kafka的消费者采用的是pull模式主动从broker拉取数据，这种主动拉的模式可以让消费者根据自己的消费速率拉消息。如果采用push模式的话，不同消费者消费速率可能不同，无法设置一个使用所有消费者的push消息大小，push模式也可能会导致消费者消息来不及消费而积压。</p><p>但pull模式也有缺点，当broker中没有消息时，消费者频繁的pull是没有任何意义的，但kafka在消费者每次拉的时候带有一个参数，当消费者拉到的数据为空时，会等待这个时间之后再去pull。</p><p>消费者在拉消息的时候和生产者生产消息的batch机制有相似的设置，可以通过设置下面两个参数减少消费者与broker之间的频繁交互</p><p>fetch.min.byte：消费者从broker获取数据的最小字节数，如果消息大小小于此值，则broker会等待有足够的数据时把它返回给消费者</p><p>fetch.max.wait.ms：默认500ms，如果消费者获取最小数据量的要求得不到满足，就会在等待最多该属性所设置的时间后获取到数据。</p><h3 id="3、offset提交"><a href="#3、offset提交" class="headerlink" title="3、offset提交"></a>3、offset提交</h3><p>消费者位移存储在kafka的内部的主题__consumer_offsets中，之前版本的位移存储在zookeeper中，老版本的Kafka会把位移信息保存在zk中，当Consumer重启后，自动从zk中读取位移信息。这种设计使Kafka Broker不需要保存位移数据，可减少Broker端需要持有的状态空间，有利于实现高伸缩性，但zk不适用于高频的写操作，这令zk集群性能严重下降，在新版本中将消费者的位移数据作为一条条普通的Kafka消息，提交至内部主题__consumer_offsets中保存。实现高持久性和高频写操作。</p><p>Consumer 需要为分配给它的每个分区提交各自的位移数据，提交位移一是表征消费者的消费进度，二是可以在当前消费者发生故障重启后能从之前提交的位移处接着消费，避免再从头开始消费。</p><h3 id="4、自动提交与手动提交"><a href="#4、自动提交与手动提交" class="headerlink" title="4、自动提交与手动提交"></a>4、自动提交与手动提交</h3><p>从消费者的角度来说位移提交分为自动提交和手动提交。</p><h4 id="4-1-自动提交"><a href="#4-1-自动提交" class="headerlink" title="4.1 自动提交"></a>4.1 自动提交</h4><p>自动提交设置enable.auto.commit的值为true，默认是5s自动提交一次。</p><p>在自动提交时，先提交上一批次拉取消息的位移，再处理下一批次，因此自动提交能保证消息不丢失，但是自动提交存在重复消费的可能。默认情况下5s提交一次，假如在上次为已提交后的第3s发生了rebalance，则消费者会从上一次提交位移的地方开始消费，则rebalance前的3s数据就会被再次消费。可以通过 auto.commit.interval.ms设置自动提交的间隔时间，但是减少时间只能是减少重复消费的时间窗口，而不能完全消除。</p><h4 id="4-2-手动异步提交"><a href="#4-2-手动异步提交" class="headerlink" title="4.2 手动异步提交"></a>4.2 手动异步提交</h4><p>手动提交并不能完去代替自动提交，手动提交是异步的，不存在重试机制，因为手动提交是异步的，重试时提交的位移可能已不是最新的位移了，因此重试没有意义。</p><p>对于常规性阶段性的手动提交可以使用异步和非异步的方式组合的方式，将两者结合，使用异步提交的方式避免程序阻塞，当consumer结束消费时同步提交。</p><p>备注：如果不发生重平衡使用自动提交的方式。</p><h3 id="5、重平衡"><a href="#5、重平衡" class="headerlink" title="5、重平衡"></a>5、重平衡</h3><h4 id="5-1-重平衡的时机"><a href="#5-1-重平衡的时机" class="headerlink" title="5.1 重平衡的时机"></a>5.1 重平衡的时机</h4><p>订阅的主题数发生变化，这种情况只有在业务调整时才会发生，要么不发生，要么不可避免；</p><ul><li>主题分区发生变化，在部署之前就要考虑集群的容量，以便确定好分区数，因此调整的次数也是有限的，在低峰时进行调整；</li><li>消费组成员的变化，消费组成员发生变化的情况有下面两种：<ul><li>消费者处理消息超时，即如果消费者处理消费的消息的时间超过了Kafka集群配置的 max.poll.interval.ms 的值，那么该消费者将会自动离组</li><li>心跳超时，如果消费者在指定的session.timeout.ms时间内没有汇报心跳，那么Kafka就会认为该消费已经dead了</li></ul></li></ul><p>因此消费端的消费者组成员变化一般都是由于异常引起的，所以其产生的 Rebalance 也是最难控制的。</p><p>重平衡过程是靠消费者端的心跳线程通知到其他消费者实例的，每当消费者向其 coordinator 汇报心跳的时候，如果这个时候 coordinator 决定开启 Rebalance ，那么 coordinator 会将REBALANCE_IN_PROGRESS封装到心跳的响应中，当消费者接收到这个REBALANCE_IN_PROGRESS，他就知道需要开启新的一轮 Rebalance 了,所以heartbeat.interval.ms除了是设置心跳的间隔时间，其实也意味着 Rebalance 感知速度，心跳越快，Rebalance 就能更快的被各个消费者感知。</p><h4 id="5-2-重平衡流程"><a href="#5-2-重平衡流程" class="headerlink" title="5.2 重平衡流程"></a>5.2 重平衡流程</h4><p>消费者端重平衡流程：</p><ul><li><p>加入组，组内成员加入组时会向协调者发送JoinGroup请求，将自己订阅的主题上报，协调者会从这些组员中选出一个leader consumer，协调者会把消费者组订阅信息封装进JoinGroup请求的响应体中，然后发给领导者，由领导者统一做出分配方案后。然后进入到下一步：发送SyncGroup请求；<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221038299.png" alt="SyncGroup请求"></p></li><li><p>Leader Consumer分配方案，这一步的主要目的是让协调者接收分配方案，然后统一以 SyncGroup 响应的方式分发给所有成员，这样组内所有成员就都知道自己该消费哪些分区了<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221118123.png" alt="SyncGroup"><br>broker端的重平衡流程：</p></li><li><p>新成员加入组，当有新成员发送JoinGroup请求时，协调者会以心跳的方式通知之前的成员开启新一轮的重平衡</p></li><li><p>组成员主动离组</p></li><li><p>组成员崩溃离组</p></li><li><p>组成员提交位移</p></li></ul><h4 id="5-3-分区分配原则"><a href="#5-3-分区分配原则" class="headerlink" title="5.3 分区分配原则"></a>5.3 分区分配原则</h4><ul><li><p>Range，这种分配是基于每个主题的分区分配，如果主题的分区不能平均分配给组内每个消费者，那么对该主题，某些消费者会被分配到额外的分区，这种分配方式明显的一个问题是随着消费者订阅的Topic的数量的增加，不均衡的问题会越来越严重，可能会出现有的消费者分配很多分区，有的消费者分配较少的分区。</p></li><li><p>RoundRobin，RoundRobin是基于全部主题的分区来进行分配的，同时这种分配也是kafka默认的rebalance分区策略，<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526221156082.png" alt="rebalance过程"><br>发现C2承担了4个分区的消费而C1订阅了T1，是不是把T1P1交给C1消费能更加的均衡呢</p></li><li><p>Sticky，目的是在执行一次新的分配时，能在上一次分配的结果的基础上，尽量少的调整分区分配的变动，节省因分区分配变化带来的开销。每一次分配变更相对上一次分配做最少的变动。其目标有两点：</p><ul><li>分区的分配尽量的均衡。</li><li>每一次重分配的结果尽量与上一次分配结果保持一致。</li></ul></li></ul><p>当这两个目标发生冲突时，优先保证第一个目标。第一个目标是每个分配算法都尽量尝试去完成的，而第二个目标才真正体现出Sticky特性的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka生产者</title>
    <link href="/2025/04/12/kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <url>/2025/04/12/kafka%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、生产者"><a href="#1、生产者" class="headerlink" title="1、生产者"></a>1、生产者</h3><h4 id="1-1、batch"><a href="#1-1、batch" class="headerlink" title="1.1、batch"></a>1.1、batch</h4><p>生产者在发送消息时不会将每一条消息都单独发送到broker中，而是采取了批量发送以此减少网络请求次数和磁盘IO次数，消息会先发到缓冲区，这个缓冲区的大小是可配置的，在缓冲区中将消息进行分批，缓冲区大小默认为32M，当缓冲区使用完后消息的追加将会被阻塞直到有空闲的区域。<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526220934984.png" alt="生产写入过程"><br><strong>batch.size</strong>:  此参数配置发送到同一分区的批量提交的数据的大小，默认为16k，当消息积压到这个值就会批量发送，增大batch可以增加吞吐量，减小batch客降低消息延迟。</p><p><strong>linger.ms</strong>：但生产者也并不是非要等到大小挤压到一个批次大小才会发送，此参数就是等待一个批次大小的时间，linger.ms参数控制batch最大的空闲时间，超过该时间的batch也会被发送到broker端。</p><p>说明：当这两个参数同时设置的时候，只要两个条件中满足一个就会发送。比如说batch.size设置16kb，linger.ms设置50ms，那么当消息积压达到16kb就会发送，如果没有到达16kb，那么在第一个消息到来之后的50ms之后消息将会发送。</p><h3 id="2、同步发送与异步发送"><a href="#2、同步发送与异步发送" class="headerlink" title="2、同步发送与异步发送"></a>2、同步发送与异步发送</h3><h4 id="2-1、同步方式"><a href="#2-1、同步方式" class="headerlink" title="2.1、同步方式"></a>2.1、同步方式</h4><p>同步方式发送消息必需要等结果返回。</p><h4 id="2-2、异步方式"><a href="#2-2、异步方式" class="headerlink" title="2.2、异步方式"></a>2.2、异步方式</h4><p>生产者将消息发送给kafka之后不会等待结果返回，调用者可以继续其他的工作。对sarama函数库来说异步发送需要注意的地方就是Return.Successes的设置，如果没有将Return.Successes设置为true，而且消息发送的过程中没有出现错误，则在select块中要设置default，否则会挂住，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(asyncProducer sarama.AsyncProducer)</span></span> &#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> success := &lt;-asyncProducer.Successes():<br>log.Infof(<span class="hljs-string">&quot;Produced message successes: [%s]\n&quot;</span>, success.Value)<br><span class="hljs-keyword">case</span> err := &lt;-asyncProducer.Errors():<br>log.Errorf(<span class="hljs-string">&quot;Produced message failure: &quot;</span>, err)<br><span class="hljs-keyword">default</span>:<br>log.Infof(<span class="hljs-string">&quot;Produced messsage default&quot;</span>)<br><br>&#125;<br>&#125;<br>&#125;(asyncProducer)<br></code></pre></td></tr></table></figure><p>因为如果没有default语句，则上面的两个case都不会匹配到，就会挂在这。如果不写default语句，则Return.Successes要置为true。</p><p>此外还需考虑的一个问题就是当设置了Return.Successes的值为true，但是没有使用producer.Successes()，也会出现为题，因为随着生产消息的成功，success的chan会被写满(kafka内部控制大小)，写满的结果就是导致后面的success结果丢失，并且会导致producer不可用。</p><p>所以config.Producer.Return.Successes &#x3D; true和操作&lt;-producer.Successes()必须配套使用；配置成true，那么就要去读取Successes，如果配置成false，则不能去读取Successes。</p><h3 id="3、分区策略"><a href="#3、分区策略" class="headerlink" title="3、分区策略"></a>3、分区策略</h3><p>指明分区序号，会直接发送到被指定的分区中<br>没有指明分区序号，但消息存在key值，则会将key的hash值与topic的分区数取余得到分区序号<br>即没有partition序号，有没有key值的情况会在第一次调用时随机生成一个小于分区数的值，后面每次调用都会加一并与分区数取余作为分区号，此种方式即为round-robin方式</p><h3 id="4、ack应答机制"><a href="#4、ack应答机制" class="headerlink" title="4、ack应答机制"></a>4、ack应答机制</h3><p>ISR(in-sync replica set)<br>对于leader分区，它维护了一个ISR集合，记录了和leader保持同步的foller集合，当ISR中的follower完成同步之后会向leader发送ACK。当follower长时间未向leader同步消息，此follower会被踢出ISR，该函数阈值可有replica.lag.time.max.ms(broker)参数设定，当leader发生故障之后会被从ISR中移除，然后从剩下的ISR中选出一个作为leader。</p><h4 id="4-1、NoResponse-0"><a href="#4-1、NoResponse-0" class="headerlink" title="4.1、NoResponse (0)"></a>4.1、NoResponse (0)</h4><p>当ack设置为NoResponse时，producer不等待broker的ack，这一操作提供了一个最低的延迟，broker还没来的写入磁盘就返回，设置为此值延迟最低。</p><h4 id="4-2、WaitForLocal-1"><a href="#4-2、WaitForLocal-1" class="headerlink" title="4.2、WaitForLocal (1)"></a>4.2、WaitForLocal (1)</h4><p>ack设置为1时，会等待leader分区落盘成功后返回ack，如果leader落盘失败会重试，如果follower同步之前leader出现故障，数据将会丢失。</p><h4 id="4-3、WaitForAll-1"><a href="#4-3、WaitForAll-1" class="headerlink" title="4.3、WaitForAll (-1)"></a>4.3、WaitForAll (-1)</h4><p>ack设置为-1，表示所有的副本成功落盘后才返回ack，但是当所有的分区副本同步成功后在leader分区返回ack之前leader分区出现故障，则会导致producer重试，消息重复，可靠性最高。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chat聊天系统思考之二</title>
    <link href="/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%BA%8C/"/>
    <url>/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>考虑下面几个条件下如何提升kafka的消费速度</p><ul><li>消息要求严格有序，如chat聊天消息</li><li>业务处理速度慢，如处理一条数据需要100ms</li><li>分片不合理，如有的分区很闲，有的分区消息数量积压</li></ul><h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><h3 id="1、顺序问题"><a href="#1、顺序问题" class="headerlink" title="1、顺序问题"></a>1、顺序问题</h3><p>关于消息消费时存在先后顺序问题，在<a href="https://zhangphh-blogs.top/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80">chat聊天系统思考之一</a>中已经加以说明。具体实现大致为对同一会话、帖子Id等维度放入同一分区中，如使用Id % 分区数，如下图：<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/20.png" alt="kafka消费消息顺序"><br>上面的解决方案是将同一会话的消息发送至同一分区进行消费，但是但消费者的消费能力大概率是不够的，因此，需要并发处理，详见<br><a href="https://zhangphh-blogs.top/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80/">chat聊天系统思考之一</a><br><img src="https://gitee.com/zhangphh/images-collections/raw/master/21.png" alt="并发消费"><br><strong>注意</strong>：此时需要注意一个问题就是，当单个消费者消费分区，并将获取到的消息放入不同的队列中，此时还可能存在乱序问题，所以，可以考虑复用Id%队列数的方式，将同一个会话的消息放入到相同的队列中，让协程进行消费。</p><h3 id="2、消息不丢失问题"><a href="#2、消息不丢失问题" class="headerlink" title="2、消息不丢失问题"></a>2、消息不丢失问题</h3><p>上面的方案，当消费者从kafka拉到消息后，并没有等待处理完成就继续从kafka拉取消息然后缓存到内存中，等待消费队列慢慢消费，这个时候如果机器宕机，则内存中的消息将会丢失。</p><p>基于上面描述的问题，考虑使用手动提交offset。但是这样其实还存在一个问题就是：各个协程处理的offset值其实是不一样的，如下图：<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/22.png" alt="数据消费"><br>此时goroutine1和goroutine2 的消息的offset不一致，为了保证消息不丢失，采用以下策略：定期手动提交当前的offset信息，提交的offset值选当前分区的最小的offset，如上面的就选1001这个offset值。可以采用在内存中缓存处理的offset列表的实现方式，如下：<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/23.png" alt="offset提交"><br><strong>当内存中待处理的最大offset与最小的offset差值&gt;&#x3D; M时，阻塞消费线程继续从kafka拉取消息，控制异常情况下的数据最多不多于M条</strong><br>但是此时会引进一个新问题：消息重复消费</p><p>此时要保证消息消费的幂等性，如可通过消息唯一标识放入如redis中判断</p><h3 id="3、消息堆积问题"><a href="#3、消息堆积问题" class="headerlink" title="3、消息堆积问题"></a>3、消息堆积问题</h3><p>堆积原因：</p><ul><li>生产者短时间生产大量消息到broker，消费者无法及时消费，如大促</li><li>生产者无法感知消息堆积，仍继续生产消息，导致消息堆积进一步加剧</li><li>消费者能力不足，消费时间长，消费者宕机、网络异常与broker无法通信</li><li>业务功能存在bug，导致消费者无法消费</li></ul><p>解决方案<br>消费者端</p><ul><li>增加消费者数量，并采用并发消费</li><li>提高消费速度，避免消费时间过长。如果单条消息消费时间无法优化，可以提高批次拉取的数量(当批次拉取的数量较少时，拉取数据量&#x2F;处理时间 &lt; 生产速度时就容易堆积)</li><li>消费消息时尽量减少耗时操作，尽量减少三方接口调用、读写库等</li><li>合理设置消费组服务数量，合理增加topic的partition&#x3D;个数，消费者数 &gt;&#x3D; 分区数</li><li>补偿消费，即消费跳过积压数据，直接消费最新的数据，同时启动补偿数据进程消费积压数据</li></ul><p>生产者端</p><ul><li>支持熔断与隔离，当broker消息积压时，对生产者熔断</li><li>根据key采用合适的算法，将消息均匀分不到对应的分区中</li></ul><p>服务端</p><ul><li>进行预估，设置合理的分区数</li></ul><p>在电商中经常大促，因此很容易出现短时间内产生大量消息的问题，因此在大促前可根据历史情况进行容量预估和相关的扩容策略。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.51cto.com/article/713177.html">我是如何将一个老系统的Kafka消费者服务的性能提升近百倍的</a></p>]]></content>
    
    
    <categories>
      
      <category>工作总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作总结</tag>
      
      <tag>聊天系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chat聊天系统思考之一</title>
    <link href="/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80/"/>
    <url>/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前有段工作经历涉及到了chat相关，而消息的发送 -&gt; 存储 -&gt; 消费是由不同的团队负责的，因此消息如何再多个团队之间流通、以及通过什么介质传递都是需要考虑的问题。</p><p>之前我负责过一些消息消费的相关工作，消息发送团队将消息推送到kafka之后，由我们去订阅topic并消费对应的分区，拿到消息之后做对应的消息类型解析、消息发送双方可见性分析、接收方未读数、推送等业务处理。本文旨在记录之前工作中遇到的相关问题以及从consumer端如何优化处理。</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/15.png" alt="消息流转过程"></p><p>可以看到，消息系统中引入了kafka，因此如果kafka出现问题，那整个系统都会出现问题。</p><h3 id="顺序问题"><a href="#顺序问题" class="headerlink" title="顺序问题"></a>顺序问题</h3><h4 id="1、为什么要保证消息的顺序"><a href="#1、为什么要保证消息的顺序" class="headerlink" title="1、为什么要保证消息的顺序"></a>1、为什么要保证消息的顺序</h4><p>我们之所以能够回复对方发过来的消息的依据就是对方消息内容，因此对于chat系统来说，消息的顺序性是必须要求保证的硬核标准，如果消息乱序，那这个chat系统可以说是完全报废。因此对于chat系统来说<strong>必须要保证消息的顺序性</strong> 。</p><h4 id="2、如何保证消息的顺序性"><a href="#2、如何保证消息的顺序性" class="headerlink" title="2、如何保证消息的顺序性"></a>2、如何保证消息的顺序性</h4><p>众所周知，kafka有topic的概念，每个topic可以拥有多个<code>分区(partition)</code>，而每个分区的内部都是有序的<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/16.png" alt="kafka生产者"></p><p>如此一来，如何保证消息的顺序性思路就比较清晰了，完全可以利用<code>partition</code>的特性去做处理，按照一定的规则将消息写到不同的<code>partition</code>中去，然后消费者消费<code>partition</code>中的消息。</p><p>思考这样一个问题：写到<code>partition</code>中的消息要按照什么规则去做呢？试想一下，我们要保证消息的顺序性，有序性是在同一会话的前提下，也就是说不同会话之前不需要保证消息的顺序性，因此我们可以把<code>conversationId</code>去做如取余或哈希操作，将同一个<code>partition</code>会话的消息全都放入一个<code>partition</code>中。<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/17.png" alt="分区与消费者绑定关系"></p><h3 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h3><p>上述一期方案上线后在项目初期运行一段时间基本没问题，但随着产品推广用户量激增，上述消费架构就出现了问题：消息接收方受消息不够实时，延迟比较高，这对用户来说十分不友好，本来10秒钟几句话的事，到现在可能延迟有1分钟，这谁能忍得了啊。</p><p>虽然可以通过水平扩展增加机器数量来缓解压力，但这不是最优的方案，而且最主要是费钱。</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h5 id="1、消息体"><a href="#1、消息体" class="headerlink" title="1、消息体"></a>1、消息体</h5><p>思考下kafka消息发送到消息消费共经历了几次IO?</p><ul><li>从producer到broker经历一次网络IO</li><li>broker落盘经历一次磁盘IO</li><li>consumer从broker取数据时经历一次网络IO</li><li>broker从磁盘拿数据经历一次磁盘IO</li></ul><p>一共经历四次IO，引用一张如图说明<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/18.png" alt="kafka消息写入过程"></p><p>因此这里有个优化思路就是减少消费者取数据时broker从磁盘取数据时经历的IO耗时，那该如何减少呢？</p><p>试想一下，假设消费者每次取500条数据，如果每条消息的消息体过大，那取500条数据经历IO耗时势必会增加，进而影响生产和消费速度。而且当消息体过大时，还有可能会导致磁盘空间不足的问题。</p><h5 id="2、路由规则"><a href="#2、路由规则" class="headerlink" title="2、路由规则"></a>2、路由规则</h5><p>排除消息体过大的原因之后，我们需要看下kafka是否存在lag，如果存在lag我们要从消费者端解决问题。</p><p>根据监控查看出现lag的具体的分区，如果是同一个topic的特定某几个分区出现lag，那就需要考虑下是不是路由规则不合理的问题。</p><p>一个例子就是对于点餐系统，如果路由规则是根据商家ID来做的，而某些商家订单量一直很大，恰巧这些商家的相关消息都路由到了同一个<code>partition</code>，就导致只有这个<code>partition</code>出现了lag，进而消息处理较慢。</p><p>针对这种路由不合理的问题，解决方案就是选择合理的路由规则或key，如上述点餐系统，可以考虑路由规则根据订单号来做，因为所有订单号都是基于同一套方案生成的，所以基本不会出现个别<code>partition</code> lag太高的情况。</p><p>而chat系统之前也说过路由规则是基于<code>conversationId</code>去做的，而conversationId也是基于相同的方案生成的，所以如果出现lag发生，那理论上会涉及到大多数<code>partition</code>都出现lag。</p><h5 id="3、表过大"><a href="#3、表过大" class="headerlink" title="3、表过大"></a>3、表过大</h5><p>假设现在有1亿conversation存于一张表中，即使有索引，根据conversationId去查询对应会话信息的时候耗时也会很高，一条消息的消费原来可能只有500ms，但是现在可能需要5s甚至更久，因此，当数据量比较大时就要考虑分表了。</p><p>这里提供一种分表思路，基于conversatioId%100去做，或者是对1000取余。</p><h5 id="4、数据库主从延迟"><a href="#4、数据库主从延迟" class="headerlink" title="4、数据库主从延迟"></a>4、数据库主从延迟</h5><p>如果在生产环境数据库采用主从架构，主节点负责写，从节点负责读，在从broker拿到消息并完成解析拿到conversationId，这时候去会话团队拿数据，发现数据返回空，对应我们这边后续消费逻辑直接报错而返回，而会话团队根据conversationId去查是有这个会话的，这种情况第一次遇到时就显得很诡异。</p><p>后来进过分析发现，我们这边调接口时走的是会话团队数据库的从库，而主从同步还没将最新数据写到从库中。</p><p>发现问题后有两个解决方案：</p><ul><li>直接读master节点，这种方案不太可取，这样slave节点只作为备份？而且master节点压力会变大，甚至垮掉，也就失去了主从架构原有的作用。</li><li>加入重试机制，读取到conversation为空时，将此消息加入到<code>重试表</code>，在做后续处理。</li></ul><h5 id="5、并发消费"><a href="#5、并发消费" class="headerlink" title="5、并发消费"></a>5、并发消费</h5><p>上述消费架构是一个分区有一个消费者，既然一个消费者消费速度太慢，那何不增加消费者的数量呢？因此优化思路就有了：<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/19.png" alt="并发消费实现原理"></p><p>可以把每个<code>partition</code>中的消息按照conversationId%5然后放入到channel中，然后每个channel在配备一个goroutine去消费，这样既能保证同一会话消息的顺序性，又能提升消费速度尽量避免lag。</p>]]></content>
    
    
    <categories>
      
      <category>工作总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作总结</tag>
      
      <tag>聊天系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go实现的简单压测工具</title>
    <link href="/2025/04/12/go%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/04/12/go%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="1、参数概览"><a href="#1、参数概览" class="headerlink" title="1、参数概览"></a>1、参数概览</h3><p>依赖<code>github.com/ddliu/go-httpclient</code>进行http接口请求<br>依赖<code>github.com/antlabs/pcurl</code>解析curl</p><p>输入参数：</p><ul><li>-c，concurrency，并发数，启动协程数</li><li>-n， totalNumber，单个协程发送的请求个数</li><li>-u，curl字符串</li><li>-p，如果不使用-u，可以将curl地址放在文件中，使用-p传入curl文件地址</li><li>-e，expectCode，期望response返回的状态码</li></ul><h3 id="2、核心代码"><a href="#2、核心代码" class="headerlink" title="2、核心代码"></a>2、核心代码</h3><h4 id="1、网络请求server-dispose-go"><a href="#1、网络请求server-dispose-go" class="headerlink" title="1、网络请求server&#x2F;dispose.go"></a>1、网络请求server&#x2F;dispose.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注册verify校验器</span><br>verify.RegisterVerifyHttp(verify.GetVerifyKey(<span class="hljs-string">&quot;statusCode&quot;</span>), verify.VerifyHttpByStatusCode)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dispose</span><span class="hljs-params">(ctx context.Context, req *request.Request, concurrency, totalNumber <span class="hljs-type">uint64</span>)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *response.ResponseResult, <span class="hljs-number">1000</span>)<br>wg := sync.WaitGroup&#123;&#125;<br>wgReceiving := sync.WaitGroup&#123;&#125;<br><br>wgReceiving.Add(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 统计数据详情</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wgReceiving.Done()<br>statistics.HandleStatics(concurrency, ch)<br>&#125;()<br><br><span class="hljs-comment">// 传递的-c参数，为每个协程创建-n次请求</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>); i &lt; concurrency; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>chanId := i<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>serveHTTP(ctx, chanId, totalNumber, ch, req)<br>&#125;()<br>&#125;<br><br>wg.Wait()<br>time.Sleep(time.Millisecond)<br><span class="hljs-built_in">close</span>(ch)<br>wgReceiving.Wait()<br>&#125;<br><br><span class="hljs-comment">// 真正发送请求的方法</span><br><span class="hljs-comment">// chanId 每个协程的身份Id</span><br><span class="hljs-comment">// ch 用于接受http接口响应数据</span><br><span class="hljs-comment">// req 根据curl解析出来的request结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveHTTP</span><span class="hljs-params">(ctx context.Context, chanId, totalNumber <span class="hljs-type">uint64</span>, ch <span class="hljs-keyword">chan</span>&lt;- *response.ResponseResult, req *request.Request)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>); i &lt; totalNumber; i++ &#123;<br><span class="hljs-keyword">if</span> ctx.Err() != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;ctx.Err err: %v \n&quot;</span>, ctx.Err())<br><span class="hljs-keyword">break</span><br>&#125;<br>header := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> req.Header &#123;<br>header[k] = req.Header.Get(k)<br>&#125;<br><br>respStatusCode := constants.Success<br>isSucceed := <span class="hljs-literal">false</span><br><br>start := time.Now()<br>resp, err := httpclient.Do(req.Method, req.URL.String(), header, <span class="hljs-literal">nil</span>)<br>cost := <span class="hljs-type">uint64</span>(time.Since(start).Nanoseconds()) <span class="hljs-comment">//统计耗时</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || resp == <span class="hljs-literal">nil</span> &#123;<br>respStatusCode = constants.RequestFailed<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 校验response code与-e是否相同</span><br>respStatusCode, isSucceed = verify.GetVerify(verify.GetVerifyKey(<span class="hljs-string">&quot;statusCode&quot;</span>))(req, resp)<br>&#125;<br><br>result := &amp;response.ResponseResult&#123;<br>Id:         fmt.Sprintf(<span class="hljs-string">&quot;%d-%d&quot;</span>, chanId, i),<br>ChanId:     chanId,<br>Cost:       cost,<br>IsSucceed:  isSucceed,<br>StatusCode: respStatusCode,<br>&#125;<br><span class="hljs-comment">// 写数据</span><br>ch &lt;- result<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、校验器verify-verify-go"><a href="#2、校验器verify-verify-go" class="headerlink" title="2、校验器verify&#x2F;verify.go"></a>2、校验器verify&#x2F;verify.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Verify <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*request.Request, *httpclient.Response)</span></span> (constants.ErrCode, <span class="hljs-type">bool</span>)<br><br><span class="hljs-keyword">var</span> (<br>verifyMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Verify)<br>mutex     sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterVerifyHttp</span><span class="hljs-params">(key <span class="hljs-type">string</span>, verifyFunc Verify)</span></span> &#123;<br>mutex.Lock()<br><span class="hljs-keyword">defer</span> mutex.Unlock()<br>verifyMap[key] = verifyFunc<br>&#125;<br><br><span class="hljs-comment">// request 解析curl所得</span><br><span class="hljs-comment">// response http请求结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">VerifyHttpByStatusCode</span><span class="hljs-params">(request *request.Request, response *httpclient.Response)</span></span> (constants.ErrCode, <span class="hljs-type">bool</span>) &#123;<br>responseCode := response.StatusCode<br><span class="hljs-keyword">if</span> responseCode == request.ExpectedCode &#123;<br><span class="hljs-keyword">return</span> constants.ErrCode(responseCode), <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> constants.ErrCode(responseCode), <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetVerifyKey</span><span class="hljs-params">(t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;http.%s&quot;</span>, t)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetVerify</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> Verify &#123;<br>verify, ok := verifyMap[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;verify方法不存在&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> verify<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、解析curl-request-request-go"><a href="#3、解析curl-request-request-go" class="headerlink" title="3、解析curl  request&#x2F;request.go"></a>3、解析curl  request&#x2F;request.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>*http.Request<br>ExpectedCode <span class="hljs-type">int</span> <span class="hljs-comment">//-e参数输入</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRequest</span><span class="hljs-params">(curl, path <span class="hljs-type">string</span>, expectedCode <span class="hljs-type">int</span>)</span></span> (*Request, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 优先使用文件解析curl</span><br><span class="hljs-keyword">if</span> path != <span class="hljs-string">&quot;&quot;</span> &#123;<br>file, err := os.Open(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;open curl file %s failed, err: %+v\n&quot;</span>, path, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>buf, err := io.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;read curl file %s failed, err: %+v\n&quot;</span>, path, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>curl = <span class="hljs-type">string</span>(buf)<br>&#125;<br><br>req, err := pcurl.ParseAndRequest(curl)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;parse curl file %s failed, err: %+v\n&quot;</span>, path, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Request&#123;<br>Request:      req,<br>ExpectedCode: expectedCode,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、数据统计statstics-statistics-go"><a href="#4、数据统计statstics-statistics-go" class="headerlink" title="4、数据统计statstics&#x2F;statistics.go"></a>4、数据统计statstics&#x2F;statistics.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HandleStatics 所有耗时变量均为纳秒</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleStatics</span><span class="hljs-params">(concurrency <span class="hljs-type">uint64</span>, ch &lt;-<span class="hljs-keyword">chan</span> *response.ResponseResult)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>requestCostTimeList []<span class="hljs-type">uint64</span>     <span class="hljs-comment">// 耗时数组</span><br>processingTime      <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// processingTime 处理总耗时</span><br>requestCostTime     <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// requestCostTime 请求总时间</span><br>maxTime             <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// maxTime 至今为止单个请求最大耗时</span><br>minTime             <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// minTime 至今为止单个请求最小耗时</span><br>successNum          <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span><br>failureNum          <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span><br>chanIdLen           <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// chanIdLen 并发数</span><br>stopChan                     = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>mutex                        = sync.RWMutex&#123;&#125;<br>chanIds                      = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>)<br><br>startTime := <span class="hljs-type">uint64</span>(time.Now().UnixNano())<br>respCodeMap := sync.Map&#123;&#125;<br>ticker := time.NewTicker(time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>endTime := <span class="hljs-type">uint64</span>(time.Now().UnixNano())<br>mutex.Lock()<br><span class="hljs-keyword">go</span> calculateData(concurrency, processingTime, endTime-startTime, maxTime, minTime, successNum, failureNum, chanIdLen, &amp;respCodeMap)<br>mutex.Unlock()<br><span class="hljs-keyword">case</span> &lt;-stopChan:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br>printHeader()<br><span class="hljs-keyword">for</span> respRes := <span class="hljs-keyword">range</span> ch &#123;<br>mutex.Lock()<br>processingTime = processingTime + respRes.Cost<br><span class="hljs-keyword">if</span> maxTime &lt;= respRes.Cost &#123;<br>maxTime = respRes.Cost<br>&#125;<br><span class="hljs-keyword">if</span> minTime == <span class="hljs-number">0</span> &#123;<br>minTime = respRes.Cost<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> minTime &gt; respRes.Cost &#123;<br>minTime = respRes.Cost<br>&#125;<br><span class="hljs-keyword">if</span> respRes.IsSucceed &#123;<br>successNum = successNum + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>failureNum = failureNum + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 统计response状态码</span><br><span class="hljs-keyword">if</span> value, ok := respCodeMap.Load(respRes.StatusCode); ok &#123;<br>total, _ := value.(<span class="hljs-type">int</span>)<br>respCodeMap.Store(respRes.StatusCode, total+<span class="hljs-number">1</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>respCodeMap.Store(respRes.StatusCode, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 统计并发数</span><br><span class="hljs-keyword">if</span> _, ok := chanIds[<span class="hljs-type">int</span>(respRes.ChanId)]; !ok &#123;<br>chanIds[<span class="hljs-type">int</span>(respRes.ChanId)] = <span class="hljs-literal">true</span><br>chanIdLen = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(chanIds))<br>&#125;<br>requestCostTimeList = <span class="hljs-built_in">append</span>(requestCostTimeList, respRes.Cost)<br>mutex.Unlock()<br>&#125;<br><span class="hljs-comment">// 数据全部接受完成，停止定时输出统计数据</span><br>stopChan &lt;- <span class="hljs-literal">true</span><br>endTime := <span class="hljs-type">uint64</span>(time.Now().UnixNano())<br>requestCostTime = endTime - startTime<br>calculateData(concurrency, processingTime, requestCostTime, maxTime, minTime, successNum, failureNum, chanIdLen, &amp;respCodeMap)<br><br>fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;*************************  结果 stat  ****************************&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;处理协程数量:&quot;</span>, concurrency)<br>fmt.Println(<span class="hljs-string">&quot;请求总数（并发数*请求数 -c * -n）:&quot;</span>, successNum+failureNum, <span class="hljs-string">&quot;总请求时间:&quot;</span>,<br>fmt.Sprintf(<span class="hljs-string">&quot;%.3f&quot;</span>, <span class="hljs-type">float64</span>(requestCostTime)/<span class="hljs-number">1e9</span>),<br><span class="hljs-string">&quot;秒&quot;</span>, <span class="hljs-string">&quot;successNum:&quot;</span>, successNum, <span class="hljs-string">&quot;failureNum:&quot;</span>, failureNum)<br>printTop(requestCostTimeList)<br>fmt.Println(<span class="hljs-string">&quot;*************************  结果 end   ****************************&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateData</span><span class="hljs-params">(concurrent, processingTime, costTime, maxTime, minTime, successNum, failureNum, chanIdLen <span class="hljs-type">uint64</span>, respCodeMap *sync.Map)</span></span> &#123;<br><span class="hljs-keyword">if</span> processingTime == <span class="hljs-number">0</span> || chanIdLen == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> qps, averageTime, maxTimeFloat, minTimeFloat, requestCostTimeFloat <span class="hljs-type">float64</span><br><br><span class="hljs-comment">// 平均 QPS 成功数*总协程数/总耗时 (每秒)</span><br>qps = <span class="hljs-type">float64</span>(successNum*<span class="hljs-number">1e9</span>*concurrent) / <span class="hljs-type">float64</span>(processingTime)<br><br><span class="hljs-comment">// 平均耗时 总耗时/总请求数/并发数 纳秒=&gt;毫秒</span><br><span class="hljs-keyword">if</span> successNum != <span class="hljs-number">0</span> &amp;&amp; concurrent != <span class="hljs-number">0</span> &#123;<br>averageTime = <span class="hljs-type">float64</span>(processingTime) / <span class="hljs-type">float64</span>(successNum*<span class="hljs-number">1e6</span>)<br>&#125;<br>maxTimeFloat = <span class="hljs-type">float64</span>(maxTime) / <span class="hljs-number">1e6</span><br>minTimeFloat = <span class="hljs-type">float64</span>(minTime) / <span class="hljs-number">1e6</span><br>requestCostTimeFloat = <span class="hljs-type">float64</span>(costTime) / <span class="hljs-number">1e9</span><br><br>result := fmt.Sprintf(<span class="hljs-string">&quot;%4.0fs│%7d│%7d│%7d│%8.2f│%11.2f│%11.2f│%11.2f│%v&quot;</span>,<br>requestCostTimeFloat, chanIdLen, successNum, failureNum, qps, maxTimeFloat, minTimeFloat, averageTime, printMap(respCodeMap))<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHeader</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;─────┬───────┬───────┬───────┬────────┬───────────┬───────────┬───────────┬────────&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot; 耗时│ 并发数│ 成功数│ 失败数│   qps  │最长耗时/ms│最短耗时/ms│平均耗时/ms│ 状态码&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;─────┼───────┼───────┼───────┼────────┼───────────┼───────────┼───────────┼────────&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 打印响应状态码及数量, 如 200:5</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMap</span><span class="hljs-params">(respCodeMap *sync.Map)</span></span> (mapStr <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">var</span> mapArr []<span class="hljs-type">string</span><br><br>respCodeMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>mapArr = <span class="hljs-built_in">append</span>(mapArr, fmt.Sprintf(<span class="hljs-string">&quot;%v:%v&quot;</span>, key, value))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br>sort.Strings(mapArr)<br>mapStr = strings.Join(mapArr, <span class="hljs-string">&quot;;&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// printTop 排序后计算 top 90 95 99</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTop</span><span class="hljs-params">(requestCostTimeList []<span class="hljs-type">uint64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(requestCostTimeList) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>all := uint64Array&#123;&#125;<br>all = requestCostTimeList<br>sort.Sort(all)<br>fmt.Println(<span class="hljs-string">&quot;tp90:&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%.3fms&quot;</span>, <span class="hljs-type">float64</span>(all[<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(all))*<span class="hljs-number">0.90</span>)]/<span class="hljs-number">1e6</span>)))<br>fmt.Println(<span class="hljs-string">&quot;tp95:&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%.3fms&quot;</span>, <span class="hljs-type">float64</span>(all[<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(all))*<span class="hljs-number">0.95</span>)]/<span class="hljs-number">1e6</span>)))<br>fmt.Println(<span class="hljs-string">&quot;tp99:&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%.3fms&quot;</span>, <span class="hljs-type">float64</span>(all[<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(all))*<span class="hljs-number">0.99</span>)]/<span class="hljs-number">1e6</span>)))<br>&#125;<br><br><span class="hljs-keyword">type</span> uint64Array []<span class="hljs-type">uint64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(array uint64Array)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(array) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(array uint64Array)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; array[i], array[j] = array[j], array[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(array uint64Array)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> array[i] &lt; array[j] &#125;<br></code></pre></td></tr></table></figure><h4 id="5、main-go"><a href="#5、main-go" class="headerlink" title="5、main.go"></a>5、main.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>concurrency  <span class="hljs-type">uint64</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 并发数</span><br>totalNumber  <span class="hljs-type">uint64</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 请求个数</span><br>curl                = <span class="hljs-string">&quot;&quot;</span><br>curlPath            = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// curl文件路径</span><br>expectedCode        = <span class="hljs-number">200</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>flag.Uint64Var(&amp;concurrency, <span class="hljs-string">&quot;c&quot;</span>, concurrency, <span class="hljs-string">&quot;并发数&quot;</span>)<br>flag.Uint64Var(&amp;totalNumber, <span class="hljs-string">&quot;n&quot;</span>, totalNumber, <span class="hljs-string">&quot;请求数(单个并发)&quot;</span>)<br>flag.StringVar(&amp;curl, <span class="hljs-string">&quot;u&quot;</span>, curl, <span class="hljs-string">&quot;压测地址&quot;</span>)<br>flag.StringVar(&amp;curlPath, <span class="hljs-string">&quot;p&quot;</span>, curlPath, <span class="hljs-string">&quot;curl文件地址&quot;</span>)<br>flag.IntVar(&amp;expectedCode, <span class="hljs-string">&quot;e&quot;</span>, expectedCode, <span class="hljs-string">&quot;期望请求结果的状态码&quot;</span>)<br><br>flag.Parse()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(getCPUNum())<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(curl) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(curlPath) == <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;示例: go run main.go -c 1 -n 1 -u https://www.baidu.com/ \n&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>req, err := request.NewRequest(curl, curlPath, expectedCode)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>ctx := context.Background()<br>server.Dispose(ctx, req, concurrency, totalNumber)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCPUNum</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> runtime.NumCPU()/<span class="hljs-number">4</span> &lt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> runtime.NumCPU() / <span class="hljs-number">4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、验证猜想"><a href="#3、验证猜想" class="headerlink" title="3、验证猜想"></a>3、验证猜想</h3><ul><li>启动<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> -c <span class="hljs-number">1000</span> -n <span class="hljs-number">5000</span> -p D:\<span class="hljs-keyword">go</span>\<span class="hljs-keyword">go</span>-demo\gostress\test-stress.curl <br></code></pre></td></tr></table></figure></li><li>qps、耗时等统计如下<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/12.png" alt="qps"><br><img src="https://gitee.com/zhangphh/images-collections/raw/master/13.png" alt="耗时"></li></ul><p>为验证工具统计正确性，配置prometheus进行对照<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/14.png" alt="普罗米修斯监控指标"><br>可以看到prometheus在http server端统计到的数据qps、tp99、tp90、tp95基本上是符合的，由此验证工具正确性</p><h3 id="4、工具http接口-监控"><a href="#4、工具http接口-监控" class="headerlink" title="4、工具http接口&amp;监控"></a>4、工具http接口&amp;监控</h3><h4 id="1、server端监控代码monitor-monitor-go"><a href="#1、server端监控代码monitor-monitor-go" class="headerlink" title="1、server端监控代码monitor&#x2F;monitor.go"></a>1、server端监控代码monitor&#x2F;monitor.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 统计qps</span><br><span class="hljs-keyword">var</span> HttpRequestCount = prometheus.NewCounterVec(<br>prometheus.CounterOpts&#123;<br>Name: <span class="hljs-string">&quot;http_request_count&quot;</span>,<br>Help: <span class="hljs-string">&quot;http request count&quot;</span>,<br>&#125;,<br>[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;endpoint&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>&#125;,<br>)<br><br><span class="hljs-keyword">var</span> Histogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123;<br>Name:    <span class="hljs-string">&quot;histogram_showcase_metric&quot;</span>,<br>Buckets: []<span class="hljs-type">float64</span>&#123;<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">120</span>, <span class="hljs-number">130</span>, <span class="hljs-number">140</span>, <span class="hljs-number">150</span>, <span class="hljs-number">160</span>, <span class="hljs-number">170</span>, <span class="hljs-number">180</span>, <span class="hljs-number">190</span>, <span class="hljs-number">200</span>, <span class="hljs-number">210</span>, <span class="hljs-number">220</span>, <span class="hljs-number">230</span>, <span class="hljs-number">240</span>, <span class="hljs-number">250</span>, <span class="hljs-number">260</span>, <span class="hljs-number">270</span>, <span class="hljs-number">280</span>, <span class="hljs-number">290</span>, <span class="hljs-number">300</span>&#125;, <span class="hljs-comment">// 根据场景需求配置bucket的范围</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2、main-go"><a href="#2、main-go" class="headerlink" title="2、main.go"></a>2、main.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>prometheus.MustRegister(monitor.HttpRequestCount)<br>prometheus.MustRegister(monitor.Histogram)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/metrics&quot;</span>, PromHandler(promhttp.Handler()))<br>r.GET(<span class="hljs-string">&quot;/stress&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>start := time.Now()<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;gin demo&quot;</span>)<br>monitor.HttpRequestCount.WithLabelValues(c.Request.URL.Path, <span class="hljs-string">&quot;8888&quot;</span>).Inc()<br><br>n := rand.Intn(<span class="hljs-number">100</span>)<br><span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">95</span> &#123;<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>time.Sleep(<span class="hljs-number">50</span> * time.Millisecond)<br>&#125;<br><br>monitor.Histogram.Observe((<span class="hljs-type">float64</span>)(time.Since(start) / time.Millisecond))<br>&#125;)<br><br>r.Run(<span class="hljs-string">&quot;:8888&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PromHandler</span><span class="hljs-params">(handler http.Handler)</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>handler.ServeHTTP(c.Writer, c.Request)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、prometheus与grafana在windows安装步骤"><a href="#5、prometheus与grafana在windows安装步骤" class="headerlink" title="5、prometheus与grafana在windows安装步骤"></a>5、prometheus与grafana在windows安装步骤</h3><ul><li><p>prometheus安装<br>直接google，改配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br><br>  <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>  <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br><span class="hljs-comment"># 此次测试监控</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;go-stress&quot;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:8888&quot;</span>]<br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:8889&quot;</span>]<br><span class="hljs-comment"># 监控windows   </span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;windows&quot;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9182&quot;</span>]<br></code></pre></td></tr></table></figure><p>启动后打开localhost:9090查看</p></li><li><p>grafana安装<br>官网下载zip安装包，解压启动即可</p></li><li><p>grafana面板配置<br><strong>qps</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">sum(<span class="hljs-name">rate</span>(<span class="hljs-name">http_request_duration_count</span>&#123;&#125;[<span class="hljs-number">1</span>m])) by (<span class="hljs-name">endpoint</span>)<br></code></pre></td></tr></table></figure><p>TP90</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">histogram_quantile</span>(<span class="hljs-number">0</span>.<span class="hljs-number">90</span>, rate(histogram_showcase_metric_bucket&#123;instance=<span class="hljs-string">&quot;localhost:8888&quot;</span>&#125;[<span class="hljs-number">1</span>m]))<br></code></pre></td></tr></table></figure><p>TP99、TP95修改对应值即可</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>造轮子-工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>压测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于构建内容审核体系思考</title>
    <link href="/2025/04/12/%E5%85%B3%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%86%85%E5%AE%B9%E5%AE%A1%E6%A0%B8%E4%BD%93%E7%B3%BB%E6%80%9D%E8%80%83/"/>
    <url>/2025/04/12/%E5%85%B3%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%86%85%E5%AE%B9%E5%AE%A1%E6%A0%B8%E4%BD%93%E7%B3%BB%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="关于构建内容审核体系思考"><a href="#关于构建内容审核体系思考" class="headerlink" title="关于构建内容审核体系思考"></a>关于构建内容审核体系思考</h1><p>对于很多企业尤其是互联网内容企业如大型论坛、直播等来说，内容安全可以说是企业的生死线。内容审核能够甄别并过滤出涉黄、暴恐、违禁、不良价值观、广告等风险内容，确保企业平台上的信息符合法律法规和运营规则，从而保障企业的内容安全‌。</p><h1 id="1-服务划分"><a href="#1-服务划分" class="headerlink" title="1 服务划分"></a>1 服务划分</h1><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/7.png" alt="服务架构"></p><ul><li>业务层：产品的使用者，包括C端和B端用户，其中B端用户一般代表着商家，其发布的内容影响力相对来说会比较大，也是内容审核的重点。</li><li>接入层：通用网关，负责鉴权、路由转发、负载均衡等</li><li>应用层：应用层包含对单体资源的审核与业务复合型资源的打包审核，其中资源审核又分为机审和人审，机审误杀率实际上是比较高的，因此对于机审非PASS的需要介入人审，最终结果以人审为主</li><li>服务层：服务层主要是所依赖的第三方服务，用于机器审核</li><li>基础层：包含依赖的公共组件</li></ul><p>将内容审核服务收归并对外暴露一套接口以供其他业务接入，其他业务无需自己再维护一套机审逻辑<br>通过送审-机审-人审架构，实现业务零风险</p><h1 id="2-机审必要性"><a href="#2-机审必要性" class="headerlink" title="2 机审必要性"></a>2 机审必要性</h1><p>机审可以大大降低人工复核量，节约成本</p><ul><li>机审可以极大地降低人工复核量，对于一些机审PASS的就可以不再关注，只需关注机审存疑和直接拒绝的即可</li><li>灵活的审核策略与执行策略，针对不同业务指定不同审核规则，进而实现业务级审核粒度</li><li>鉴于机审存在误差，对于要求严格的业务，考虑多厂商交叉审核，只要有一个厂商认为图片有问题就流入人审复核</li></ul><h1 id="3-审核体系构建"><a href="#3-审核体系构建" class="headerlink" title="3 审核体系构建"></a>3 审核体系构建</h1><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/8.png" alt="机审主流程"></p><ul><li>机审整体流程如上图所示，其中图片、文本类机器审核响应速度很快，无需异步处理可实时获取到审核结果，但对于音频、视频、文档这类审核时间较长，需等审核完成后由厂商回调得到最终结果</li><li>图中红色 <strong>countdown动作</strong> 表示审核完成(最终态)计数动作，当countdown计数器降为0时会回调业务方，告知业务方业务资源最终审核状态，如动态是否审核通过，以此判断是否允许发布或全员可见</li></ul><h2 id="3-1-审核策略择路"><a href="#3-1-审核策略择路" class="headerlink" title="3.1 审核策略择路"></a>3.1 审核策略择路</h2><p>由于业务多样、资源类型不同、多厂商审核的原因，审核策略也就会存在多样，因此审核策略需要拎出来单独管理<br>此外，除了这种全局策略，对于电商这种存在店铺概念的还需支持店铺级审核策略及新店铺规则<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/9.png" alt="审核策略择路"></p><p>审核策略优先级为 店铺级 &gt; 新店铺 &gt; 全局策略<br>策略分级的优点</p><ul><li>当做白名单用：如当店铺自成立以来从无违规时，可为此店铺配置<code>全放行策略</code>，甚至是不审核，可以根据实际调整</li><li>当做黑名单用：当有一些店铺总是在红线附近横跳时也可将此店铺加入黑名单，并配置<code>机审严格</code>策略，让机审作为其结果而不用流入人审</li><li>新店铺自定义规则：对于新店铺，大部分情况下不需要太严格的审核策略，因此当度为新店铺配置一个规则是有必要的</li><li>店铺审核个性化配置：店铺级策略可支持但店铺定制化审核策略，为指定店铺不同来源路径下的资源配置不同审核策略</li></ul><h2 id="3-2-多厂商交叉审核"><a href="#3-2-多厂商交叉审核" class="headerlink" title="3.2 多厂商交叉审核"></a>3.2 多厂商交叉审核</h2><p>鉴于使用单厂商存在误判且无法容灾，考虑接入多云，只有当多厂商审核结果都为PASS时才放行，否则进入人审<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/10.png" alt="多云交叉审核"></p><p>对于交叉审核注意点有以下几条</p><ul><li>优先选择机审准确率高的厂商作为第一道审核线，以降低二次送审次数，节约成本</li><li>当A厂商结果为PASS时才需流入B厂商，若第一道审核已经判断为非PASS时，则无需进入第二道审核</li><li>第一道审核发生异常时自动以第二道审核为主，但需配置监控告警，及时感知送审异常</li><li>多云审核最终结果可根据具体情况而定</li></ul><h2 id="3-2-送审-机审-人审全流程"><a href="#3-2-送审-机审-人审全流程" class="headerlink" title="3.2 送审-机审-人审全流程"></a>3.2 送审-机审-人审全流程</h2><p>素材从送审-机审-人审全流程大致如下</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/11.jpeg" alt="审核全流程"></p><ul><li>送审：业务统一送审到内容审核，由内容审核统一做机审，根据素材类型和业务类型不同做对应的响应</li><li>机审：内容审核服务作为底层服务接收其他业务送审素材，统一送至云厂商，并接收云厂商审核结果回调将审核结果落库并通知送审业务方最终结果</li><li>人审：对于存在违规嫌疑的素材将会流入到人审阶段，人审分为初审与复审。初审只过滤违规片段，与业务分离实现脱敏，初审拒绝的将会流入到复审；复审审核内容与具体业务强相关，并且包含此业务所有素材</li></ul><h1 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4 其他问题"></a>4 其他问题</h1><ul><li>送审优化：业务方送审条件需额外设计，如帖子浏览量达某阈值之后再送审等</li><li>直播审核优化：直播审核违规截帧片段再审核，进一步降低误杀率</li><li>文本审核优化：文本审核增加白名单，避免相同文本重复审核</li><li>去重处理：除直播外所有资源审核需加去重操作，如根据素材ID + 策略ID做key审核之前做去重</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作总结</tag>
      
      <tag>内容审核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cachego内存模型原理剖析</title>
    <link href="/2025/04/12/cachego%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/2025/04/12/cachego%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="cachego-内存模型原理剖析"><a href="#cachego-内存模型原理剖析" class="headerlink" title="cachego 内存模型原理剖析"></a>cachego 内存模型原理剖析</h1><p><a href="https://github.com/FishGoddess/cachego">cachego github地址</a><br>cachego 是一个拥有分片机制的轻量级内存缓存库，API 友好，支持多种数据淘汰机制，可以应用于所有的 GoLang 应用程序中</p><p><strong>功能特性</strong></p><ul><li>以键值对形式缓存数据，极简的 API 设计风格</li><li>引入 option function 模式，简化创建缓存参数</li><li>提供 ttl 过期机制，支持限制键值对数量</li><li>提供 lru 清理机制，提供 lfu 清理机制</li><li>引入分片机制提高并发，分片与内存淘汰策略可灵活搭配</li><li>支持懒清理机制，每一次访问的时候判断是否过期</li><li>支持哨兵清理机制，每隔一定的时间间隔进行清理</li><li>自带 singleflight 机制，减少缓存穿透的伤害</li><li>支持上报缓存状况，可自定义多个缓存上报点</li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU（Least Recently Used）称为最近最少使用算法。基本的思想是：长期不被使用的数据，在未来被用到的几率也不大，因此当新的数据进来时，就可以优先将这些数据替换掉。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>cachego LRU策略底层实现为双向链表，头部为最活跃元素，尾部为最近最少使用元素。元素在使用后(插入&#x2F;查询&#x2F;更新)元素会移动到头部，当元素数超限后从尾部移除元素以供插入新元素</p><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/5.png" alt="LRU算法实现"></p><h3 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><ul><li>lruCache 元素存储结构体</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> lruCache <span class="hljs-keyword">struct</span> &#123;<br>*config<br><br>elementMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element <span class="hljs-comment">// map，存在性判断;快速获取元素值</span><br>elementList *list.List <span class="hljs-comment">// 双向链表用于实现LRU</span><br>lock        sync.RWMutex <span class="hljs-comment">// 读写锁</span><br><br>loader *loader<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>set操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> evict() (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <span class="hljs-comment">// 内存淘汰策略</span><br><span class="hljs-keyword">if</span> element := lc.elementList.Back(); element != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// lru队列尾部先过期</span><br><span class="hljs-keyword">return</span> lc.removeElement(element)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>element, ok := lc.elementMap[key]<br><span class="hljs-keyword">if</span> ok &#123; <span class="hljs-comment">// update更新操作</span><br>entry := lc.unwrap(element)<br>entry.setup(key, value, ttl)<br><br>lc.elementList.MoveToFront(element) <span class="hljs-comment">// 元素移到队首</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> lc.maxEntries &gt; <span class="hljs-number">0</span> &amp;&amp; lc.elementList.Len() &gt;= lc.maxEntries &#123; <span class="hljs-comment">// 队列已满, 从队尾移除最近最少访问的元素</span><br>evictedValue = lc.evict()<br>&#125;<br><br>element = lc.elementList.PushFront(newEntry(key, value, ttl, lc.now)) <span class="hljs-comment">// 新建元素, 头插</span><br>lc.elementMap[key] = element<br><br><span class="hljs-keyword">return</span> evictedValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>element, ok := lc.elementMap[key] <span class="hljs-comment">// map存在性断定</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>entry := lc.unwrap(element)<br><span class="hljs-keyword">if</span> entry.expired(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 过期直接判定不存在</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>lc.elementList.MoveToFront(element) <span class="hljs-comment">// 移到队首</span><br><span class="hljs-keyword">return</span> entry.value, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>代码实现上相对简单，通过map+双向链表实现LRU算法，核心set、get逻辑清晰</li><li>不足处: 虽然有定时任务扫描过期key，但get时对于过期key未立即删除，会存在隐患，若队尾元素未过期，存在过期元素在队列中间，则理论上应该优先淘汰过期key。如果需要严格遵守LRU则可忽略此问题，因此可根据实际业务决定是否改造这一点</li></ul><h2 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h2><p>LFU（least frequently used）最近最不经常使用的算法，对于每个数据，维护其使用的次数以及最近的使用时间，删除的策略是：优先删除使用次数最少的数据，如果存在多个使用次数相同的数据，则优先删除最远一次使用的数据。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>cachego 是基于最小堆实现的LFU，使用 <code>最小堆</code> 来维护按访问频率排序的元素。当元素被访问时，更新其访问频率。当缓存满时，使用 最小堆 删除访问频率最小的元素</p><ul><li>最小堆<br>一棵完全二叉树，非叶子结点的值不大于左孩子和右孩子的值<br><img src="https://gitee.com/zhangphh/images-collections/raw/master/6.png" alt="小根堆"></li></ul><h3 id="核心代码解读-1"><a href="#核心代码解读-1" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><ul><li><p>lfuCache结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> lfuCache <span class="hljs-keyword">struct</span> &#123;<br>*config<br><br>itemMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*heap.Item <span class="hljs-comment">// 同样的map，存在性判断及常数get</span><br>itemHeap *heap.Heap <span class="hljs-comment">// 小根堆</span><br>lock     sync.RWMutex<br><br>loader *loader<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lfuCache)</span></span> evict() (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <span class="hljs-comment">// 内存淘汰策略</span><br><span class="hljs-keyword">if</span> item := lc.itemHeap.Pop(); item != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 小根堆移除顶端元素</span><br><span class="hljs-keyword">return</span> lc.removeItem(item)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lfuCache)</span></span> set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>item, ok := lc.itemMap[key]<br><span class="hljs-keyword">if</span> ok &#123;<br>entry := lc.unwrap(item)<br>entry.setup(key, value, ttl)<br><br>item.Adjust(item.Weight() + <span class="hljs-number">1</span>) <span class="hljs-comment">// 核心访问次数加1,调整小根堆</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> lc.maxEntries &gt; <span class="hljs-number">0</span> &amp;&amp; lc.itemHeap.Size() &gt;= lc.maxEntries &#123; <span class="hljs-comment">// 过期驱除顶端key</span><br>evictedValue = lc.evict()<br>&#125;<br><br>item = lc.itemHeap.Push(<span class="hljs-number">0</span>, newEntry(key, value, ttl, lc.now)) <span class="hljs-comment">// 加入小根堆</span><br>lc.itemMap[key] = item<br><br><span class="hljs-keyword">return</span> evictedValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lfuCache)</span></span> get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>item, ok := lc.itemMap[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>entry := lc.unwrap(item)<br><span class="hljs-keyword">if</span> entry.expired(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 过期判断</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>item.Adjust(item.Weight() + <span class="hljs-number">1</span>) <span class="hljs-comment">// 访问次数加一</span><br><span class="hljs-keyword">return</span> entry.value, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>巧妙利用小根堆特性实现LFU，每次过期等删除操作只需移除顶端元素即可，增、改、查操作访问次数自增后堆结点元素需交换保证最小堆特性</li><li>不足处: 同样存在get操作唯一出过期key问题</li></ul><h2 id="Standard算法"><a href="#Standard算法" class="headerlink" title="Standard算法"></a>Standard算法</h2><p>cachego 默认存储及内存淘汰策略, 底层使用go原生map实现</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><p>go 原生map</p><h3 id="核心代码解读-2"><a href="#核心代码解读-2" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><ul><li><p>standardCache结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> standardCache <span class="hljs-keyword">struct</span> &#123;<br>*config<br><br>entries <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry <span class="hljs-comment">// 原生map, entry存储key、value、过期时间等</span><br>lock    sync.RWMutex<br><br>loader *loader<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *standardCache)</span></span> evict() (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <span class="hljs-comment">// 内存淘汰策略</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> sc.entries &#123; <span class="hljs-comment">// 随机过期key</span><br><span class="hljs-keyword">return</span> sc.remove(key)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *standardCache)</span></span> set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>entry, ok := sc.entries[key]<br><span class="hljs-keyword">if</span> ok &#123;<br>entry.setup(key, value, ttl)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> sc.maxEntries &gt; <span class="hljs-number">0</span> &amp;&amp; sc.size() &gt;= sc.maxEntries &#123; <span class="hljs-comment">// 超限随机过期key</span><br>evictedValue = sc.evict()<br>&#125;<br><br>sc.entries[key] = newEntry(key, value, ttl, sc.now)<br><span class="hljs-keyword">return</span> evictedValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *standardCache)</span></span> get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>entry, ok := sc.entries[key]<br><span class="hljs-keyword">if</span> ok &amp;&amp; !entry.expired(<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> entry.value, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>gocahce支持三套内存模型以供用户选择底层存储及内存淘汰策略</li><li>提供 ttl 过期机制，支持限制键值对数量</li><li>支持懒清理机制，每一次访问的时候判断是否过期</li></ul>]]></content>
    
    
    <categories>
      
      <category>每日一库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存缓存</tag>
      
      <tag>cachego</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cachego分片、上报、GC与数据加载机制原理</title>
    <link href="/2025/04/12/cachego%E5%88%86%E7%89%87%E3%80%81%E4%B8%8A%E6%8A%A5%E3%80%81GC%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2025/04/12/cachego%E5%88%86%E7%89%87%E3%80%81%E4%B8%8A%E6%8A%A5%E3%80%81GC%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="cachego-分片、上报、GC与数据加载机制原理"><a href="#cachego-分片、上报、GC与数据加载机制原理" class="headerlink" title="cachego 分片、上报、GC与数据加载机制原理"></a>cachego 分片、上报、GC与数据加载机制原理</h1><p><a href="https://github.com/FishGoddess/cachego">cachego github地址</a> </p><ul><li>为减小锁之间的竞争，cachego引入了分片机制，将key分散到多个sharding中，减低锁冲突概率加速索引。 sharding机制可与lru、lfu、standard模式丝滑结合，以实现cache中所有sharding内存模型都是指定的某种类型。</li><li>reporter 上报功能，支持上报hit次数、miss次数、gc次数、load次数(从下层存储load次数)，同时通过 option function 模式提供灵活的上报函数注册满足业务定制化上报功能。</li></ul><h2 id="newCache操作"><a href="#newCache操作" class="headerlink" title="newCache操作"></a>newCache操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCache</span><span class="hljs-params">(withReport <span class="hljs-type">bool</span>, opts ...Option)</span></span> (cache Cache, reporter *Reporter) &#123;<br>conf := newDefaultConfig()<br>applyOptions(conf, opts) <span class="hljs-comment">// option 模式赋值config</span><br><br>newCache, ok := newCaches[conf.cacheType] <span class="hljs-comment">// 选择内存模型 lru/lfu/standard</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cachego: cache type doesn&#x27;t exist&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> conf.shardings &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// cache分片, 本文讨论重点</span><br>cache = newShardingCache(conf, newCache)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cache = newCache(conf)<br>&#125;<br><br><span class="hljs-keyword">if</span> withReport &#123; <span class="hljs-comment">// 上报, 本文讨论重点</span><br>cache, reporter = report(conf, cache)<br>&#125;<br><br><span class="hljs-keyword">if</span> conf.gcDuration &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// gc</span><br>RunGCTask(cache, conf.gcDuration)<br>&#125;<br><br><span class="hljs-keyword">return</span> cache, reporter<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>newCache函数通过option模式允许用户自定义配置</li><li>根据用户配置决定是否创建sharding与reporter</li><li>根据所传gc间隔时长制定gc回收计划</li></ul><h2 id="shardingCache实现原理"><a href="#shardingCache实现原理" class="headerlink" title="shardingCache实现原理"></a>shardingCache实现原理</h2><h3 id="newShardingCache操作"><a href="#newShardingCache操作" class="headerlink" title="newShardingCache操作"></a>newShardingCache操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newShardingCache</span><span class="hljs-params">(conf *config, newCache <span class="hljs-keyword">func</span>(conf *config)</span></span> Cache) Cache &#123;<br><span class="hljs-keyword">if</span> conf.shardings &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cachego: shardings must be &gt; 0.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> bits.OnesCount(<span class="hljs-type">uint</span>(conf.shardings)) &gt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 只允许设置2的幂个分片</span><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cachego: shardings must be the pow of 2 (such as 64).&quot;</span>)<br>&#125;<br><br>caches := <span class="hljs-built_in">make</span>([]Cache, <span class="hljs-number">0</span>, conf.shardings)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; conf.shardings; i++ &#123; <span class="hljs-comment">// 循环创建分片数的cache，每个分片都是一个cache(lru/lfu/standard)</span><br>caches = <span class="hljs-built_in">append</span>(caches, newCache(conf))<br>&#125;<br><br>cache := &amp;shardingCache&#123;<br>config: conf,<br>caches: caches,<br>&#125;<br><br><span class="hljs-keyword">return</span> cache<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FNV-1a算法"><a href="#FNV-1a算法" class="headerlink" title="FNV-1a算法"></a>FNV-1a算法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hash</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// 高效的sharding分片寻址算法, FNV-1a算法 </span><br>hash := <span class="hljs-number">1469598103934665603</span><br><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> key &#123; <br>hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + <span class="hljs-type">int</span>(r&amp;<span class="hljs-number">0xffff</span>)<br>hash *= <span class="hljs-number">1099511628211</span><br>&#125;<br><br><span class="hljs-keyword">return</span> hash<br>&#125;<br></code></pre></td></tr></table></figure><p>算法高效原因</p><ul><li>简单的操作，<ul><li>左移操作：hash &lt;&lt; 5 </li><li>加法和减法：(hash &lt;&lt; 5) - hash 加法是哈希混合的一部分，有助于在不同字符之间产生良好的差异。</li><li>乘法：hash *&#x3D; 1099511628211 使用一个质数进行乘法引入更多的不可预测性。质数乘法有助于散列过程的均匀分布，因为质数避免了模式和重复的出现，从而减少碰撞</li></ul></li><li>通过 (hash &lt;&lt; 5) - hash 和 hash *&#x3D; 1099511628211，每个字符都会引入一个新的混合因子，使得前面的字符和后面的字符对最终哈希值的贡献是均匀的，这意味着输入数据中的每一个字符都能够“影响”哈希值的所有位，导致哈希值具有很好的散列性质</li><li>复杂度是 O(n), 通过质数乘法和每个字符的逐步混合减少哈希碰撞</li></ul><h3 id="set操作"><a href="#set操作" class="headerlink" title="set操作"></a>set操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *shardingCache)</span></span> Set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (oldValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">return</span> sc.cacheOf(key).Set(key, value, ttl)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *shardingCache)</span></span> cacheOf(key <span class="hljs-type">string</span>) Cache &#123; <span class="hljs-comment">// sharding 寻址操作</span><br>hash := sc.hash(key) <span class="hljs-comment">// FNV-1a算法 </span><br>mask := <span class="hljs-built_in">len</span>(sc.caches) - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">return</span> sc.caches[hash&amp;mask] <span class="hljs-comment">// 与sharding数与操作选定sharding</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>采用高效的<code>FNV-1a</code>算法获取key的散列值，确保了key的均匀性与sharding寻址速度</li><li>最终写入操作还是三种核心cache执行，key-value最终会被存入所选的lruCache、lfuCache或standardCache</li><li>除此之外shardingCache的hash也是支持自定义的，在创建cache时可自定义实现<code>WithHash()</code></li></ul><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>get操作通过FNV-1a算法定位到sharding后执行对应cache的get获取</p><h2 id="reportableCache实现原理"><a href="#reportableCache实现原理" class="headerlink" title="reportableCache实现原理"></a>reportableCache实现原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">report</span><span class="hljs-params">(conf *config, cache Cache)</span></span> (Cache, *Reporter) &#123;<br>reporter := &amp;Reporter&#123; <span class="hljs-comment">// 构建reporter</span><br>conf:        conf,<br>cache:       cache,<br>hitCount:    <span class="hljs-number">0</span>,<br>missedCount: <span class="hljs-number">0</span>,<br>gcCount:     <span class="hljs-number">0</span>,<br>loadCount:   <span class="hljs-number">0</span>,<br>&#125;<br><br>cache = &amp;reportableCache&#123;<br>config:   conf,<br>Reporter: reporter,<br>&#125;<br><br><span class="hljs-keyword">return</span> cache, reporter<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="set操作-1"><a href="#set操作-1" class="headerlink" title="set操作"></a>set操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rc *reportableCache)</span></span> Set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">return</span> rc.cache.Set(key, value, ttl)<br>&#125;<br></code></pre></td></tr></table></figure><p>set操作核心是调用另外三种cache的set接口执行写入操作</p><h3 id="get操作-1"><a href="#get操作-1" class="headerlink" title="get操作"></a>get操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rc *reportableCache)</span></span> Get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>value, found = rc.cache.Get(key) <span class="hljs-comment">// get</span><br><br><span class="hljs-keyword">if</span> found &#123;<br><span class="hljs-keyword">if</span> rc.recordHit &#123; <span class="hljs-comment">// hit数自增, atomic库操作</span><br>rc.increaseHitCount()<br>&#125;<br><br><span class="hljs-keyword">if</span> rc.reportHit != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 上报</span><br>rc.reportHit(rc.Reporter, key, value) <span class="hljs-comment">// reportHit 自定义上报函数</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> rc.recordMissed &#123; <span class="hljs-comment">// miss数自增, atomic库操作</span><br>rc.increaseMissedCount()<br>&#125;<br><br><span class="hljs-keyword">if</span> rc.reportMissed != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 上报</span><br>rc.reportMissed(rc.Reporter, key) <span class="hljs-comment">// reportMissed 自定义上报函数</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> value, found<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作分为两步操作，先获取到值，再执行上报逻辑，其中hit与miss数均使用atomic库操作，保证原子性。</li><li>上报函数是由用户自定义，同时cachego也提供了HitRate与MissedRate等函数进行概率计算，详情可参考 <code>./_examples/report.go</code></li></ul><h2 id="gc与load数据加载"><a href="#gc与load数据加载" class="headerlink" title="gc与load数据加载"></a>gc与load数据加载</h2><h3 id="垃圾清理机制"><a href="#垃圾清理机制" class="headerlink" title="垃圾清理机制"></a>垃圾清理机制</h3><p>gc函数用于手动清理过期key。可在创建cache时手动传入<code>WithGC()</code>指定定时清理时间间隔，或者手动调用<code>GC()</code>函数执行</p><h4 id="定时清理"><a href="#定时清理" class="headerlink" title="定时清理"></a>定时清理</h4><p>在创建cache时如果传入<code>WithGC()</code>，则会执行<code>RunGCTask()</code>函数在后台定时扫描并清理过期数据，详情可参考<code>newCache</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RunGCTask</span><span class="hljs-params">(cache Cache, duration time.Duration)</span></span> (cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>fn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>cache.GC() <span class="hljs-comment">// 调用对应的cache只执行gc</span><br>&#125;<br><br>ctx := context.Background()<br>ctx, cancel = context.WithCancel(ctx)<br><br><span class="hljs-keyword">go</span> task.New(fn).Context(ctx).Duration(duration).Run()<br><span class="hljs-keyword">return</span> cancel<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Task)</span></span> Run() &#123;<br><span class="hljs-keyword">if</span> t.fn == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> t.before != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// AOP前置操作</span><br>t.before(t.ctx)<br>&#125;<br><br><span class="hljs-keyword">if</span> t.after != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// AOP后置操作</span><br><span class="hljs-keyword">defer</span> t.after(t.ctx)<br>&#125;<br><br>ticker := time.NewTicker(t.duration)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br><br><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// ticker定时执行</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t.ctx.Done():<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>t.fn(t.ctx) <span class="hljs-comment">// 执行自定义清理函数</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定时垃圾回收通过ticker+for循环定时执行，且返回一个cancel函数支持手动终止回收任务</li><li>task包封装了任务执行过程，允许自定义函数前置和后置操作，类似AOP操作</li><li>自动清理相比于手动清理多了一个定时任务触发</li></ul><h4 id="手动清理"><a href="#手动清理" class="headerlink" title="手动清理"></a>手动清理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> gc() (cleans <span class="hljs-type">int</span>) &#123;<br>now := lc.now()<br>scans := <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> _, element := <span class="hljs-keyword">range</span> lc.elementMap &#123;<br>scans++<br><br><span class="hljs-keyword">if</span> entry := lc.unwrap(element); entry.expired(now) &#123;<br>lc.removeElement(element)<br>cleans++<br>&#125;<br><br><span class="hljs-keyword">if</span> lc.maxScans &gt; <span class="hljs-number">0</span> &amp;&amp; scans &gt;= lc.maxScans &#123; <span class="hljs-comment">// 控制扫描key的数量以实现部分扫描</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> cleans <span class="hljs-comment">// return被清理的数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>手动清理支持指定扫描key数量，以免扫描key过多导致资源占用过多<br>如果cache类型是reportableCache，则在清理完成后还会刷新相关指标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rc *reportableCache)</span></span> GC() (cleans <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> rc.recordGC &#123; <span class="hljs-comment">// gc次数自增</span><br>rc.increaseGCCount()<br>&#125;<br><br><span class="hljs-keyword">if</span> rc.reportGC == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> rc.cache.GC()<br>&#125;<br><br>begin := rc.now()<br>cleans = rc.cache.GC()<br>end := rc.now()<br><br>cost := time.Duration(end - begin)<br>rc.reportGC(rc.Reporter, cost, cleans) <span class="hljs-comment">// 上报耗时、被清理key的数量</span><br><br><span class="hljs-keyword">return</span> cleans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="load数据加载"><a href="#load数据加载" class="headerlink" title="load数据加载"></a>load数据加载</h2><p>当在cache获取到某个key不存在时，可以向下层存取加载，这是可以使用cachego的<code>Load()</code>函数实现。<br><code>Load()</code>函数支持自定义加载函数，将从下层获取到的值再set会cachego中，且引入了<code>singleflight</code>减少缓存穿透的伤害</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> Load(key <span class="hljs-type">string</span>, ttl time.Duration, load <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)) (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>value, err = lc.loader.Load(key, ttl, load)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> value, err<br>&#125;<br><br>lc.Set(key, value, ttl)<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *loader)</span></span> Load(key <span class="hljs-type">string</span>, ttl time.Duration, load <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)) (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> load == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;cachego: load function is nil in loader&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> l.group == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> load()<br>&#125;<br><br><span class="hljs-keyword">return</span> l.group.Call(key, load)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Call calls fn in singleflight mode and returns its result and error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Call(key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 避免同一时间多次调用同一个函数</span><br>g.lock.Lock()<br><br><span class="hljs-keyword">if</span> c, ok := g.calls[key]; ok &#123; <span class="hljs-comment">// 如果已经存在调用，则直接wait等待结果返回即可</span><br>g.lock.Unlock()<br><br><span class="hljs-comment">// Waiting...</span><br>c.wg.Wait()<br><span class="hljs-keyword">return</span> c.result, c.err<br>&#125;<br><br>c := newCall(fn)<br>c.wg.Add(<span class="hljs-number">1</span>)<br><br>g.calls[key] = c<br>g.lock.Unlock()<br><br>c.do()<br>g.lock.Lock()<br><br><span class="hljs-keyword">if</span> !c.deleted &#123; <span class="hljs-comment">// 完成调用后，删除</span><br><span class="hljs-built_in">delete</span>(g.calls, key)<br>&#125;<br><br>g.lock.Unlock()<br><span class="hljs-keyword">return</span> c.result, c.err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>singleflight是什么</p><ul><li>singleflight 避免重复的网络请求：对于重复的网络请求（如缓存查询），来避免多个 goroutine 发起重复的请求。</li><li>避免重复的数据库查询：类似于网络请求，多个并发查询可以避免重复的数据库访问。</li><li>共享计算结果：如果某个计算过程非常复杂且耗时，多个并发任务可以共享这个计算结果，而不需要重新计算</li></ul></li><li><p>load函数核心为从下层取数据，再写入当前内存缓存中</p></li><li><p>为避免同一key短时间内从下层存储中多次load，默认singleflight是开启的，如果不想用的话可以在新建 cachego传入<code>WithDisableSingleflight()</code>以关闭</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>每日一库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存缓存</tag>
      
      <tag>cachego</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+GitHub+阿里云域名解析搭建博客</title>
    <link href="/2024/11/16/Hexo-GitHub-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/11/16/Hexo-GitHub-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h1><p>node、github相关环境搭建参照: <a href="https://blog.csdn.net/weixin_44763569/article/details/106435118">搭建Hexo个人博客详细教程</a></p><h1 id="2-Hexo更换主题"><a href="#2-Hexo更换主题" class="headerlink" title="2.Hexo更换主题"></a>2.Hexo更换主题</h1><p>主题选用 <a href="https://hexo.fluid-dev.com/page/2/#board">Fluid</a>，效果如下<br><img src="https://i-blog.csdnimg.cn/direct/fb20f206a78b416591a2a54e4a89437c.png" alt="Fluid主题首页效果图"></p><h2 id="2-1-Fluid安装"><a href="#2-1-Fluid安装" class="headerlink" title="2.1 Fluid安装"></a>2.1 Fluid安装</h2><p>参考Fluid文档: <a href="https://hexo.fluid-dev.com/docs/start/">Fluid开始使用</a></p><p>推荐使用npm方式安装</p><h2 id="2-2-Fluid配置指南"><a href="#2-2-Fluid配置指南" class="headerlink" title="2.2 Fluid配置指南"></a>2.2 Fluid配置指南</h2><p>参照文档: <a href="https://hexo.fluid-dev.com/docs/guide/">Fluid配置指南</a></p><h1 id="3-Hexo创建文档及提交方式"><a href="#3-Hexo创建文档及提交方式" class="headerlink" title="3. Hexo创建文档及提交方式"></a>3. Hexo创建文档及提交方式</h1><h2 id="3-1-配置github仓库"><a href="#3-1-配置github仓库" class="headerlink" title="3.1 配置github仓库"></a>3.1 配置github仓库</h2><p>在本地所创建的项目里面找到 _congif.yml文件，找到 deploy 字段，把以下代码放进去，填写第一步新建的仓库地址<br><img src="https://i-blog.csdnimg.cn/direct/b073575427764f1880fb4bdce527d1eb.png" alt="配置github仓库"></p><h2 id="3-2-安装推送工具"><a href="#3-2-安装推送工具" class="headerlink" title="3.2 安装推送工具"></a>3.2 安装推送工具</h2><p>用npm安装一个推送工具，将本地项目推到仓库上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h2 id="3-3-创建文章及推送"><a href="#3-3-创建文章及推送" class="headerlink" title="3.3 创建文章及推送"></a>3.3 创建文章及推送</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new 测试文章 <span class="hljs-comment"># 1.创建新文章，&#x27;测试文章&#x27;为文件名，文章格式为markdown，新文章在source/_posts目录下</span><br>hexo clean <span class="hljs-comment"># 2.此命令用于清除缓存(非必须但建议执行)</span><br>hexo g <span class="hljs-comment"># 3.hexo generate简写，即生成静态文件</span><br>hexo deploy <span class="hljs-comment"># 4. 推送到github</span><br></code></pre></td></tr></table></figure><p>注意: 只有推送到github后才能通过域名方式访问，否则只能在本地localhost:4000(<code>hexo server</code> 命令启动本地server)查看</p><h1 id="4-域名绑定"><a href="#4-域名绑定" class="headerlink" title="4. 域名绑定"></a>4. 域名绑定</h1><h2 id="4-1-域名购买"><a href="#4-1-域名购买" class="headerlink" title="4.1 域名购买"></a>4.1 域名购买</h2><p>这里域名选择阿里云， 域名购买方式可自行百度</p><h2 id="4-2-域名解析"><a href="#4-2-域名解析" class="headerlink" title="4.2 域名解析"></a>4.2 域名解析</h2><p>域名购买后需解析，解析步骤及绑定github参考: <a href="https://www.cnblogs.com/yz0812/p/10392711.html">hexo绑定个人域名</a></p><p>具体解析记录可参考下面阿里云域名解析记录截图:<br><img src="https://i-blog.csdnimg.cn/direct/ae01ca2a1ec04d35a93e250dd7d3f1fd.png" alt="阿里云域名解析记录"></p><h1 id="5-使用域名访问博客"><a href="#5-使用域名访问博客" class="headerlink" title="5.使用域名访问博客"></a>5.使用域名访问博客</h1><p>上述步骤完成后即可通过域名方式博客<br><img src="https://i-blog.csdnimg.cn/direct/017782a0711c4aa487a59ff2cb177d5c.png" alt="使用域名访问博客"></p><h1 id="6-图床"><a href="#6-图床" class="headerlink" title="6.图床"></a>6.图床</h1><p>基于Gitee + Picgo</p><h2 id="6-1-下载Picgo"><a href="#6-1-下载Picgo" class="headerlink" title="6.1 下载Picgo"></a>6.1 下载Picgo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/Molunerfinn/PicGo/releases<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214016392.png" alt="下载Picgo"></p><h2 id="6-2-配置Picgo"><a href="#6-2-配置Picgo" class="headerlink" title="6.2 配置Picgo"></a>6.2 配置Picgo</h2><h3 id="6-1-gitee新建仓库"><a href="#6-1-gitee新建仓库" class="headerlink" title="6.1 gitee新建仓库"></a>6.1 gitee新建仓库</h3><h3 id="6-2-生成Gitee令牌"><a href="#6-2-生成Gitee令牌" class="headerlink" title="6.2 生成Gitee令牌"></a>6.2 生成Gitee令牌</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214302660.png" alt="生成Gitee令牌"><br>进入设置 –&gt; 点击私人令牌 –&gt; 点击生成新令牌</p><h3 id="6-3-Picgo安装gitee插件"><a href="#6-3-Picgo安装gitee插件" class="headerlink" title="6.3 Picgo安装gitee插件"></a>6.3 Picgo安装gitee插件</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214356514.png" alt="Picgo安装gitee插件"></p><h3 id="6-4-配置Picgo图床设置"><a href="#6-4-配置Picgo图床设置" class="headerlink" title="6.4 配置Picgo图床设置"></a>6.4 配置Picgo图床设置</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214523988.png" alt="配置Picgo图床设置"></p><p>更详细内容参考：<a href="https://blog.csdn.net/m0_69326428/article/details/147326688">Hexo+Github+gitee图床零成本搭建自己的专属博客</a></p><h1 id="7-其他问题"><a href="#7-其他问题" class="headerlink" title="7.其他问题"></a>7.其他问题</h1><h2 id="7-1-markdown图片失效问题"><a href="#7-1-markdown图片失效问题" class="headerlink" title="7.1 markdown图片失效问题"></a>7.1 markdown图片失效问题</h2><p>有种原因是图床存在防盗链，会报403禁止访问，此种问题解决方案可参考: <a href="https://juejin.cn/post/7368276508136505407">外链图片不显示</a></p><h2 id="7-2-GitHub配置自定义域名新推送失效问题"><a href="#7-2-GitHub配置自定义域名新推送失效问题" class="headerlink" title="7.2 GitHub配置自定义域名新推送失效问题"></a>7.2 GitHub配置自定义域名新推送失效问题</h2><p>域名绑定后已经能通过个人域名访问托管在github的博客了，但存在一个问题,就是每次hexo d重新部署后,配置的 GitHub Pages 自定义域名消失<br>解决方案也很简单就在<code>source</code> 目录下新建一个CNAME文件，将个人域名填进去即可，可参考: <a href="https://cloud.tencent.com/developer/article/2446582">为HEXO绑定自己的域名</a></p>]]></content>
    
    
    <categories>
      
      <category>造轮子-工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
