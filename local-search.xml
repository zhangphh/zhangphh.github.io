<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HighWaterMark与副本同步机制</title>
    <link href="/2025/04/12/HighWaterMark%E4%B8%8E%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/12/HighWaterMark%E4%B8%8E%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>0.11版本之前依赖于HW实现副本同步备份，0.11之后通过Leader epoch实现副本同步备份。</p><p>两个概念：</p><ul><li>LEO：log end offset，日志末端位移，记录了该副本底层日志下一条消息应存放的位置。</li><li>HW，高水位值，小于等于HW的消息是被认为已经备份的。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/81967a72a1b29543c125782cf7726a93.png" alt="在这里插入图片描述"><br>[0, 7]的消息是已经完全备份，[8, 15)的数据为尚未完全备份的。</p><p>kafka中所有的副本都保有自己的HW值和LEO值，但leader副本中还保存有其他副本的HW值和LEO值，如下图：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f4d5788ec0d46fdd4e37014fab0c8774.png" alt="在这里插入图片描述"><br>leader中保存的副本的HW值和LEO值得作用是用来更新leader副本的HW值。</p><h3 id="1、更新HW值的时机"><a href="#1、更新HW值的时机" class="headerlink" title="1、更新HW值的时机"></a>1、更新HW值的时机</h3><ul><li>follower副本：follower副本会在更新LEO值之后尝试更新HW值。</li><li>leader副本：<ul><li>当某个follower副本成为leader副本时；</li><li>broker崩溃导致副本被踢出ISR</li><li>producer向leader副本写消息时，由于LEO会被更改，因此会检查下HW是否需要更新；</li><li>leader处理follower的fetch请求时，首先会从log取数据，然后会尝试更新HW值</li></ul></li></ul><h4 id="1-1、leader副本更新HW"><a href="#1-1、leader副本更新HW" class="headerlink" title="1.1、leader副本更新HW"></a>1.1、leader副本更新HW</h4><p>处理生产者请求的逻辑：</p><ul><li>写入消息到本次磁盘</li><li>更新分区高水位<ul><li>获取leader副本所在broker端保存的所有远程副本LEO值(LEO-0, LEO-1,… … LEO-n)</li><li>获取leader副本高水位值，currentHW</li><li>更新currentHW&#x3D;max{currentHW，min(LEO-1,LEO-2,…..,LEO-n)}</li></ul></li></ul><p>处理follower副本拉取消息的处理逻辑：</p><ul><li>读取磁盘或页缓存中的数据</li><li>使用follower副本发送请求中位移值更新leader副本LEO值</li><li>更新分区高水位值，具体步骤与处理生产者请求的步骤相同</li></ul><h4 id="1-2、follower副本更新HW"><a href="#1-2、follower副本更新HW" class="headerlink" title="1.2、follower副本更新HW"></a>1.2、follower副本更新HW</h4><ul><li>写入消息到log文件</li><li>更新LEO值</li><li>更新高水位<ul><li>获取leader的高水位值：currentHW</li><li>获取步骤2刚才更新的LEO值，currentLEO</li><li>更新高水位值，min(currnetHW，currentLEO)</li></ul></li></ul><h3 id="2、副本同步机制"><a href="#2、副本同步机制" class="headerlink" title="2、副本同步机制"></a>2、副本同步机制</h3><p>当生产者生产一条消息，leader和follower副本高水位更新如下：<br>初始状态时，所有的值都为0<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b62f8534d600a14918440cb1c530f288.png" alt="在这里插入图片描述"><br>生产者发送一条消息后<br><img src="https://i-blog.csdnimg.cn/blog_migrate/05e32dff036cb45921ac76eba29d47ef.png" alt="在这里插入图片描述"><br>当leader副本将消息写入磁盘后LEO值变为1<br>follower再次从leader拉取消息，有消息拉取到，则状态进一步更新<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cf3ba65f9873bad0f7af39b723df6e9c.png" alt="在这里插入图片描述"><br>可以看到此时的副本LEO也被更新为1，但是leader副本和follower副本的HW仍然没有更新，这会在下一次follower的fetch请求时更新。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3a3ad359c94a3afcfda3b7999ae039f0.png" alt="在这里插入图片描述"><br>在新一轮的拉取中，由于位移值时0的消息已经拉取成功，则本次拉取会拉去位移值为1的消息，leader副本接收到请求后，会将remote LEO值更新为1，然后更新HW值为1，将更新后的HW值发送到follower，follower将HW值更新为1，致辞一个完整的同步过程完成。</p><p>上述的拉取流程可以看到kafka使用HW来决定副本备份的进度，而HW值的更新需要新一轮的Fetch请求才能实现，这种设计是有问题的，可能会引起备份数据丢失和备份数据不一致的问题。</p><h3 id="3、Leader-epoch"><a href="#3、Leader-epoch" class="headerlink" title="3、Leader epoch"></a>3、Leader epoch</h3><p><strong>备份数据丢失的问题</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/55b62c8f01eae9895e824f153a220ede.png" alt="在这里插入图片描述"><br>当生产者发送两条消息leader副本都完成落盘，而且follower副本B的HW已经更新为1，在第二条消息的同步时，fetch请求的响应失败，则B的HW就不会被更新到2，如果此时B重启，则B在重启后会重新加载之前的HW值，也就是1，此时副本B会做日志截断把2的消息删除，并调整LEO为1。<br>B会向A的leader副本发出同步消息的fetch请求，如果此时A恰好宕机，则B升级为leader，而当A重启回来后也会执行日志截断，将HW调整回1与B相同。这样，位移&#x3D;1的消息就从两个副本的log中被删除，即永远地丢失了。</p><p> <strong>备份数据不一致问题</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42e23e782194bf9fac4b94a667a5694b.png" alt="在这里插入图片描述"><br>A为leader，B为follower，B的HW只更新到1，此时A、B同事宕机，但是B先恢复，此时B为leader，在A恢复之前又向B写入了新的消息2，此时B的HW为2，此时A恢复，A的HW与B的HW相等，不会出现日志截断，之后会正常的执行下去，但是副本A与leader副本B数据存在不一致的地方。</p><p>针对上述的两个问题，kafka 0.11版本对此进行了优化，采用leader epoch技术来解决上述问题。</p><p>epoch，单调递增的版本号，每当副本领导权发生改变时都会增加该版本号，小版本号的leader被认为是过期的leader，不能再行使leader的权力。它其实是一对值，即(epoch, offset)，offset为该epoch版本对应的leader写入的第一条消息的位移。<br>(0, 0)<br>(1, 120)<br>则表示第一个leader从位移0开始写入消息；共写了120条[0, 119]；而第二个leader版本号是1，从位移120处开始写入消息.</p><p>​​leader broker中会保存这样的一个缓存，并定期地写入到一个checkpoint文件中。</p><p>当leader写底层log时它会尝试更新整个缓存——如果这个leader首次写消息，则会在缓存中增加一个条目；否则就不做更新。而每次副本重新成为leader时会查询这部分缓存，获取出对应leader版本的位移，这就不会发生数据不一致和丢失的情况。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d9674df658e29af294c4db5726d1259b.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/d6ab5858e323e58a10d99e5b9cdab2f3.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka日志存储</title>
    <link href="/2025/04/12/kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/"/>
    <url>/2025/04/12/kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>kafka中的topic是逻辑上的概念，而真正存储消息的是分区，更具体点来说是分区中的segment，每个分区可分为多个segment，存储的消息称为日志。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/debb6a7abff89eaa5406fe825a7d7c96.png" alt="在这里插入图片描述"></p><h3 id="1、LogSegment"><a href="#1、LogSegment" class="headerlink" title="1、LogSegment"></a>1、LogSegment</h3><p>一个partition分区拥有多个logsegment，kafka日志追加是顺序写入的，把分区分为多个日志段可减小日志文件的大小，在进行日志删除和数据读取的时候也可以快速定位。需要注意的是只有活跃的日志段拥有文件的写入权限，其余的都只有读取权限。</p><p>日志文件存在多个后缀的文件，重点需要关注的有.index，.timeindex，.log三个。每个LogSegment都有一个基准偏移量，用于表示当前LogSegment文件的第一条消息的offset，固定长度是20位数字，长度未达到用0填充，索引文件和日志文件都由此命名规则命名如000000000000000000100.index、00000000000000000100.timeindex、00000000000000000100.log。</p><h3 id="2、日志格式演变"><a href="#2、日志格式演变" class="headerlink" title="2、日志格式演变"></a>2、日志格式演变</h3><h4 id="2-1、v0版本"><a href="#2-1、v0版本" class="headerlink" title="2.1、v0版本"></a>2.1、v0版本</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e67e55f0e3b41e3f180133a27bf265aa.png" alt="在这里插入图片描述"></p><p>上图RECORD部分即为v0版本的消息格式，在0.10.0版本之前都是采用的此种消息格式。LOG_OVERHEAD和RECORD一期来描述一条消息，与消息对应的是消息集的概念，消息集中包含多条消息，消息集不仅是存储于磁盘以及在网络上传输(Produce和Fetch)的基本形式，而且是kafka中压缩的基本单元。</p><ul><li>crc32， 4字节，crc32校验值，校验范围从magic到value</li><li>magic，1字节，消息格式版本号，此版本magic值为0</li><li>attributes，1字节，表示消息的属性，第三位表示消息的压缩类型，0为NONE，1为GZIP，2为SNAPPY，3为LZ4，其余位保留</li><li>key length，消息的key的长度，如果值为-1，表示此消息无key，即key&#x3D;null</li><li>key，可选，如果没有key则无此字段</li><li>value length，实际消息体的长度，如果为-1，表示消息为空</li><li>value，消息体，可以为空。</li></ul><p>v0版本的消息最小长度为crc32+magic+attributes+key length+value length &#x3D; 4+1+1+4+4&#x3D;14B，当消息的长度小于这个值，则可认为这条消息是破损的而不被接受。</p><h4 id="2-2、v1版本"><a href="#2-2、v1版本" class="headerlink" title="2.2、v1版本"></a>2.2、v1版本</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2221a3a5ae018c999bc978bb3977d16d.png" alt="在这里插入图片描述"><br>v1版本的magic值为1，v1版本的消息最小长度为14+8&#x3D;22B，kafka从0.10.0版本开始到0.11.0之前使用的消息格式都是v1</p><p><strong>消息压缩</strong></p><p>kafka发送消息并不是一条一条发送的，而是通过消息集(message set)批量发送的，为了提高性能，kafka支持压缩消息的功能，具体来说就是压缩消息集。压缩解压过程是：生产者发送压缩消息集，broker端保存压缩的消息集，消费者解压消息集进行消费。这样就能减少网络IO消耗提升性能。</p><p>生产者可以通过配置compression.type来开启压缩功能，支持的压缩算法有GZIP、LZ4、SNAPPY三种。压缩消息时，将整个消息集进行压缩作为一个内层消息，这个内层消息作为外层消息的value，并将原来消息集最大的offset作为外层消息的offset，而内层消息的offset永远从0开始，如下图：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/eab94e41c101dc5b34b8172fd86b836d.png" alt="在这里插入图片描述"><br>对于压缩的情形，外层消息的timestamp设置为：</p><ul><li>如果timestamp类型是CreateTime，那么设置的是内层消息中最大的时间戳(the max timestamp of inner messages if CreateTime is used)</li><li>如果timestamp类型是LogAppendTime，那么设置的是kafka服务器当前的时间戳。</li></ul><p>内层消息的timestamp设置为：</p><ul><li>如果外层消息的timestamp类型是CreateTime，那么设置的是生产者创建消息时的时间戳</li><li>如果外层消息的timestamp类型是LogAppendTime，那么所有的内层消息时间戳都将被忽略</li></ul><h4 id="2-3、v2版本"><a href="#2-3、v2版本" class="headerlink" title="2.3、v2版本"></a>2.3、v2版本</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/74d9bec897b578809d5557eb976105b9.png" alt="在这里插入图片描述"></p><p>kafka从0.11.0版本开始使用v2版本的消息格式，v2版本引入了变长整型(Varints)和ZigZag编码，Varints是使用一个或多个字节来序列化整数的一种方法，数值越小，其所占用的字节数就越少。ZigZag编码以一种锯齿状的方式来回穿梭于正负整数之间，以使得带符号整数映射为无符号整数，这样可使得绝对值较小的负数仍享有较小的Varints编码值。</p><p>如果没有使用Varints编码，如v0和v1，当key length &#x3D; -1时，int类型的需要4个字节来保存，而使用Varints只需要一个字节，根据Varints的规则可以推导出0-63之间的数字占1个字节，64-8191之间的数字占2个字节，8192-1048575之间的数字占3个字节。而kafka broker的配置message.max.bytes的默认大小为1000012（Varints编码占3个字节），如果消息格式中与长度有关的字段采用Varints的编码的话，绝大多数情况下都会节省空间，而v2版本的消息格式也正是这样做的。</p><p>v2版本引入了新的概念Record Batch，而摒弃了先前的Message Set，在消息压缩的情形下，Record Batch Header部分（从first offset到records count字段）是不被压缩的，而被压缩的是records字段中的所有内容。</p><p>关于Record字段描述：</p><ul><li>length：消息总长度</li><li>attributes：弃用，但是还是在消息格式中占据1B的大小，以备未来的格式扩展</li><li>timestamp delta：时间戳增量。通常一个timestamp需要占用8个字节，如果像这里保存与RecordBatch的其实时间戳的差值的话可以进一步的节省占用的字节数</li><li>offset delta：位移增量。保存与RecordBatch起始位移的差值，可以节省占用的字节数</li><li>headers：这个字段用来支持应用级别的扩展，而不需要像v0和v1版本一样不得不将一些应用级别的属性值嵌入在消息体里面。Header的格式如上图最有，包含key和value，一个Record里面可以包含0至多个Header</li></ul><p>RecordBatch字段描述：</p><ul><li>first offset：表示当前RecordBatch的起始位移</li><li>length：计算partition leader epoch到headers之间的长度</li><li>partition leader epoch：用来确保数据可靠性</li><li>magic：消息格式的版本号，对于v2版本而言，magic等于2</li><li>attributes，消息属性，注意这里占用了两个字节。低3位表示压缩格式，可以参考v0和v1；第4位表示时间戳类型；第5位表示此RecordBatch是否处于事务中，0表示非事务，1表示事务。第6位表示是否是Control消息，0表示非Control消息，而1表示是Control消息，Control消息用来支持事务功能</li><li>last offset delta：RecordBatch中最后一个Record的offset与first offset的差值。主要被broker用来确认RecordBatch中Records的组装正确性</li><li>first timestamp：RecordBatch中第一条Record的时间戳</li><li>max timestamp：RecordBatch中最大的时间戳，一般情况下是指最后一个Record的时间戳，和last offset delta的作用一样，用来确保消息组装的正确性</li><li>producer id：用来支持幂等性</li><li>producer epoch：和producer id一样，用来支持幂等性</li><li>first sequence：和producer id、producer epoch一样，用来支持幂等性</li><li>records count：RecordBatch中Record的个数</li></ul><h3 id="3、日志索引"><a href="#3、日志索引" class="headerlink" title="3、日志索引"></a>3、日志索引</h3><p>kafka的日志分段文件包括了两个索引文件：偏移量索引文件和时间戳索引文件。其中偏移量索引文件是为了建立消息偏移量与物理地址之间的映射关系，时间戳索引文件则是用来建立时间戳与偏移量的映射关系。索引文件都是以稀疏索引的方式构建的。</p><p>偏移量索引文件是单调递增的，查询时通过二分查找的方式快速定位到小于制定偏移量的最大偏移量，然后根据对应的物理地址找到对应的消息。时间索引文件中的时间戳也是单调递增的，查询时先定位到小于指定时间的最大时间戳，根据此时间戳对应的偏移量去偏移量索引文件中找到对应的消息。</p><h4 id="3-1、偏移量索引"><a href="#3-1、偏移量索引" class="headerlink" title="3.1、偏移量索引"></a>3.1、偏移量索引</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0396f436d8ebfc812195bf6f6ee41388.png" alt="在这里插入图片描述"><br>偏移量索引文件中的每个索引占8个字节，分为两部分</p><ul><li>relative offset，相对偏移量，占4字节，表示消息相对于baseOffsset的偏移量，这个baseOffset即为此日志文件的名</li><li>position，物理地址，占4字节，表示消息在分段日志文件中的物理地址</li></ul><p>使用偏移量索引查找消息过程：</p><ul><li>因为偏移量索引文件文件名是baseOffset，所以可以使用二分法快速定位到指定的偏移量索引文件</li><li>找到索引文件后，在索引文件中利用二分法找到特定的索引项(小于当前偏移量的最大偏移量)，进而找到此索引相对应的物理地址，最后顺序查找出对应偏移量的消息。</li></ul><h4 id="3-2、时间戳索引"><a href="#3-2、时间戳索引" class="headerlink" title="3.2、时间戳索引"></a>3.2、时间戳索引</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0de3ff6fe97f7ad1d8c5ed7265602ee9.png" alt="在这里插入图片描述"><br>时间戳索引占12个字节，分为两部分</p><ul><li>timestamp，当前日志分段的最大时间戳</li><li>relative offset，时间戳对应的消息相对偏移量</li></ul><p>根据时间戳查找对应消息过程</p><ul><li>根据时间戳找到每个日志分段的文件中最大的时间戳逐一比较，定位到时间戳索引文件。由于时间戳索引文件也是根据baseOffset命名的，所以这一步无法使用二分法</li><li>在时间戳索引文件中使用二分法定位到时间戳索引项</li><li>根据时间戳索引项对应的偏移量使用偏移量索引找出对应的消息。</li></ul><h4 id="3-3、二分查找算法"><a href="#3-3、二分查找算法" class="headerlink" title="3.3、二分查找算法"></a>3.3、二分查找算法</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a161b69b21b901e965b06926f4ad16d7.png" alt="在这里插入图片描述"><br>kafka写入索引文件的方式是在文件末尾追加写入的，而几乎所有的索引查询都发生在索引尾部。kafka原本的二分查找并没有考虑到缓存的问题，可能会导致一些不必要的缺页中断，kafka线程会被阻塞等待索引项从磁盘读取并放入页缓存中。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6bf819bee0ee6649c7520a07805ced71.png" alt="在这里插入图片描述"><br>上图kafka的某个索引占用了操作系统页缓存的13个页，如果待查找的位移值在最后一个页上则二分查找会一次读取编号为0、6、9、11、12的页。</p><p>通常情况下，一个页会存放成百上千的索引项，锁着索引文件被不断写入，page 12被不断地填充新的索引项。如果此时索引查询方都来自ISR副本集合或Lag很小的消费者，那么这些查询大都集中在对page 12 的查询上，此时page 0、6、9、11、12页一定或被经常性的访问，所以要把他们保存在页缓存上。</p><p>当page 12 空间被使用完了之后，会出现新的页，记为page 13，此时要查询最新的索引项所使用的页缓存为page 0、7、10、12、13，由于page 7和10很长时间没有使用过了，所以很可能会不在页缓存中，因此会出现缺页异常需要从磁盘中加载进页缓存中，这个过程可能会造成几毫秒至一秒的延迟。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d53df746ab46e50294e3376bf56574c.png" alt="在这里插入图片描述"><br>基于上述问题，提出了缓存友好的二分算法，整体思路就是将所有索引项分为两个部分：热区和冷区。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/135119f0b928cb6b66d4b32b26c058b1.png" alt="在这里插入图片描述"><br>这个改进版算法的最大的优点在于查询最热那部分数据所遍历的page永远是固定的，因此大概率在页缓存中，从而避免无意义的缺页异常。</p><p>改进版二分查找算法流程：</p><ul><li>如果索引为空，直接返回&lt;-1, -1&gt;对；</li><li>确认热区第一个索引项位于哪个槽，_warmEntries参数就是所谓的分割线，目前固定为8192字节处，如果是OffsetIndex，_warmEntries &#x3D; 8192 &#x2F; 8 &#x3D; 1024，即第1024个槽，如果是TimeIndex，_warmEntries &#x3D; 8192 &#x2F; 12 &#x3D; 682，即第682个槽；</li><li>判断target位移在热区还是在冷区；</li><li>确保target位移值不能小于当前最小位移值；</li><li>如果在冷区，搜索冷区。</li></ul><p>通过索引查找消息复杂度为 O(log2n)+O(m)， n是索引文件里索引的个数，m为稀疏程度。</p><h3 id="4、日志清理之Log-Deletion"><a href="#4、日志清理之Log-Deletion" class="headerlink" title="4、日志清理之Log Deletion"></a>4、日志清理之Log Deletion</h3><p>可以通过设置broker端的参数log.cleanup.policy值来设置日志清理策略，此参数默认值为delete，当然也可设置为compact，如果将log.cleanup.policy设置为compact，还需要将log.cleanup.enable(默认为true)设置为true。除此之外，log.cleanup.policy的值还可设置为“delete,compact”同时支持日志删除和日志压缩。</p><p>kafka日志管理器中有一个专门的日志删除任务来周期性检测和删除不符合保留条件的日志分段文件，这个周期可以通过broker端的参数log.retention.check.interval.ms来配置，默认为300000，也即是5分钟检测一次。当前的日志分段保留策略有三种：基于时间、基于日志大小和基于日志起始偏移量的保留策略。</p><h4 id="4-1、基于时间"><a href="#4-1、基于时间" class="headerlink" title="4.1、基于时间"></a>4.1、基于时间</h4><p>基于此策略的日志删除会检查当前日志文件中是否保留有超过了设定的阈值(retentionMs)来寻找可删除的日志分段文件集合deletableSegments。retentionMs可以通过broker端参数log.retention.hours、log.retention.minutes、log.retention.ms来配置，其中ms优先级最高，minute次之，hour最低，默认情况下配置了hour为168，也就是默认情况下日志分段文件会被保留7天。</p><p>查找过期的日志分段文件，并不是简单的根据日志分段的最近修改时间lastModifyTime来计算，而是根据日志分段中最大的时间戳largestTimeStamp来计算。因为日志分段的lastModifyTime可以被修改，如分区副本被重新分配。获取largestTimeStamp要先查询该日志分段对应的时间戳索引文件，查找时间戳索引文件的最后一条索引项，若最后一条索引项的时间戳字段值大于0，则取其值，否则设置为lastModifyTime</p><p>如果此分区所有的日志分段文件都被标记为删除，此时会先切分出一个新的日志分段作为activeSegment勇于接受新消息的写入，然后在执行之前的删除操作。</p><p>日志分段删除流程如下：</p><ul><li>从日志对象文件中所维护的跳表中移除待删除的日志分段，以确保没有线程对这些日志分段进行读取操作</li><li>将待删除的日志分段文件加上“.delete”后缀，包括其对应的索引文件</li><li>最后交由一个以”delete-file”命名的延迟任务来删除这些“.delete”为后缀的文件，这个延迟任务可以通过file.delete.delay.ms来设置，默认为60000，即1min</li></ul><h4 id="4-2、基于日志大小"><a href="#4-2、基于日志大小" class="headerlink" title="4.2、基于日志大小"></a>4.2、基于日志大小</h4><p>broker端可以设置log.retention.bytes的值来设置一个分区日志文件的大小，默认为-1表示无穷大，这个值设置的是总的日志分段大小，而不是一个日志分段。</p><p>此策略的删除过程首先会计算需要删除的日志大小，然后从日志文件中的第一个日志分段开始进行查找可删除的日志分段的文件集合deletableSegments，然后删除，删除操作如4.1</p><h4 id="4-3、基于日志起始偏移量"><a href="#4-3、基于日志起始偏移量" class="headerlink" title="4.3、基于日志起始偏移量"></a>4.3、基于日志起始偏移量</h4><p>基于日志起始偏移量的删除策略的判断依据是某日志分段的下一个日志分段的起始偏移量baseOffset是否小于等于logStartOffset，若是则可以删除此日志分段。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef5c42502912560929e6098066cff9eb.png" alt="在这里插入图片描述"><br>如上图，此时会删除前两个日志分段</p><h3 id="5、日志清理之Log-Compaction"><a href="#5、日志清理之Log-Compaction" class="headerlink" title="5、日志清理之Log Compaction"></a>5、日志清理之Log Compaction</h3><p>Log Compaction是日志压紧、压实，相同key的不同value值只保留最后一个版本，也就是kafka定期将相同key的消息进行合并，只保留最新的value值。</p><h3 id="6、切分文件的时机"><a href="#6、切分文件的时机" class="headerlink" title="6、切分文件的时机"></a>6、切分文件的时机</h3><p>日志文件和索引文件都会存在多个文件，组成多个SegmentLog，其切分规则如下：</p><ul><li>当前日志分段文件的大小超过了broker端参数log.segment.bytes配置的值，默认值为1G</li><li>当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于log.roll.ms或log.roll.hours参数配置的值，默认只配置了hour为186，即7天</li><li>偏移量索引文件或时间戳索引文件的大小达到了broker端参数log.index.size.max.bytes配置的值，默认为10MB</li><li>追加消息的偏移量与当前日志分段的偏移量之间的差值大于Integer.MAX_VALUE(4字节)，即要追加的消息的偏移量不能转变为相对偏移量。</li></ul><h3 id="7、零拷贝"><a href="#7、零拷贝" class="headerlink" title="7、零拷贝"></a>7、零拷贝</h3><p>kafka速度快的原因：</p><ul><li>多个partition可被并行读取</li><li>顺序写磁盘</li><li>”零拷贝“</li></ul><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/635291df1b1c111292faa01dc16f8d71.png" alt="在这里插入图片描述"><br>DMA(Direct Memory Access)：直接存储器访问，一种可让某些硬件子系统去直接访问系统主内存，而不用依赖CPU的计算机系统的功能。也就是跳过CPU，直接访问主内存。传统的内存访问都需要通过CPU的调度来完成，DMA技术出现后使系统 CPU 从实际的 I&#x2F;O 数据传输过程中摆脱出来，从而大大提高系统的吞吐率。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9568580e5cd939e0ef3212712a5405c3.png" alt="在这里插入图片描述"><br>很多硬件都支持DMA，其中就包括网卡。实际IO读写，需要进行IO中断，需要CPU响应中断(带来上下文切换)，尽管后来引入DMA来接管CPU的中断请求，但四次copy是存在“不必要的拷贝”的。在这两次CPU拷贝中，应用缓存除了缓存数据并将其传输回socket缓冲区之外并没有实际做什么，所以这两步是可以做优化的，传统IO方式，会注意到实际上并不需要第二个和第三个数据副本。</p><p>说明：这种优化掉两次cpu拷贝的场景，是在读取磁盘的文件后不需要进一步的处理，直接通过网络发送出去，kafka落盘操作就是这种情况，只是把数据写入磁盘，而不对数据进行操作。如果读取到的磁盘数据需要应用程序进一步处理的话，则必须要经过第二次和第三次拷贝，让数据在应用缓冲区处理。</p><p><strong>Memory Mapped Files</strong>，简称为mmap，他的作用就是将磁盘文件映射到内存，通过修改内存就能修改磁盘文件。实现方式就是通过页表的方式实现文件到内存的映射，映射完成后对物理内存的操作会被同步到磁盘上(在合适的时候有操作系统完成)。</p><p>通过mmap，进程想读写硬盘一样读写内存，这个内存是虚拟内存，所以不必担心实际内存的大小，因为有虚拟内存兜底。使用这种方式I&#x2F;O提升很大，省去了内核空间到用户空间复制的开销。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/436cbd16d0db0a69dfe7fbdf6ce631e3.png" alt="在这里插入图片描述"></p><p>mmap实现的”零拷贝”将上下文的切换次数从4次减少为了两次，拷贝次数从4次降低到了3次。</p><p><strong>sendfile函数</strong>，Linux从2.1开始引入此函数用于将文件通过socket发送，刚开始时和mmap没有区别，Linux2.4做了进一步的优化。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dfcef8b66138a59b6848ef465a2ad119.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka消费者</title>
    <link href="/2025/04/12/kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <url>/2025/04/12/kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h3 id="1、消费者与消费组"><a href="#1、消费者与消费组" class="headerlink" title="1、消费者与消费组"></a>1、消费者与消费组</h3><p>消费组是kafka提供的可扩展且具有容错性的消费者机制，同一个消费组的消费者共有一个groupId，一个分区只能被同一个消费组中的一个消费者消费。</p><p>消费组解决了什么问题：</p><ul><li>消费模式灵活，假设三个消费者订阅了一个主题，当使用三个消费组时，每个消费组有一个消费者，利用分区在不同消费组间共享的特性，就实现了发布订阅(广播)模式；当把这三个消费者放在一个消费组中时利用分区在消费组成员间互斥的特性实现了队列(单播)模式；</li><li>故障容灾，引进了消费组的概念，当消费组中的某个消费者出现故障时消费组会执行在平衡操作。</li></ul><h3 id="2、push-or-pull"><a href="#2、push-or-pull" class="headerlink" title="2、push or pull"></a>2、push or pull</h3><p>kafka的消费者采用的是pull模式主动从broker拉取数据，这种主动拉的模式可以让消费者根据自己的消费速率拉消息。如果采用push模式的话，不同消费者消费速率可能不同，无法设置一个使用所有消费者的push消息大小，push模式也可能会导致消费者消息来不及消费而积压。</p><p>但pull模式也有缺点，当broker中没有消息时，消费者频繁的pull是没有任何意义的，但kafka在消费者每次拉的时候带有一个参数，当消费者拉到的数据为空时，会等待这个时间之后再去pull。</p><p>消费者在拉消息的时候和生产者生产消息的batch机制有相似的设置，可以通过设置下面两个参数减少消费者与broker之间的频繁交互</p><p>fetch.min.byte：消费者从broker获取数据的最小字节数，如果消息大小小于此值，则broker会等待有足够的数据时把它返回给消费者</p><p>fetch.max.wait.ms：默认500ms，如果消费者获取最小数据量的要求得不到满足，就会在等待最多该属性所设置的时间后获取到数据。</p><h3 id="3、offset提交"><a href="#3、offset提交" class="headerlink" title="3、offset提交"></a>3、offset提交</h3><p>消费者位移存储在kafka的内部的主题__consumer_offsets中，之前版本的位移存储在zookeeper中，老版本的Kafka会把位移信息保存在zk中，当Consumer重启后，自动从zk中读取位移信息。这种设计使Kafka Broker不需要保存位移数据，可减少Broker端需要持有的状态空间，有利于实现高伸缩性，但zk不适用于高频的写操作，这令zk集群性能严重下降，在新版本中将消费者的位移数据作为一条条普通的Kafka消息，提交至内部主题__consumer_offsets中保存。实现高持久性和高频写操作。</p><p>Consumer 需要为分配给它的每个分区提交各自的位移数据，提交位移一是表征消费者的消费进度，二是可以在当前消费者发生故障重启后能从之前提交的位移处接着消费，避免再从头开始消费。</p><h3 id="4、自动提交与手动提交"><a href="#4、自动提交与手动提交" class="headerlink" title="4、自动提交与手动提交"></a>4、自动提交与手动提交</h3><p>从消费者的角度来说位移提交分为自动提交和手动提交。</p><h4 id="4-1-自动提交"><a href="#4-1-自动提交" class="headerlink" title="4.1 自动提交"></a>4.1 自动提交</h4><p>自动提交设置enable.auto.commit的值为true，默认是5s自动提交一次。</p><p>在自动提交时，先提交上一批次拉取消息的位移，再处理下一批次，因此自动提交能保证消息不丢失，但是自动提交存在重复消费的可能。默认情况下5s提交一次，假如在上次为已提交后的第3s发生了rebalance，则消费者会从上一次提交位移的地方开始消费，则rebalance前的3s数据就会被再次消费。可以通过 auto.commit.interval.ms设置自动提交的间隔时间，但是减少时间只能是减少重复消费的时间窗口，而不能完全消除。</p><h4 id="4-2-手动异步提交"><a href="#4-2-手动异步提交" class="headerlink" title="4.2 手动异步提交"></a>4.2 手动异步提交</h4><p>手动提交并不能完去代替自动提交，手动提交是异步的，不存在重试机制，因为手动提交是异步的，重试时提交的位移可能已不是最新的位移了，因此重试没有意义。</p><p>对于常规性阶段性的手动提交可以使用异步和非异步的方式组合的方式，将两者结合，使用异步提交的方式避免程序阻塞，当consumer结束消费时同步提交。</p><p>备注：如果不发生重平衡使用自动提交的方式。</p><h3 id="5、重平衡"><a href="#5、重平衡" class="headerlink" title="5、重平衡"></a>5、重平衡</h3><h4 id="5-1-重平衡的时机"><a href="#5-1-重平衡的时机" class="headerlink" title="5.1 重平衡的时机"></a>5.1 重平衡的时机</h4><p>订阅的主题数发生变化，这种情况只有在业务调整时才会发生，要么不发生，要么不可避免；</p><ul><li>主题分区发生变化，在部署之前就要考虑集群的容量，以便确定好分区数，因此调整的次数也是有限的，在低峰时进行调整；</li><li>消费组成员的变化，消费组成员发生变化的情况有下面两种：<ul><li>消费者处理消息超时，即如果消费者处理消费的消息的时间超过了Kafka集群配置的 max.poll.interval.ms 的值，那么该消费者将会自动离组</li><li>心跳超时，如果消费者在指定的session.timeout.ms时间内没有汇报心跳，那么Kafka就会认为该消费已经dead了</li></ul></li></ul><p>因此消费端的消费者组成员变化一般都是由于异常引起的，所以其产生的 Rebalance 也是最难控制的。</p><p>重平衡过程是靠消费者端的心跳线程通知到其他消费者实例的，每当消费者向其 coordinator 汇报心跳的时候，如果这个时候 coordinator 决定开启 Rebalance ，那么 coordinator 会将REBALANCE_IN_PROGRESS封装到心跳的响应中，当消费者接收到这个REBALANCE_IN_PROGRESS，他就知道需要开启新的一轮 Rebalance 了,所以heartbeat.interval.ms除了是设置心跳的间隔时间，其实也意味着 Rebalance 感知速度，心跳越快，Rebalance 就能更快的被各个消费者感知。</p><h4 id="5-2-重平衡流程"><a href="#5-2-重平衡流程" class="headerlink" title="5.2 重平衡流程"></a>5.2 重平衡流程</h4><p>消费者端重平衡流程：</p><ul><li><p>加入组，组内成员加入组时会向协调者发送JoinGroup请求，将自己订阅的主题上报，协调者会从这些组员中选出一个leader consumer，协调者会把消费者组订阅信息封装进JoinGroup请求的响应体中，然后发给领导者，由领导者统一做出分配方案后。然后进入到下一步：发送SyncGroup请求；<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d0d9e3df8fbc3241dc9fb9a8d38855c2.png" alt="在这里插入图片描述"></p></li><li><p>Leader Consumer分配方案，这一步的主要目的是让协调者接收分配方案，然后统一以 SyncGroup 响应的方式分发给所有成员，这样组内所有成员就都知道自己该消费哪些分区了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8328ef21b98395b9d47864bf4ccff063.png" alt="在这里插入图片描述"><br>broker端的重平衡流程：</p></li><li><p>新成员加入组，当有新成员发送JoinGroup请求时，协调者会以心跳的方式通知之前的成员开启新一轮的重平衡</p></li><li><p>组成员主动离组</p></li><li><p>组成员崩溃离组</p></li><li><p>组成员提交位移</p></li></ul><h4 id="5-3-分区分配原则"><a href="#5-3-分区分配原则" class="headerlink" title="5.3 分区分配原则"></a>5.3 分区分配原则</h4><ul><li><p>Range，这种分配是基于每个主题的分区分配，如果主题的分区不能平均分配给组内每个消费者，那么对该主题，某些消费者会被分配到额外的分区，这种分配方式明显的一个问题是随着消费者订阅的Topic的数量的增加，不均衡的问题会越来越严重，可能会出现有的消费者分配很多分区，有的消费者分配较少的分区。</p></li><li><p>RoundRobin，RoundRobin是基于全部主题的分区来进行分配的，同时这种分配也是kafka默认的rebalance分区策略，<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7541d7ef7b0cc30cdfeda74fc8874185.png" alt="在这里插入图片描述"><br>发现C2承担了4个分区的消费而C1订阅了T1，是不是把T1P1交给C1消费能更加的均衡呢</p></li><li><p>Sticky，目的是在执行一次新的分配时，能在上一次分配的结果的基础上，尽量少的调整分区分配的变动，节省因分区分配变化带来的开销。每一次分配变更相对上一次分配做最少的变动。其目标有两点：</p><ul><li>分区的分配尽量的均衡。</li><li>每一次重分配的结果尽量与上一次分配结果保持一致。</li></ul></li></ul><p>当这两个目标发生冲突时，优先保证第一个目标。第一个目标是每个分配算法都尽量尝试去完成的，而第二个目标才真正体现出Sticky特性的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka生产者</title>
    <link href="/2025/04/12/kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <url>/2025/04/12/kafka%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、生产者"><a href="#1、生产者" class="headerlink" title="1、生产者"></a>1、生产者</h3><h4 id="1-1、batch"><a href="#1-1、batch" class="headerlink" title="1.1、batch"></a>1.1、batch</h4><p>生产者在发送消息时不会将每一条消息都单独发送到broker中，而是采取了批量发送以此减少网络请求次数和磁盘IO次数，消息会先发到缓冲区，这个缓冲区的大小是可配置的，在缓冲区中将消息进行分批，缓冲区大小默认为32M，当缓冲区使用完后消息的追加将会被阻塞直到有空闲的区域。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f8179af0773f3afc3ee5a570d7f6eda8.png" alt="在这里插入图片描述"><br><strong>batch.size</strong>:  此参数配置发送到同一分区的批量提交的数据的大小，默认为16k，当消息积压到这个值就会批量发送，增大batch可以增加吞吐量，减小batch客降低消息延迟。</p><p><strong>linger.ms</strong>：但生产者也并不是非要等到大小挤压到一个批次大小才会发送，此参数就是等待一个批次大小的时间，linger.ms参数控制batch最大的空闲时间，超过该时间的batch也会被发送到broker端。</p><p>说明：当这两个参数同时设置的时候，只要两个条件中满足一个就会发送。比如说batch.size设置16kb，linger.ms设置50ms，那么当消息积压达到16kb就会发送，如果没有到达16kb，那么在第一个消息到来之后的50ms之后消息将会发送。</p><h3 id="2、同步发送与异步发送"><a href="#2、同步发送与异步发送" class="headerlink" title="2、同步发送与异步发送"></a>2、同步发送与异步发送</h3><h4 id="2-1、同步方式"><a href="#2-1、同步方式" class="headerlink" title="2.1、同步方式"></a>2.1、同步方式</h4><p>同步方式发送消息必需要等结果返回。</p><h4 id="2-2、异步方式"><a href="#2-2、异步方式" class="headerlink" title="2.2、异步方式"></a>2.2、异步方式</h4><p>生产者将消息发送给kafka之后不会等待结果返回，调用者可以继续其他的工作。对sarama函数库来说异步发送需要注意的地方就是Return.Successes的设置，如果没有将Return.Successes设置为true，而且消息发送的过程中没有出现错误，则在select块中要设置default，否则会挂住，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(asyncProducer sarama.AsyncProducer)</span></span> &#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> success := &lt;-asyncProducer.Successes():<br>log.Infof(<span class="hljs-string">&quot;Produced message successes: [%s]\n&quot;</span>, success.Value)<br><span class="hljs-keyword">case</span> err := &lt;-asyncProducer.Errors():<br>log.Errorf(<span class="hljs-string">&quot;Produced message failure: &quot;</span>, err)<br><span class="hljs-keyword">default</span>:<br>log.Infof(<span class="hljs-string">&quot;Produced messsage default&quot;</span>)<br><br>&#125;<br>&#125;<br>&#125;(asyncProducer)<br></code></pre></td></tr></table></figure><p>因为如果没有default语句，则上面的两个case都不会匹配到，就会挂在这。如果不写default语句，则Return.Successes要置为true。</p><p>此外还需考虑的一个问题就是当设置了Return.Successes的值为true，但是没有使用producer.Successes()，也会出现为题，因为随着生产消息的成功，success的chan会被写满(kafka内部控制大小)，写满的结果就是导致后面的success结果丢失，并且会导致producer不可用。</p><p>所以config.Producer.Return.Successes &#x3D; true和操作&lt;-producer.Successes()必须配套使用；配置成true，那么就要去读取Successes，如果配置成false，则不能去读取Successes。</p><h3 id="3、分区策略"><a href="#3、分区策略" class="headerlink" title="3、分区策略"></a>3、分区策略</h3><p>指明分区序号，会直接发送到被指定的分区中<br>没有指明分区序号，但消息存在key值，则会将key的hash值与topic的分区数取余得到分区序号<br>即没有partition序号，有没有key值的情况会在第一次调用时随机生成一个小于分区数的值，后面每次调用都会加一并与分区数取余作为分区号，此种方式即为round-robin方式</p><h3 id="4、ack应答机制"><a href="#4、ack应答机制" class="headerlink" title="4、ack应答机制"></a>4、ack应答机制</h3><p>ISR(in-sync replica set)<br>对于leader分区，它维护了一个ISR集合，记录了和leader保持同步的foller集合，当ISR中的follower完成同步之后会向leader发送ACK。当follower长时间未向leader同步消息，此follower会被踢出ISR，该函数阈值可有replica.lag.time.max.ms(broker)参数设定，当leader发生故障之后会被从ISR中移除，然后从剩下的ISR中选出一个作为leader。</p><h4 id="4-1、NoResponse-0"><a href="#4-1、NoResponse-0" class="headerlink" title="4.1、NoResponse (0)"></a>4.1、NoResponse (0)</h4><p>当ack设置为NoResponse时，producer不等待broker的ack，这一操作提供了一个最低的延迟，broker还没来的写入磁盘就返回，设置为此值延迟最低。</p><h4 id="4-2、WaitForLocal-1"><a href="#4-2、WaitForLocal-1" class="headerlink" title="4.2、WaitForLocal (1)"></a>4.2、WaitForLocal (1)</h4><p>ack设置为1时，会等待leader分区落盘成功后返回ack，如果leader落盘失败会重试，如果follower同步之前leader出现故障，数据将会丢失。</p><h4 id="4-3、WaitForAll-1"><a href="#4-3、WaitForAll-1" class="headerlink" title="4.3、WaitForAll (-1)"></a>4.3、WaitForAll (-1)</h4><p>ack设置为-1，表示所有的副本成功落盘后才返回ack，但是当所有的分区副本同步成功后在leader分区返回ack之前leader分区出现故障，则会导致producer重试，消息重复，可靠性最高。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chat聊天系统思考之二</title>
    <link href="/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%BA%8C/"/>
    <url>/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>考虑下面几个条件下如何提升kafka的消费速度</p><ul><li>消息要求严格有序，如chat聊天消息</li><li>业务处理速度慢，如处理一条数据需要100ms</li><li>分片不合理，如有的分区很闲，有的分区消息数量积压</li></ul><h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><h3 id="1、顺序问题"><a href="#1、顺序问题" class="headerlink" title="1、顺序问题"></a>1、顺序问题</h3><p>关于消息消费时存在先后顺序问题，在<a href="https://zhangphh-blogs.top/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80">chat聊天系统思考之一</a>中已经加以说明。具体实现大致为对同一会话、帖子Id等维度放入同一分区中，如使用Id % 分区数，如下图：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0cb3662ec2f302c8d847d7891ed96088.png" alt="kafka消费消息顺序"><br>上面的解决方案是将同一会话的消息发送至同一分区进行消费，但是但消费者的消费能力大概率是不够的，因此，需要并发处理，详见<br><a href="https://zhangphh-blogs.top/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80/">chat聊天系统思考之一</a><br><img src="https://i-blog.csdnimg.cn/blog_migrate/224d2429122b36f2f5eb27423dc29c90.png" alt="并发消费"><br><strong>注意</strong>：此时需要注意一个问题就是，当单个消费者消费分区，并将获取到的消息放入不同的队列中，此时还可能存在乱序问题，所以，可以考虑复用Id%队列数的方式，将同一个会话的消息放入到相同的队列中，让协程进行消费。</p><h3 id="2、消息不丢失问题"><a href="#2、消息不丢失问题" class="headerlink" title="2、消息不丢失问题"></a>2、消息不丢失问题</h3><p>上面的方案，当消费者从kafka拉到消息后，并没有等待处理完成就继续从kafka拉取消息然后缓存到内存中，等待消费队列慢慢消费，这个时候如果机器宕机，则内存中的消息将会丢失。</p><p>基于上面描述的问题，考虑使用手动提交offset。但是这样其实还存在一个问题就是：各个协程处理的offset值其实是不一样的，如下图：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/da37d0a0700a39ea6405e8060197016e.png" alt="在这里插入图片描述"><br>此时goroutine1和goroutine2 的消息的offset不一致，为了保证消息不丢失，采用以下策略：定期手动提交当前的offset信息，提交的offset值选当前分区的最小的offset，如上面的就选1001这个offset值。可以采用在内存中缓存处理的offset列表的实现方式，如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/28c935d1fb21bf9f00a9ea175fe2d806.png" alt="在这里插入图片描述"><br><strong>当内存中待处理的最大offset与最小的offset差值&gt;&#x3D; M时，阻塞消费线程继续从kafka拉取消息，控制异常情况下的数据最多不多于M条</strong><br>但是此时会引进一个新问题：消息重复消费</p><p>此时要保证消息消费的幂等性，如可通过消息唯一标识放入如redis中判断</p><h3 id="3、消息堆积问题"><a href="#3、消息堆积问题" class="headerlink" title="3、消息堆积问题"></a>3、消息堆积问题</h3><p>堆积原因：</p><ul><li>生产者短时间生产大量消息到broker，消费者无法及时消费，如大促</li><li>生产者无法感知消息堆积，仍继续生产消息，导致消息堆积进一步加剧</li><li>消费者能力不足，消费时间长，消费者宕机、网络异常与broker无法通信</li><li>业务功能存在bug，导致消费者无法消费</li></ul><p>解决方案<br>消费者端</p><ul><li>增加消费者数量，并采用并发消费</li><li>提高消费速度，避免消费时间过长。如果单条消息消费时间无法优化，可以提高批次拉取的数量(当批次拉取的数量较少时，拉取数据量&#x2F;处理时间 &lt; 生产速度时就容易堆积)</li><li>消费消息时尽量减少耗时操作，尽量减少三方接口调用、读写库等</li><li>合理设置消费组服务数量，合理增加topic的partition&#x3D;个数，消费者数 &gt;&#x3D; 分区数</li><li>补偿消费，即消费跳过积压数据，直接消费最新的数据，同时启动补偿数据进程消费积压数据</li></ul><p>生产者端</p><ul><li>支持熔断与隔离，当broker消息积压时，对生产者熔断</li><li>根据key采用合适的算法，将消息均匀分不到对应的分区中</li></ul><p>服务端</p><ul><li>进行预估，设置合理的分区数</li></ul><p>在电商中经常大促，因此很容易出现短时间内产生大量消息的问题，因此在大促前可根据历史情况进行容量预估和相关的扩容策略。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.51cto.com/article/713177.html">我是如何将一个老系统的Kafka消费者服务的性能提升近百倍的</a></p>]]></content>
    
    
    <categories>
      
      <category>工作总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作总结</tag>
      
      <tag>聊天系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chat聊天系统思考之一</title>
    <link href="/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80/"/>
    <url>/2025/04/12/chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E4%B9%8B%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前有段工作经历涉及到了chat相关，而消息的发送 -&gt; 存储 -&gt; 消费是由不同的团队负责的，因此消息如何再多个团队之间流通、以及通过什么介质传递都是需要考虑的问题。</p><p>之前我负责过一些消息消费的相关工作，消息发送团队将消息推送到kafka之后，由我们去订阅topic并消费对应的分区，拿到消息之后做对应的消息类型解析、消息发送双方可见性分析、接收方未读数、推送等业务处理。本文旨在记录之前工作中遇到的相关问题以及从consumer端如何优化处理。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/80d56c66d935fd536a67c369798a31ef.png" alt="消息流转过程"></p><p>可以看到，消息系统中引入了kafka，因此如果kafka出现问题，那整个系统都会出现问题。</p><h3 id="顺序问题"><a href="#顺序问题" class="headerlink" title="顺序问题"></a>顺序问题</h3><h4 id="1、为什么要保证消息的顺序"><a href="#1、为什么要保证消息的顺序" class="headerlink" title="1、为什么要保证消息的顺序"></a>1、为什么要保证消息的顺序</h4><p>我们之所以能够回复对方发过来的消息的依据就是对方消息内容，因此对于chat系统来说，消息的顺序性是必须要求保证的硬核标准，如果消息乱序，那这个chat系统可以说是完全报废。因此对于chat系统来说<strong>必须要保证消息的顺序性</strong> 。</p><h4 id="2、如何保证消息的顺序性"><a href="#2、如何保证消息的顺序性" class="headerlink" title="2、如何保证消息的顺序性"></a>2、如何保证消息的顺序性</h4><p>众所周知，kafka有topic的概念，每个topic可以拥有多个<code>分区(partition)</code>，而每个分区的内部都是有序的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7247ada71b52740fb7e9eb4713e921e0.png" alt="kafka生产者"></p><p>如此一来，如何保证消息的顺序性思路就比较清晰了，完全可以利用<code>partition</code>的特性去做处理，按照一定的规则将消息写到不同的<code>partition</code>中去，然后消费者消费<code>partition</code>中的消息。</p><p>思考这样一个问题：写到<code>partition</code>中的消息要按照什么规则去做呢？试想一下，我们要保证消息的顺序性，有序性是在同一会话的前提下，也就是说不同会话之前不需要保证消息的顺序性，因此我们可以把<code>conversationId</code>去做如取余或哈希操作，将同一个<code>partition</code>会话的消息全都放入一个<code>partition</code>中。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0875a160e32802d14a70183d09e926d1.png" alt="分区与消费者绑定关系"></p><h3 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h3><p>上述一期方案上线后在项目初期运行一段时间基本没问题，但随着产品推广用户量激增，上述消费架构就出现了问题：消息接收方受消息不够实时，延迟比较高，这对用户来说十分不友好，本来10秒钟几句话的事，到现在可能延迟有1分钟，这谁能忍得了啊。</p><p>虽然可以通过水平扩展增加机器数量来缓解压力，但这不是最优的方案，而且最主要是费钱。</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h5 id="1、消息体"><a href="#1、消息体" class="headerlink" title="1、消息体"></a>1、消息体</h5><p>思考下kafka消息发送到消息消费共经历了几次IO?</p><ul><li>从producer到broker经历一次网络IO</li><li>broker落盘经历一次磁盘IO</li><li>consumer从broker取数据时经历一次网络IO</li><li>broker从磁盘拿数据经历一次磁盘IO</li></ul><p>一共经历四次IO，引用一张如图说明<br><img src="https://i-blog.csdnimg.cn/blog_migrate/37a9910c450eef9c59f1b53bdd3a5a31.png" alt="kafka消息写入过程"></p><p>因此这里有个优化思路就是减少消费者取数据时broker从磁盘取数据时经历的IO耗时，那该如何减少呢？</p><p>试想一下，假设消费者每次取500条数据，如果每条消息的消息体过大，那取500条数据经历IO耗时势必会增加，进而影响生产和消费速度。而且当消息体过大时，还有可能会导致磁盘空间不足的问题。</p><h5 id="2、路由规则"><a href="#2、路由规则" class="headerlink" title="2、路由规则"></a>2、路由规则</h5><p>排除消息体过大的原因之后，我们需要看下kafka是否存在lag，如果存在lag我们要从消费者端解决问题。</p><p>根据监控查看出现lag的具体的分区，如果是同一个topic的特定某几个分区出现lag，那就需要考虑下是不是路由规则不合理的问题。</p><p>一个例子就是对于点餐系统，如果路由规则是根据商家ID来做的，而某些商家订单量一直很大，恰巧这些商家的相关消息都路由到了同一个<code>partition</code>，就导致只有这个<code>partition</code>出现了lag，进而消息处理较慢。</p><p>针对这种路由不合理的问题，解决方案就是选择合理的路由规则或key，如上述点餐系统，可以考虑路由规则根据订单号来做，因为所有订单号都是基于同一套方案生成的，所以基本不会出现个别<code>partition</code> lag太高的情况。</p><p>而chat系统之前也说过路由规则是基于<code>conversationId</code>去做的，而conversationId也是基于相同的方案生成的，所以如果出现lag发生，那理论上会涉及到大多数<code>partition</code>都出现lag。</p><h5 id="3、表过大"><a href="#3、表过大" class="headerlink" title="3、表过大"></a>3、表过大</h5><p>假设现在有1亿conversation存于一张表中，即使有索引，根据conversationId去查询对应会话信息的时候耗时也会很高，一条消息的消费原来可能只有500ms，但是现在可能需要5s甚至更久，因此，当数据量比较大时就要考虑分表了。</p><p>这里提供一种分表思路，基于conversatioId%100去做，或者是对1000取余。</p><h5 id="4、数据库主从延迟"><a href="#4、数据库主从延迟" class="headerlink" title="4、数据库主从延迟"></a>4、数据库主从延迟</h5><p>如果在生产环境数据库采用主从架构，主节点负责写，从节点负责读，在从broker拿到消息并完成解析拿到conversationId，这时候去会话团队拿数据，发现数据返回空，对应我们这边后续消费逻辑直接报错而返回，而会话团队根据conversationId去查是有这个会话的，这种情况第一次遇到时就显得很诡异。</p><p>后来进过分析发现，我们这边调接口时走的是会话团队数据库的从库，而主从同步还没将最新数据写到从库中。</p><p>发现问题后有两个解决方案：</p><ul><li>直接读master节点，这种方案不太可取，这样slave节点只作为备份？而且master节点压力会变大，甚至垮掉，也就失去了主从架构原有的作用。</li><li>加入重试机制，读取到conversation为空时，将此消息加入到<code>重试表</code>，在做后续处理。</li></ul><h5 id="5、并发消费"><a href="#5、并发消费" class="headerlink" title="5、并发消费"></a>5、并发消费</h5><p>上述消费架构是一个分区有一个消费者，既然一个消费者消费速度太慢，那何不增加消费者的数量呢？因此优化思路就有了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/931490e2deb7ca3d158495261f9239e4.png" alt="并发消费实现原理"></p><p>可以把每个<code>partition</code>中的消息按照conversationId%5然后放入到channel中，然后每个channel在配备一个goroutine去消费，这样既能保证同一会话消息的顺序性，又能提升消费速度尽量避免lag。</p>]]></content>
    
    
    <categories>
      
      <category>工作总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作总结</tag>
      
      <tag>聊天系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go实现的简单压测工具</title>
    <link href="/2025/04/12/go%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/04/12/go%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="1、参数概览"><a href="#1、参数概览" class="headerlink" title="1、参数概览"></a>1、参数概览</h3><p>依赖<code>github.com/ddliu/go-httpclient</code>进行http接口请求<br>依赖<code>github.com/antlabs/pcurl</code>解析curl</p><p>输入参数：</p><ul><li>-c，concurrency，并发数，启动协程数</li><li>-n， totalNumber，单个协程发送的请求个数</li><li>-u，curl字符串</li><li>-p，如果不使用-u，可以将curl地址放在文件中，使用-p传入curl文件地址</li><li>-e，expectCode，期望response返回的状态码</li></ul><h3 id="2、核心代码"><a href="#2、核心代码" class="headerlink" title="2、核心代码"></a>2、核心代码</h3><h4 id="1、网络请求server-dispose-go"><a href="#1、网络请求server-dispose-go" class="headerlink" title="1、网络请求server&#x2F;dispose.go"></a>1、网络请求server&#x2F;dispose.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注册verify校验器</span><br>verify.RegisterVerifyHttp(verify.GetVerifyKey(<span class="hljs-string">&quot;statusCode&quot;</span>), verify.VerifyHttpByStatusCode)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dispose</span><span class="hljs-params">(ctx context.Context, req *request.Request, concurrency, totalNumber <span class="hljs-type">uint64</span>)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *response.ResponseResult, <span class="hljs-number">1000</span>)<br>wg := sync.WaitGroup&#123;&#125;<br>wgReceiving := sync.WaitGroup&#123;&#125;<br><br>wgReceiving.Add(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 统计数据详情</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wgReceiving.Done()<br>statistics.HandleStatics(concurrency, ch)<br>&#125;()<br><br><span class="hljs-comment">// 传递的-c参数，为每个协程创建-n次请求</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>); i &lt; concurrency; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>chanId := i<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>serveHTTP(ctx, chanId, totalNumber, ch, req)<br>&#125;()<br>&#125;<br><br>wg.Wait()<br>time.Sleep(time.Millisecond)<br><span class="hljs-built_in">close</span>(ch)<br>wgReceiving.Wait()<br>&#125;<br><br><span class="hljs-comment">// 真正发送请求的方法</span><br><span class="hljs-comment">// chanId 每个协程的身份Id</span><br><span class="hljs-comment">// ch 用于接受http接口响应数据</span><br><span class="hljs-comment">// req 根据curl解析出来的request结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveHTTP</span><span class="hljs-params">(ctx context.Context, chanId, totalNumber <span class="hljs-type">uint64</span>, ch <span class="hljs-keyword">chan</span>&lt;- *response.ResponseResult, req *request.Request)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>); i &lt; totalNumber; i++ &#123;<br><span class="hljs-keyword">if</span> ctx.Err() != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;ctx.Err err: %v \n&quot;</span>, ctx.Err())<br><span class="hljs-keyword">break</span><br>&#125;<br>header := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> req.Header &#123;<br>header[k] = req.Header.Get(k)<br>&#125;<br><br>respStatusCode := constants.Success<br>isSucceed := <span class="hljs-literal">false</span><br><br>start := time.Now()<br>resp, err := httpclient.Do(req.Method, req.URL.String(), header, <span class="hljs-literal">nil</span>)<br>cost := <span class="hljs-type">uint64</span>(time.Since(start).Nanoseconds()) <span class="hljs-comment">//统计耗时</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || resp == <span class="hljs-literal">nil</span> &#123;<br>respStatusCode = constants.RequestFailed<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 校验response code与-e是否相同</span><br>respStatusCode, isSucceed = verify.GetVerify(verify.GetVerifyKey(<span class="hljs-string">&quot;statusCode&quot;</span>))(req, resp)<br>&#125;<br><br>result := &amp;response.ResponseResult&#123;<br>Id:         fmt.Sprintf(<span class="hljs-string">&quot;%d-%d&quot;</span>, chanId, i),<br>ChanId:     chanId,<br>Cost:       cost,<br>IsSucceed:  isSucceed,<br>StatusCode: respStatusCode,<br>&#125;<br><span class="hljs-comment">// 写数据</span><br>ch &lt;- result<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、校验器verify-verify-go"><a href="#2、校验器verify-verify-go" class="headerlink" title="2、校验器verify&#x2F;verify.go"></a>2、校验器verify&#x2F;verify.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Verify <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*request.Request, *httpclient.Response)</span></span> (constants.ErrCode, <span class="hljs-type">bool</span>)<br><br><span class="hljs-keyword">var</span> (<br>verifyMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Verify)<br>mutex     sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterVerifyHttp</span><span class="hljs-params">(key <span class="hljs-type">string</span>, verifyFunc Verify)</span></span> &#123;<br>mutex.Lock()<br><span class="hljs-keyword">defer</span> mutex.Unlock()<br>verifyMap[key] = verifyFunc<br>&#125;<br><br><span class="hljs-comment">// request 解析curl所得</span><br><span class="hljs-comment">// response http请求结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">VerifyHttpByStatusCode</span><span class="hljs-params">(request *request.Request, response *httpclient.Response)</span></span> (constants.ErrCode, <span class="hljs-type">bool</span>) &#123;<br>responseCode := response.StatusCode<br><span class="hljs-keyword">if</span> responseCode == request.ExpectedCode &#123;<br><span class="hljs-keyword">return</span> constants.ErrCode(responseCode), <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> constants.ErrCode(responseCode), <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetVerifyKey</span><span class="hljs-params">(t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;http.%s&quot;</span>, t)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetVerify</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> Verify &#123;<br>verify, ok := verifyMap[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;verify方法不存在&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> verify<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、解析curl-request-request-go"><a href="#3、解析curl-request-request-go" class="headerlink" title="3、解析curl  request&#x2F;request.go"></a>3、解析curl  request&#x2F;request.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>*http.Request<br>ExpectedCode <span class="hljs-type">int</span> <span class="hljs-comment">//-e参数输入</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRequest</span><span class="hljs-params">(curl, path <span class="hljs-type">string</span>, expectedCode <span class="hljs-type">int</span>)</span></span> (*Request, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 优先使用文件解析curl</span><br><span class="hljs-keyword">if</span> path != <span class="hljs-string">&quot;&quot;</span> &#123;<br>file, err := os.Open(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;open curl file %s failed, err: %+v\n&quot;</span>, path, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>buf, err := io.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;read curl file %s failed, err: %+v\n&quot;</span>, path, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>curl = <span class="hljs-type">string</span>(buf)<br>&#125;<br><br>req, err := pcurl.ParseAndRequest(curl)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;parse curl file %s failed, err: %+v\n&quot;</span>, path, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Request&#123;<br>Request:      req,<br>ExpectedCode: expectedCode,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、数据统计statstics-statistics-go"><a href="#4、数据统计statstics-statistics-go" class="headerlink" title="4、数据统计statstics&#x2F;statistics.go"></a>4、数据统计statstics&#x2F;statistics.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HandleStatics 所有耗时变量均为纳秒</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleStatics</span><span class="hljs-params">(concurrency <span class="hljs-type">uint64</span>, ch &lt;-<span class="hljs-keyword">chan</span> *response.ResponseResult)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>requestCostTimeList []<span class="hljs-type">uint64</span>     <span class="hljs-comment">// 耗时数组</span><br>processingTime      <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// processingTime 处理总耗时</span><br>requestCostTime     <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// requestCostTime 请求总时间</span><br>maxTime             <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// maxTime 至今为止单个请求最大耗时</span><br>minTime             <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// minTime 至今为止单个请求最小耗时</span><br>successNum          <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span><br>failureNum          <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span><br>chanIdLen           <span class="hljs-type">uint64</span>   = <span class="hljs-number">0</span> <span class="hljs-comment">// chanIdLen 并发数</span><br>stopChan                     = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>mutex                        = sync.RWMutex&#123;&#125;<br>chanIds                      = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>)<br><br>startTime := <span class="hljs-type">uint64</span>(time.Now().UnixNano())<br>respCodeMap := sync.Map&#123;&#125;<br>ticker := time.NewTicker(time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>endTime := <span class="hljs-type">uint64</span>(time.Now().UnixNano())<br>mutex.Lock()<br><span class="hljs-keyword">go</span> calculateData(concurrency, processingTime, endTime-startTime, maxTime, minTime, successNum, failureNum, chanIdLen, &amp;respCodeMap)<br>mutex.Unlock()<br><span class="hljs-keyword">case</span> &lt;-stopChan:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br>printHeader()<br><span class="hljs-keyword">for</span> respRes := <span class="hljs-keyword">range</span> ch &#123;<br>mutex.Lock()<br>processingTime = processingTime + respRes.Cost<br><span class="hljs-keyword">if</span> maxTime &lt;= respRes.Cost &#123;<br>maxTime = respRes.Cost<br>&#125;<br><span class="hljs-keyword">if</span> minTime == <span class="hljs-number">0</span> &#123;<br>minTime = respRes.Cost<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> minTime &gt; respRes.Cost &#123;<br>minTime = respRes.Cost<br>&#125;<br><span class="hljs-keyword">if</span> respRes.IsSucceed &#123;<br>successNum = successNum + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>failureNum = failureNum + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 统计response状态码</span><br><span class="hljs-keyword">if</span> value, ok := respCodeMap.Load(respRes.StatusCode); ok &#123;<br>total, _ := value.(<span class="hljs-type">int</span>)<br>respCodeMap.Store(respRes.StatusCode, total+<span class="hljs-number">1</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>respCodeMap.Store(respRes.StatusCode, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 统计并发数</span><br><span class="hljs-keyword">if</span> _, ok := chanIds[<span class="hljs-type">int</span>(respRes.ChanId)]; !ok &#123;<br>chanIds[<span class="hljs-type">int</span>(respRes.ChanId)] = <span class="hljs-literal">true</span><br>chanIdLen = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(chanIds))<br>&#125;<br>requestCostTimeList = <span class="hljs-built_in">append</span>(requestCostTimeList, respRes.Cost)<br>mutex.Unlock()<br>&#125;<br><span class="hljs-comment">// 数据全部接受完成，停止定时输出统计数据</span><br>stopChan &lt;- <span class="hljs-literal">true</span><br>endTime := <span class="hljs-type">uint64</span>(time.Now().UnixNano())<br>requestCostTime = endTime - startTime<br>calculateData(concurrency, processingTime, requestCostTime, maxTime, minTime, successNum, failureNum, chanIdLen, &amp;respCodeMap)<br><br>fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;*************************  结果 stat  ****************************&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;处理协程数量:&quot;</span>, concurrency)<br>fmt.Println(<span class="hljs-string">&quot;请求总数（并发数*请求数 -c * -n）:&quot;</span>, successNum+failureNum, <span class="hljs-string">&quot;总请求时间:&quot;</span>,<br>fmt.Sprintf(<span class="hljs-string">&quot;%.3f&quot;</span>, <span class="hljs-type">float64</span>(requestCostTime)/<span class="hljs-number">1e9</span>),<br><span class="hljs-string">&quot;秒&quot;</span>, <span class="hljs-string">&quot;successNum:&quot;</span>, successNum, <span class="hljs-string">&quot;failureNum:&quot;</span>, failureNum)<br>printTop(requestCostTimeList)<br>fmt.Println(<span class="hljs-string">&quot;*************************  结果 end   ****************************&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateData</span><span class="hljs-params">(concurrent, processingTime, costTime, maxTime, minTime, successNum, failureNum, chanIdLen <span class="hljs-type">uint64</span>, respCodeMap *sync.Map)</span></span> &#123;<br><span class="hljs-keyword">if</span> processingTime == <span class="hljs-number">0</span> || chanIdLen == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> qps, averageTime, maxTimeFloat, minTimeFloat, requestCostTimeFloat <span class="hljs-type">float64</span><br><br><span class="hljs-comment">// 平均 QPS 成功数*总协程数/总耗时 (每秒)</span><br>qps = <span class="hljs-type">float64</span>(successNum*<span class="hljs-number">1e9</span>*concurrent) / <span class="hljs-type">float64</span>(processingTime)<br><br><span class="hljs-comment">// 平均耗时 总耗时/总请求数/并发数 纳秒=&gt;毫秒</span><br><span class="hljs-keyword">if</span> successNum != <span class="hljs-number">0</span> &amp;&amp; concurrent != <span class="hljs-number">0</span> &#123;<br>averageTime = <span class="hljs-type">float64</span>(processingTime) / <span class="hljs-type">float64</span>(successNum*<span class="hljs-number">1e6</span>)<br>&#125;<br>maxTimeFloat = <span class="hljs-type">float64</span>(maxTime) / <span class="hljs-number">1e6</span><br>minTimeFloat = <span class="hljs-type">float64</span>(minTime) / <span class="hljs-number">1e6</span><br>requestCostTimeFloat = <span class="hljs-type">float64</span>(costTime) / <span class="hljs-number">1e9</span><br><br>result := fmt.Sprintf(<span class="hljs-string">&quot;%4.0fs│%7d│%7d│%7d│%8.2f│%11.2f│%11.2f│%11.2f│%v&quot;</span>,<br>requestCostTimeFloat, chanIdLen, successNum, failureNum, qps, maxTimeFloat, minTimeFloat, averageTime, printMap(respCodeMap))<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHeader</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;─────┬───────┬───────┬───────┬────────┬───────────┬───────────┬───────────┬────────&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot; 耗时│ 并发数│ 成功数│ 失败数│   qps  │最长耗时/ms│最短耗时/ms│平均耗时/ms│ 状态码&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;─────┼───────┼───────┼───────┼────────┼───────────┼───────────┼───────────┼────────&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 打印响应状态码及数量, 如 200:5</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMap</span><span class="hljs-params">(respCodeMap *sync.Map)</span></span> (mapStr <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">var</span> mapArr []<span class="hljs-type">string</span><br><br>respCodeMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>mapArr = <span class="hljs-built_in">append</span>(mapArr, fmt.Sprintf(<span class="hljs-string">&quot;%v:%v&quot;</span>, key, value))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br>sort.Strings(mapArr)<br>mapStr = strings.Join(mapArr, <span class="hljs-string">&quot;;&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// printTop 排序后计算 top 90 95 99</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTop</span><span class="hljs-params">(requestCostTimeList []<span class="hljs-type">uint64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(requestCostTimeList) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>all := uint64Array&#123;&#125;<br>all = requestCostTimeList<br>sort.Sort(all)<br>fmt.Println(<span class="hljs-string">&quot;tp90:&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%.3fms&quot;</span>, <span class="hljs-type">float64</span>(all[<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(all))*<span class="hljs-number">0.90</span>)]/<span class="hljs-number">1e6</span>)))<br>fmt.Println(<span class="hljs-string">&quot;tp95:&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%.3fms&quot;</span>, <span class="hljs-type">float64</span>(all[<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(all))*<span class="hljs-number">0.95</span>)]/<span class="hljs-number">1e6</span>)))<br>fmt.Println(<span class="hljs-string">&quot;tp99:&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%.3fms&quot;</span>, <span class="hljs-type">float64</span>(all[<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(all))*<span class="hljs-number">0.99</span>)]/<span class="hljs-number">1e6</span>)))<br>&#125;<br><br><span class="hljs-keyword">type</span> uint64Array []<span class="hljs-type">uint64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(array uint64Array)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(array) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(array uint64Array)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; array[i], array[j] = array[j], array[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(array uint64Array)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> array[i] &lt; array[j] &#125;<br></code></pre></td></tr></table></figure><h4 id="5、main-go"><a href="#5、main-go" class="headerlink" title="5、main.go"></a>5、main.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>concurrency  <span class="hljs-type">uint64</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 并发数</span><br>totalNumber  <span class="hljs-type">uint64</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 请求个数</span><br>curl                = <span class="hljs-string">&quot;&quot;</span><br>curlPath            = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// curl文件路径</span><br>expectedCode        = <span class="hljs-number">200</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>flag.Uint64Var(&amp;concurrency, <span class="hljs-string">&quot;c&quot;</span>, concurrency, <span class="hljs-string">&quot;并发数&quot;</span>)<br>flag.Uint64Var(&amp;totalNumber, <span class="hljs-string">&quot;n&quot;</span>, totalNumber, <span class="hljs-string">&quot;请求数(单个并发)&quot;</span>)<br>flag.StringVar(&amp;curl, <span class="hljs-string">&quot;u&quot;</span>, curl, <span class="hljs-string">&quot;压测地址&quot;</span>)<br>flag.StringVar(&amp;curlPath, <span class="hljs-string">&quot;p&quot;</span>, curlPath, <span class="hljs-string">&quot;curl文件地址&quot;</span>)<br>flag.IntVar(&amp;expectedCode, <span class="hljs-string">&quot;e&quot;</span>, expectedCode, <span class="hljs-string">&quot;期望请求结果的状态码&quot;</span>)<br><br>flag.Parse()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(getCPUNum())<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(curl) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(curlPath) == <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;示例: go run main.go -c 1 -n 1 -u https://www.baidu.com/ \n&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>req, err := request.NewRequest(curl, curlPath, expectedCode)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>ctx := context.Background()<br>server.Dispose(ctx, req, concurrency, totalNumber)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCPUNum</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> runtime.NumCPU()/<span class="hljs-number">4</span> &lt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> runtime.NumCPU() / <span class="hljs-number">4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、验证猜想"><a href="#3、验证猜想" class="headerlink" title="3、验证猜想"></a>3、验证猜想</h3><ul><li>启动<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> -c <span class="hljs-number">1000</span> -n <span class="hljs-number">5000</span> -p D:\<span class="hljs-keyword">go</span>\<span class="hljs-keyword">go</span>-demo\gostress\test-stress.curl <br></code></pre></td></tr></table></figure></li><li>qps、耗时等统计如下<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5d091430a9c4763253d430f4bda16954.png" alt="qps"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/76c18a39ccdf0c9d0d6484056ad910b7.png" alt="耗时"></li></ul><p>为验证工具统计正确性，配置prometheus进行对照<br><img src="https://i-blog.csdnimg.cn/blog_migrate/72cfecb04da708cb4c29d3d289228bc4.png" alt="普罗米修斯监控指标"><br>可以看到prometheus在http server端统计到的数据qps、tp99、tp90、tp95基本上是符合的，由此验证工具正确性</p><h3 id="4、工具http接口-监控"><a href="#4、工具http接口-监控" class="headerlink" title="4、工具http接口&amp;监控"></a>4、工具http接口&amp;监控</h3><h4 id="1、server端监控代码monitor-monitor-go"><a href="#1、server端监控代码monitor-monitor-go" class="headerlink" title="1、server端监控代码monitor&#x2F;monitor.go"></a>1、server端监控代码monitor&#x2F;monitor.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 统计qps</span><br><span class="hljs-keyword">var</span> HttpRequestCount = prometheus.NewCounterVec(<br>prometheus.CounterOpts&#123;<br>Name: <span class="hljs-string">&quot;http_request_count&quot;</span>,<br>Help: <span class="hljs-string">&quot;http request count&quot;</span>,<br>&#125;,<br>[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;endpoint&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>&#125;,<br>)<br><br><span class="hljs-keyword">var</span> Histogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123;<br>Name:    <span class="hljs-string">&quot;histogram_showcase_metric&quot;</span>,<br>Buckets: []<span class="hljs-type">float64</span>&#123;<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">120</span>, <span class="hljs-number">130</span>, <span class="hljs-number">140</span>, <span class="hljs-number">150</span>, <span class="hljs-number">160</span>, <span class="hljs-number">170</span>, <span class="hljs-number">180</span>, <span class="hljs-number">190</span>, <span class="hljs-number">200</span>, <span class="hljs-number">210</span>, <span class="hljs-number">220</span>, <span class="hljs-number">230</span>, <span class="hljs-number">240</span>, <span class="hljs-number">250</span>, <span class="hljs-number">260</span>, <span class="hljs-number">270</span>, <span class="hljs-number">280</span>, <span class="hljs-number">290</span>, <span class="hljs-number">300</span>&#125;, <span class="hljs-comment">// 根据场景需求配置bucket的范围</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2、main-go"><a href="#2、main-go" class="headerlink" title="2、main.go"></a>2、main.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>prometheus.MustRegister(monitor.HttpRequestCount)<br>prometheus.MustRegister(monitor.Histogram)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/metrics&quot;</span>, PromHandler(promhttp.Handler()))<br>r.GET(<span class="hljs-string">&quot;/stress&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>start := time.Now()<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;gin demo&quot;</span>)<br>monitor.HttpRequestCount.WithLabelValues(c.Request.URL.Path, <span class="hljs-string">&quot;8888&quot;</span>).Inc()<br><br>n := rand.Intn(<span class="hljs-number">100</span>)<br><span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">95</span> &#123;<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>time.Sleep(<span class="hljs-number">50</span> * time.Millisecond)<br>&#125;<br><br>monitor.Histogram.Observe((<span class="hljs-type">float64</span>)(time.Since(start) / time.Millisecond))<br>&#125;)<br><br>r.Run(<span class="hljs-string">&quot;:8888&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PromHandler</span><span class="hljs-params">(handler http.Handler)</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>handler.ServeHTTP(c.Writer, c.Request)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、prometheus与grafana在windows安装步骤"><a href="#5、prometheus与grafana在windows安装步骤" class="headerlink" title="5、prometheus与grafana在windows安装步骤"></a>5、prometheus与grafana在windows安装步骤</h3><ul><li><p>prometheus安装<br>直接google，改配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br><br>  <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>  <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br><span class="hljs-comment"># 此次测试监控</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;go-stress&quot;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:8888&quot;</span>]<br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:8889&quot;</span>]<br><span class="hljs-comment"># 监控windows   </span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;windows&quot;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9182&quot;</span>]<br></code></pre></td></tr></table></figure><p>启动后打开localhost:9090查看</p></li><li><p>grafana安装<br>官网下载zip安装包，解压启动即可</p></li><li><p>grafana面板配置<br><strong>qps</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">sum(<span class="hljs-name">rate</span>(<span class="hljs-name">http_request_duration_count</span>&#123;&#125;[<span class="hljs-number">1</span>m])) by (<span class="hljs-name">endpoint</span>)<br></code></pre></td></tr></table></figure><p>TP90</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">histogram_quantile</span>(<span class="hljs-number">0</span>.<span class="hljs-number">90</span>, rate(histogram_showcase_metric_bucket&#123;instance=<span class="hljs-string">&quot;localhost:8888&quot;</span>&#125;[<span class="hljs-number">1</span>m]))<br></code></pre></td></tr></table></figure><p>TP99、TP95修改对应值即可</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>造轮子-工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>压测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于构建内容审核体系思考</title>
    <link href="/2025/04/12/%E5%85%B3%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%86%85%E5%AE%B9%E5%AE%A1%E6%A0%B8%E4%BD%93%E7%B3%BB%E6%80%9D%E8%80%83/"/>
    <url>/2025/04/12/%E5%85%B3%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%86%85%E5%AE%B9%E5%AE%A1%E6%A0%B8%E4%BD%93%E7%B3%BB%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="关于构建内容审核体系思考"><a href="#关于构建内容审核体系思考" class="headerlink" title="关于构建内容审核体系思考"></a>关于构建内容审核体系思考</h1><p>对于很多企业尤其是互联网内容企业如大型论坛、直播等来说，内容安全可以说是企业的生死线。内容审核能够甄别并过滤出涉黄、暴恐、违禁、不良价值观、广告等风险内容，确保企业平台上的信息符合法律法规和运营规则，从而保障企业的内容安全‌。</p><h1 id="1-服务划分"><a href="#1-服务划分" class="headerlink" title="1 服务划分"></a>1 服务划分</h1><p><img src="https://i-blog.csdnimg.cn/direct/e80aa69c76f746de8e8754a187a6bcb2.png" alt="服务架构"></p><ul><li>业务层：产品的使用者，包括C端和B端用户，其中B端用户一般代表着商家，其发布的内容影响力相对来说会比较大，也是内容审核的重点。</li><li>接入层：通用网关，负责鉴权、路由转发、负载均衡等</li><li>应用层：应用层包含对单体资源的审核与业务复合型资源的打包审核，其中资源审核又分为机审和人审，机审误杀率实际上是比较高的，因此对于机审非PASS的需要介入人审，最终结果以人审为主</li><li>服务层：服务层主要是所依赖的第三方服务，用于机器审核</li><li>基础层：包含依赖的公共组件</li></ul><p>将内容审核服务收归并对外暴露一套接口以供其他业务接入，其他业务无需自己再维护一套机审逻辑<br>通过送审-机审-人审架构，实现业务零风险</p><h1 id="2-机审必要性"><a href="#2-机审必要性" class="headerlink" title="2 机审必要性"></a>2 机审必要性</h1><p>机审可以大大降低人工复核量，节约成本</p><ul><li>机审可以极大地降低人工复核量，对于一些机审PASS的就可以不再关注，只需关注机审存疑和直接拒绝的即可</li><li>灵活的审核策略与执行策略，针对不同业务指定不同审核规则，进而实现业务级审核粒度</li><li>鉴于机审存在误差，对于要求严格的业务，考虑多厂商交叉审核，只要有一个厂商认为图片有问题就流入人审复核</li></ul><h1 id="3-审核体系构建"><a href="#3-审核体系构建" class="headerlink" title="3 审核体系构建"></a>3 审核体系构建</h1><p><img src="https://i-blog.csdnimg.cn/direct/13b31d29eea84100a6974cadefe61a3c.png" alt="机审主流程"></p><ul><li>机审整体流程如上图所示，其中图片、文本类机器审核响应速度很快，无需异步处理可实时获取到审核结果，但对于音频、视频、文档这类审核时间较长，需等审核完成后由厂商回调得到最终结果</li><li>图中红色 <strong>countdown动作</strong> 表示审核完成(最终态)计数动作，当countdown计数器降为0时会回调业务方，告知业务方业务资源最终审核状态，如动态是否审核通过，以此判断是否允许发布或全员可见</li></ul><h2 id="3-1-审核策略择路"><a href="#3-1-审核策略择路" class="headerlink" title="3.1 审核策略择路"></a>3.1 审核策略择路</h2><p>由于业务多样、资源类型不同、多厂商审核的原因，审核策略也就会存在多样，因此审核策略需要拎出来单独管理<br>此外，除了这种全局策略，对于电商这种存在店铺概念的还需支持店铺级审核策略及新店铺规则<br><img src="https://i-blog.csdnimg.cn/direct/862ceb916fa64f73b7c38e2a1c341ae8.png" alt="审核策略择路"></p><p>审核策略优先级为 店铺级 &gt; 新店铺 &gt; 全局策略<br>策略分级的优点</p><ul><li>当做白名单用：如当店铺自成立以来从无违规时，可为此店铺配置<code>全放行策略</code>，甚至是不审核，可以根据实际调整</li><li>当做黑名单用：当有一些店铺总是在红线附近横跳时也可将此店铺加入黑名单，并配置<code>机审严格</code>策略，让机审作为其结果而不用流入人审</li><li>新店铺自定义规则：对于新店铺，大部分情况下不需要太严格的审核策略，因此当度为新店铺配置一个规则是有必要的</li><li>店铺审核个性化配置：店铺级策略可支持但店铺定制化审核策略，为指定店铺不同来源路径下的资源配置不同审核策略</li></ul><h2 id="3-2-多厂商交叉审核"><a href="#3-2-多厂商交叉审核" class="headerlink" title="3.2 多厂商交叉审核"></a>3.2 多厂商交叉审核</h2><p>鉴于使用单厂商存在误判且无法容灾，考虑接入多云，只有当多厂商审核结果都为PASS时才放行，否则进入人审<br><img src="https://i-blog.csdnimg.cn/direct/d60959b5346e4019880edc99789f3c71.png" alt="多云交叉审核"></p><p>对于交叉审核注意点有以下几条</p><ul><li>优先选择机审准确率高的厂商作为第一道审核线，以降低二次送审次数，节约成本</li><li>当A厂商结果为PASS时才需流入B厂商，若第一道审核已经判断为非PASS时，则无需进入第二道审核</li><li>第一道审核发生异常时自动以第二道审核为主，但需配置监控告警，及时感知送审异常</li><li>多云审核最终结果可根据具体情况而定</li></ul><h2 id="3-2-送审-机审-人审全流程"><a href="#3-2-送审-机审-人审全流程" class="headerlink" title="3.2 送审-机审-人审全流程"></a>3.2 送审-机审-人审全流程</h2><p>素材从送审-机审-人审全流程大致如下</p><p><img src="https://i-blog.csdnimg.cn/direct/4dd0dd5848d64f29b0c601c233140c49.jpeg" alt="审核全流程"></p><ul><li>送审：业务统一送审到内容审核，由内容审核统一做机审，根据素材类型和业务类型不同做对应的响应</li><li>机审：内容审核服务作为底层服务接收其他业务送审素材，统一送至云厂商，并接收云厂商审核结果回调将审核结果落库并通知送审业务方最终结果</li><li>人审：对于存在违规嫌疑的素材将会流入到人审阶段，人审分为初审与复审。初审只过滤违规片段，与业务分离实现脱敏，初审拒绝的将会流入到复审；复审审核内容与具体业务强相关，并且包含此业务所有素材</li></ul><h1 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4 其他问题"></a>4 其他问题</h1><ul><li>送审优化：业务方送审条件需额外设计，如帖子浏览量达某阈值之后再送审等</li><li>直播审核优化：直播审核违规截帧片段再审核，进一步降低误杀率</li><li>文本审核优化：文本审核增加白名单，避免相同文本重复审核</li><li>去重处理：除直播外所有资源审核需加去重操作，如根据素材ID + 策略ID做key审核之前做去重</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作总结</tag>
      
      <tag>内容审核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cachego内存模型原理剖析</title>
    <link href="/2025/04/12/cachego%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/2025/04/12/cachego%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="cachego-内存模型原理剖析"><a href="#cachego-内存模型原理剖析" class="headerlink" title="cachego 内存模型原理剖析"></a>cachego 内存模型原理剖析</h1><p><a href="https://github.com/FishGoddess/cachego">cachego github地址</a><br>cachego 是一个拥有分片机制的轻量级内存缓存库，API 友好，支持多种数据淘汰机制，可以应用于所有的 GoLang 应用程序中</p><p><strong>功能特性</strong></p><ul><li>以键值对形式缓存数据，极简的 API 设计风格</li><li>引入 option function 模式，简化创建缓存参数</li><li>提供 ttl 过期机制，支持限制键值对数量</li><li>提供 lru 清理机制，提供 lfu 清理机制</li><li>引入分片机制提高并发，分片与内存淘汰策略可灵活搭配</li><li>支持懒清理机制，每一次访问的时候判断是否过期</li><li>支持哨兵清理机制，每隔一定的时间间隔进行清理</li><li>自带 singleflight 机制，减少缓存穿透的伤害</li><li>支持上报缓存状况，可自定义多个缓存上报点</li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU（Least Recently Used）称为最近最少使用算法。基本的思想是：长期不被使用的数据，在未来被用到的几率也不大，因此当新的数据进来时，就可以优先将这些数据替换掉。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>cachego LRU策略底层实现为双向链表，头部为最活跃元素，尾部为最近最少使用元素。元素在使用后(插入&#x2F;查询&#x2F;更新)元素会移动到头部，当元素数超限后从尾部移除元素以供插入新元素</p><p><img src="https://i-blog.csdnimg.cn/direct/9ea78ca7349d4a439e483c3314111ad8.png" alt="LRU算法实现"></p><h3 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><ul><li>lruCache 元素存储结构体</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> lruCache <span class="hljs-keyword">struct</span> &#123;<br>*config<br><br>elementMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element <span class="hljs-comment">// map，存在性判断;快速获取元素值</span><br>elementList *list.List <span class="hljs-comment">// 双向链表用于实现LRU</span><br>lock        sync.RWMutex <span class="hljs-comment">// 读写锁</span><br><br>loader *loader<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>set操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> evict() (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <span class="hljs-comment">// 内存淘汰策略</span><br><span class="hljs-keyword">if</span> element := lc.elementList.Back(); element != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// lru队列尾部先过期</span><br><span class="hljs-keyword">return</span> lc.removeElement(element)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>element, ok := lc.elementMap[key]<br><span class="hljs-keyword">if</span> ok &#123; <span class="hljs-comment">// update更新操作</span><br>entry := lc.unwrap(element)<br>entry.setup(key, value, ttl)<br><br>lc.elementList.MoveToFront(element) <span class="hljs-comment">// 元素移到队首</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> lc.maxEntries &gt; <span class="hljs-number">0</span> &amp;&amp; lc.elementList.Len() &gt;= lc.maxEntries &#123; <span class="hljs-comment">// 队列已满, 从队尾移除最近最少访问的元素</span><br>evictedValue = lc.evict()<br>&#125;<br><br>element = lc.elementList.PushFront(newEntry(key, value, ttl, lc.now)) <span class="hljs-comment">// 新建元素, 头插</span><br>lc.elementMap[key] = element<br><br><span class="hljs-keyword">return</span> evictedValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>element, ok := lc.elementMap[key] <span class="hljs-comment">// map存在性断定</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>entry := lc.unwrap(element)<br><span class="hljs-keyword">if</span> entry.expired(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 过期直接判定不存在</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>lc.elementList.MoveToFront(element) <span class="hljs-comment">// 移到队首</span><br><span class="hljs-keyword">return</span> entry.value, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>代码实现上相对简单，通过map+双向链表实现LRU算法，核心set、get逻辑清晰</li><li>不足处: 虽然有定时任务扫描过期key，但get时对于过期key未立即删除，会存在隐患，若队尾元素未过期，存在过期元素在队列中间，则理论上应该优先淘汰过期key。如果需要严格遵守LRU则可忽略此问题，因此可根据实际业务决定是否改造这一点</li></ul><h2 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h2><p>LFU（least frequently used）最近最不经常使用的算法，对于每个数据，维护其使用的次数以及最近的使用时间，删除的策略是：优先删除使用次数最少的数据，如果存在多个使用次数相同的数据，则优先删除最远一次使用的数据。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>cachego 是基于最小堆实现的LFU，使用 <code>最小堆</code> 来维护按访问频率排序的元素。当元素被访问时，更新其访问频率。当缓存满时，使用 最小堆 删除访问频率最小的元素</p><ul><li>最小堆<br>一棵完全二叉树，非叶子结点的值不大于左孩子和右孩子的值<br><img src="https://i-blog.csdnimg.cn/direct/8f0bd9e0dd134cdca9a4d186e94af498.png" alt="小根堆"></li></ul><h3 id="核心代码解读-1"><a href="#核心代码解读-1" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><ul><li><p>lfuCache结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> lfuCache <span class="hljs-keyword">struct</span> &#123;<br>*config<br><br>itemMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*heap.Item <span class="hljs-comment">// 同样的map，存在性判断及常数get</span><br>itemHeap *heap.Heap <span class="hljs-comment">// 小根堆</span><br>lock     sync.RWMutex<br><br>loader *loader<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lfuCache)</span></span> evict() (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <span class="hljs-comment">// 内存淘汰策略</span><br><span class="hljs-keyword">if</span> item := lc.itemHeap.Pop(); item != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 小根堆移除顶端元素</span><br><span class="hljs-keyword">return</span> lc.removeItem(item)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lfuCache)</span></span> set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>item, ok := lc.itemMap[key]<br><span class="hljs-keyword">if</span> ok &#123;<br>entry := lc.unwrap(item)<br>entry.setup(key, value, ttl)<br><br>item.Adjust(item.Weight() + <span class="hljs-number">1</span>) <span class="hljs-comment">// 核心访问次数加1,调整小根堆</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> lc.maxEntries &gt; <span class="hljs-number">0</span> &amp;&amp; lc.itemHeap.Size() &gt;= lc.maxEntries &#123; <span class="hljs-comment">// 过期驱除顶端key</span><br>evictedValue = lc.evict()<br>&#125;<br><br>item = lc.itemHeap.Push(<span class="hljs-number">0</span>, newEntry(key, value, ttl, lc.now)) <span class="hljs-comment">// 加入小根堆</span><br>lc.itemMap[key] = item<br><br><span class="hljs-keyword">return</span> evictedValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lfuCache)</span></span> get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>item, ok := lc.itemMap[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>entry := lc.unwrap(item)<br><span class="hljs-keyword">if</span> entry.expired(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 过期判断</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>item.Adjust(item.Weight() + <span class="hljs-number">1</span>) <span class="hljs-comment">// 访问次数加一</span><br><span class="hljs-keyword">return</span> entry.value, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>巧妙利用小根堆特性实现LFU，每次过期等删除操作只需移除顶端元素即可，增、改、查操作访问次数自增后堆结点元素需交换保证最小堆特性</li><li>不足处: 同样存在get操作唯一出过期key问题</li></ul><h2 id="Standard算法"><a href="#Standard算法" class="headerlink" title="Standard算法"></a>Standard算法</h2><p>cachego 默认存储及内存淘汰策略, 底层使用go原生map实现</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><p>go 原生map</p><h3 id="核心代码解读-2"><a href="#核心代码解读-2" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><ul><li><p>standardCache结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> standardCache <span class="hljs-keyword">struct</span> &#123;<br>*config<br><br>entries <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry <span class="hljs-comment">// 原生map, entry存储key、value、过期时间等</span><br>lock    sync.RWMutex<br><br>loader *loader<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *standardCache)</span></span> evict() (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <span class="hljs-comment">// 内存淘汰策略</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> sc.entries &#123; <span class="hljs-comment">// 随机过期key</span><br><span class="hljs-keyword">return</span> sc.remove(key)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *standardCache)</span></span> set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>entry, ok := sc.entries[key]<br><span class="hljs-keyword">if</span> ok &#123;<br>entry.setup(key, value, ttl)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> sc.maxEntries &gt; <span class="hljs-number">0</span> &amp;&amp; sc.size() &gt;= sc.maxEntries &#123; <span class="hljs-comment">// 超限随机过期key</span><br>evictedValue = sc.evict()<br>&#125;<br><br>sc.entries[key] = newEntry(key, value, ttl, sc.now)<br><span class="hljs-keyword">return</span> evictedValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *standardCache)</span></span> get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>entry, ok := sc.entries[key]<br><span class="hljs-keyword">if</span> ok &amp;&amp; !entry.expired(<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> entry.value, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>gocahce支持三套内存模型以供用户选择底层存储及内存淘汰策略</li><li>提供 ttl 过期机制，支持限制键值对数量</li><li>支持懒清理机制，每一次访问的时候判断是否过期</li></ul>]]></content>
    
    
    <categories>
      
      <category>每日一库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存缓存</tag>
      
      <tag>cachego</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cachego分片、上报、GC与数据加载机制原理</title>
    <link href="/2025/04/12/cachego%E5%88%86%E7%89%87%E3%80%81%E4%B8%8A%E6%8A%A5%E3%80%81GC%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2025/04/12/cachego%E5%88%86%E7%89%87%E3%80%81%E4%B8%8A%E6%8A%A5%E3%80%81GC%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="cachego-分片、上报、GC与数据加载机制原理"><a href="#cachego-分片、上报、GC与数据加载机制原理" class="headerlink" title="cachego 分片、上报、GC与数据加载机制原理"></a>cachego 分片、上报、GC与数据加载机制原理</h1><p><a href="https://github.com/FishGoddess/cachego">cachego github地址</a> </p><ul><li>为减小锁之间的竞争，cachego引入了分片机制，将key分散到多个sharding中，减低锁冲突概率加速索引。 sharding机制可与lru、lfu、standard模式丝滑结合，以实现cache中所有sharding内存模型都是指定的某种类型。</li><li>reporter 上报功能，支持上报hit次数、miss次数、gc次数、load次数(从下层存储load次数)，同时通过 option function 模式提供灵活的上报函数注册满足业务定制化上报功能。</li></ul><h2 id="newCache操作"><a href="#newCache操作" class="headerlink" title="newCache操作"></a>newCache操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCache</span><span class="hljs-params">(withReport <span class="hljs-type">bool</span>, opts ...Option)</span></span> (cache Cache, reporter *Reporter) &#123;<br>conf := newDefaultConfig()<br>applyOptions(conf, opts) <span class="hljs-comment">// option 模式赋值config</span><br><br>newCache, ok := newCaches[conf.cacheType] <span class="hljs-comment">// 选择内存模型 lru/lfu/standard</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cachego: cache type doesn&#x27;t exist&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> conf.shardings &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// cache分片, 本文讨论重点</span><br>cache = newShardingCache(conf, newCache)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cache = newCache(conf)<br>&#125;<br><br><span class="hljs-keyword">if</span> withReport &#123; <span class="hljs-comment">// 上报, 本文讨论重点</span><br>cache, reporter = report(conf, cache)<br>&#125;<br><br><span class="hljs-keyword">if</span> conf.gcDuration &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// gc</span><br>RunGCTask(cache, conf.gcDuration)<br>&#125;<br><br><span class="hljs-keyword">return</span> cache, reporter<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>newCache函数通过option模式允许用户自定义配置</li><li>根据用户配置决定是否创建sharding与reporter</li><li>根据所传gc间隔时长制定gc回收计划</li></ul><h2 id="shardingCache实现原理"><a href="#shardingCache实现原理" class="headerlink" title="shardingCache实现原理"></a>shardingCache实现原理</h2><h3 id="newShardingCache操作"><a href="#newShardingCache操作" class="headerlink" title="newShardingCache操作"></a>newShardingCache操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newShardingCache</span><span class="hljs-params">(conf *config, newCache <span class="hljs-keyword">func</span>(conf *config)</span></span> Cache) Cache &#123;<br><span class="hljs-keyword">if</span> conf.shardings &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cachego: shardings must be &gt; 0.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> bits.OnesCount(<span class="hljs-type">uint</span>(conf.shardings)) &gt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 只允许设置2的幂个分片</span><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cachego: shardings must be the pow of 2 (such as 64).&quot;</span>)<br>&#125;<br><br>caches := <span class="hljs-built_in">make</span>([]Cache, <span class="hljs-number">0</span>, conf.shardings)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; conf.shardings; i++ &#123; <span class="hljs-comment">// 循环创建分片数的cache，每个分片都是一个cache(lru/lfu/standard)</span><br>caches = <span class="hljs-built_in">append</span>(caches, newCache(conf))<br>&#125;<br><br>cache := &amp;shardingCache&#123;<br>config: conf,<br>caches: caches,<br>&#125;<br><br><span class="hljs-keyword">return</span> cache<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FNV-1a算法"><a href="#FNV-1a算法" class="headerlink" title="FNV-1a算法"></a>FNV-1a算法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hash</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// 高效的sharding分片寻址算法, FNV-1a算法 </span><br>hash := <span class="hljs-number">1469598103934665603</span><br><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> key &#123; <br>hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + <span class="hljs-type">int</span>(r&amp;<span class="hljs-number">0xffff</span>)<br>hash *= <span class="hljs-number">1099511628211</span><br>&#125;<br><br><span class="hljs-keyword">return</span> hash<br>&#125;<br></code></pre></td></tr></table></figure><p>算法高效原因</p><ul><li>简单的操作，<ul><li>左移操作：hash &lt;&lt; 5 </li><li>加法和减法：(hash &lt;&lt; 5) - hash 加法是哈希混合的一部分，有助于在不同字符之间产生良好的差异。</li><li>乘法：hash *&#x3D; 1099511628211 使用一个质数进行乘法引入更多的不可预测性。质数乘法有助于散列过程的均匀分布，因为质数避免了模式和重复的出现，从而减少碰撞</li></ul></li><li>通过 (hash &lt;&lt; 5) - hash 和 hash *&#x3D; 1099511628211，每个字符都会引入一个新的混合因子，使得前面的字符和后面的字符对最终哈希值的贡献是均匀的，这意味着输入数据中的每一个字符都能够“影响”哈希值的所有位，导致哈希值具有很好的散列性质</li><li>复杂度是 O(n), 通过质数乘法和每个字符的逐步混合减少哈希碰撞</li></ul><h3 id="set操作"><a href="#set操作" class="headerlink" title="set操作"></a>set操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *shardingCache)</span></span> Set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (oldValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">return</span> sc.cacheOf(key).Set(key, value, ttl)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *shardingCache)</span></span> cacheOf(key <span class="hljs-type">string</span>) Cache &#123; <span class="hljs-comment">// sharding 寻址操作</span><br>hash := sc.hash(key) <span class="hljs-comment">// FNV-1a算法 </span><br>mask := <span class="hljs-built_in">len</span>(sc.caches) - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">return</span> sc.caches[hash&amp;mask] <span class="hljs-comment">// 与sharding数与操作选定sharding</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>采用高效的<code>FNV-1a</code>算法获取key的散列值，确保了key的均匀性与sharding寻址速度</li><li>最终写入操作还是三种核心cache执行，key-value最终会被存入所选的lruCache、lfuCache或standardCache</li><li>除此之外shardingCache的hash也是支持自定义的，在创建cache时可自定义实现<code>WithHash()</code></li></ul><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>get操作通过FNV-1a算法定位到sharding后执行对应cache的get获取</p><h2 id="reportableCache实现原理"><a href="#reportableCache实现原理" class="headerlink" title="reportableCache实现原理"></a>reportableCache实现原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">report</span><span class="hljs-params">(conf *config, cache Cache)</span></span> (Cache, *Reporter) &#123;<br>reporter := &amp;Reporter&#123; <span class="hljs-comment">// 构建reporter</span><br>conf:        conf,<br>cache:       cache,<br>hitCount:    <span class="hljs-number">0</span>,<br>missedCount: <span class="hljs-number">0</span>,<br>gcCount:     <span class="hljs-number">0</span>,<br>loadCount:   <span class="hljs-number">0</span>,<br>&#125;<br><br>cache = &amp;reportableCache&#123;<br>config:   conf,<br>Reporter: reporter,<br>&#125;<br><br><span class="hljs-keyword">return</span> cache, reporter<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="set操作-1"><a href="#set操作-1" class="headerlink" title="set操作"></a>set操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rc *reportableCache)</span></span> Set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration) (evictedValue <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">return</span> rc.cache.Set(key, value, ttl)<br>&#125;<br></code></pre></td></tr></table></figure><p>set操作核心是调用另外三种cache的set接口执行写入操作</p><h3 id="get操作-1"><a href="#get操作-1" class="headerlink" title="get操作"></a>get操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rc *reportableCache)</span></span> Get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, found <span class="hljs-type">bool</span>) &#123;<br>value, found = rc.cache.Get(key) <span class="hljs-comment">// get</span><br><br><span class="hljs-keyword">if</span> found &#123;<br><span class="hljs-keyword">if</span> rc.recordHit &#123; <span class="hljs-comment">// hit数自增, atomic库操作</span><br>rc.increaseHitCount()<br>&#125;<br><br><span class="hljs-keyword">if</span> rc.reportHit != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 上报</span><br>rc.reportHit(rc.Reporter, key, value) <span class="hljs-comment">// reportHit 自定义上报函数</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> rc.recordMissed &#123; <span class="hljs-comment">// miss数自增, atomic库操作</span><br>rc.increaseMissedCount()<br>&#125;<br><br><span class="hljs-keyword">if</span> rc.reportMissed != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 上报</span><br>rc.reportMissed(rc.Reporter, key) <span class="hljs-comment">// reportMissed 自定义上报函数</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> value, found<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>get操作分为两步操作，先获取到值，再执行上报逻辑，其中hit与miss数均使用atomic库操作，保证原子性。</li><li>上报函数是由用户自定义，同时cachego也提供了HitRate与MissedRate等函数进行概率计算，详情可参考 <code>./_examples/report.go</code></li></ul><h2 id="gc与load数据加载"><a href="#gc与load数据加载" class="headerlink" title="gc与load数据加载"></a>gc与load数据加载</h2><h3 id="垃圾清理机制"><a href="#垃圾清理机制" class="headerlink" title="垃圾清理机制"></a>垃圾清理机制</h3><p>gc函数用于手动清理过期key。可在创建cache时手动传入<code>WithGC()</code>指定定时清理时间间隔，或者手动调用<code>GC()</code>函数执行</p><h4 id="定时清理"><a href="#定时清理" class="headerlink" title="定时清理"></a>定时清理</h4><p>在创建cache时如果传入<code>WithGC()</code>，则会执行<code>RunGCTask()</code>函数在后台定时扫描并清理过期数据，详情可参考<code>newCache</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RunGCTask</span><span class="hljs-params">(cache Cache, duration time.Duration)</span></span> (cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>fn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>cache.GC() <span class="hljs-comment">// 调用对应的cache只执行gc</span><br>&#125;<br><br>ctx := context.Background()<br>ctx, cancel = context.WithCancel(ctx)<br><br><span class="hljs-keyword">go</span> task.New(fn).Context(ctx).Duration(duration).Run()<br><span class="hljs-keyword">return</span> cancel<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Task)</span></span> Run() &#123;<br><span class="hljs-keyword">if</span> t.fn == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> t.before != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// AOP前置操作</span><br>t.before(t.ctx)<br>&#125;<br><br><span class="hljs-keyword">if</span> t.after != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// AOP后置操作</span><br><span class="hljs-keyword">defer</span> t.after(t.ctx)<br>&#125;<br><br>ticker := time.NewTicker(t.duration)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br><br><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// ticker定时执行</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t.ctx.Done():<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>t.fn(t.ctx) <span class="hljs-comment">// 执行自定义清理函数</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定时垃圾回收通过ticker+for循环定时执行，且返回一个cancel函数支持手动终止回收任务</li><li>task包封装了任务执行过程，允许自定义函数前置和后置操作，类似AOP操作</li><li>自动清理相比于手动清理多了一个定时任务触发</li></ul><h4 id="手动清理"><a href="#手动清理" class="headerlink" title="手动清理"></a>手动清理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> gc() (cleans <span class="hljs-type">int</span>) &#123;<br>now := lc.now()<br>scans := <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> _, element := <span class="hljs-keyword">range</span> lc.elementMap &#123;<br>scans++<br><br><span class="hljs-keyword">if</span> entry := lc.unwrap(element); entry.expired(now) &#123;<br>lc.removeElement(element)<br>cleans++<br>&#125;<br><br><span class="hljs-keyword">if</span> lc.maxScans &gt; <span class="hljs-number">0</span> &amp;&amp; scans &gt;= lc.maxScans &#123; <span class="hljs-comment">// 控制扫描key的数量以实现部分扫描</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> cleans <span class="hljs-comment">// return被清理的数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>手动清理支持指定扫描key数量，以免扫描key过多导致资源占用过多<br>如果cache类型是reportableCache，则在清理完成后还会刷新相关指标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rc *reportableCache)</span></span> GC() (cleans <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> rc.recordGC &#123; <span class="hljs-comment">// gc次数自增</span><br>rc.increaseGCCount()<br>&#125;<br><br><span class="hljs-keyword">if</span> rc.reportGC == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> rc.cache.GC()<br>&#125;<br><br>begin := rc.now()<br>cleans = rc.cache.GC()<br>end := rc.now()<br><br>cost := time.Duration(end - begin)<br>rc.reportGC(rc.Reporter, cost, cleans) <span class="hljs-comment">// 上报耗时、被清理key的数量</span><br><br><span class="hljs-keyword">return</span> cleans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="load数据加载"><a href="#load数据加载" class="headerlink" title="load数据加载"></a>load数据加载</h2><p>当在cache获取到某个key不存在时，可以向下层存取加载，这是可以使用cachego的<code>Load()</code>函数实现。<br><code>Load()</code>函数支持自定义加载函数，将从下层获取到的值再set会cachego中，且引入了<code>singleflight</code>减少缓存穿透的伤害</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc *lruCache)</span></span> Load(key <span class="hljs-type">string</span>, ttl time.Duration, load <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)) (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>value, err = lc.loader.Load(key, ttl, load)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> value, err<br>&#125;<br><br>lc.Set(key, value, ttl)<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *loader)</span></span> Load(key <span class="hljs-type">string</span>, ttl time.Duration, load <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)) (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> load == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;cachego: load function is nil in loader&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> l.group == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> load()<br>&#125;<br><br><span class="hljs-keyword">return</span> l.group.Call(key, load)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Call calls fn in singleflight mode and returns its result and error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Call(key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 避免同一时间多次调用同一个函数</span><br>g.lock.Lock()<br><br><span class="hljs-keyword">if</span> c, ok := g.calls[key]; ok &#123; <span class="hljs-comment">// 如果已经存在调用，则直接wait等待结果返回即可</span><br>g.lock.Unlock()<br><br><span class="hljs-comment">// Waiting...</span><br>c.wg.Wait()<br><span class="hljs-keyword">return</span> c.result, c.err<br>&#125;<br><br>c := newCall(fn)<br>c.wg.Add(<span class="hljs-number">1</span>)<br><br>g.calls[key] = c<br>g.lock.Unlock()<br><br>c.do()<br>g.lock.Lock()<br><br><span class="hljs-keyword">if</span> !c.deleted &#123; <span class="hljs-comment">// 完成调用后，删除</span><br><span class="hljs-built_in">delete</span>(g.calls, key)<br>&#125;<br><br>g.lock.Unlock()<br><span class="hljs-keyword">return</span> c.result, c.err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>singleflight是什么</p><ul><li>singleflight 避免重复的网络请求：对于重复的网络请求（如缓存查询），来避免多个 goroutine 发起重复的请求。</li><li>避免重复的数据库查询：类似于网络请求，多个并发查询可以避免重复的数据库访问。</li><li>共享计算结果：如果某个计算过程非常复杂且耗时，多个并发任务可以共享这个计算结果，而不需要重新计算</li></ul></li><li><p>load函数核心为从下层取数据，再写入当前内存缓存中</p></li><li><p>为避免同一key短时间内从下层存储中多次load，默认singleflight是开启的，如果不想用的话可以在新建 cachego传入<code>WithDisableSingleflight()</code>以关闭</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>每日一库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存缓存</tag>
      
      <tag>cachego</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+GitHub+阿里云域名解析搭建博客</title>
    <link href="/2024/11/16/Hexo-GitHub-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/11/16/Hexo-GitHub-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h1><p>node、github相关环境搭建参照: <a href="https://blog.csdn.net/weixin_44763569/article/details/106435118">搭建Hexo个人博客详细教程</a></p><h1 id="2-Hexo更换主题"><a href="#2-Hexo更换主题" class="headerlink" title="2.Hexo更换主题"></a>2.Hexo更换主题</h1><p>主题选用 <a href="https://hexo.fluid-dev.com/page/2/#board">Fluid</a>，效果如下<br><img src="https://i-blog.csdnimg.cn/direct/fb20f206a78b416591a2a54e4a89437c.png" alt="Fluid主题首页效果图"></p><h2 id="2-1-Fluid安装"><a href="#2-1-Fluid安装" class="headerlink" title="2.1 Fluid安装"></a>2.1 Fluid安装</h2><p>参考Fluid文档: <a href="https://hexo.fluid-dev.com/docs/start/">Fluid开始使用</a></p><p>推荐使用npm方式安装</p><h2 id="2-2-Fluid配置指南"><a href="#2-2-Fluid配置指南" class="headerlink" title="2.2 Fluid配置指南"></a>2.2 Fluid配置指南</h2><p>参照文档: <a href="https://hexo.fluid-dev.com/docs/guide/">Fluid配置指南</a></p><h1 id="3-Hexo创建文档及提交方式"><a href="#3-Hexo创建文档及提交方式" class="headerlink" title="3. Hexo创建文档及提交方式"></a>3. Hexo创建文档及提交方式</h1><h2 id="3-1-配置github仓库"><a href="#3-1-配置github仓库" class="headerlink" title="3.1 配置github仓库"></a>3.1 配置github仓库</h2><p>在本地所创建的项目里面找到 _congif.yml文件，找到 deploy 字段，把以下代码放进去，填写第一步新建的仓库地址<br><img src="https://i-blog.csdnimg.cn/direct/b073575427764f1880fb4bdce527d1eb.png" alt="配置github仓库"></p><h2 id="3-2-安装推送工具"><a href="#3-2-安装推送工具" class="headerlink" title="3.2 安装推送工具"></a>3.2 安装推送工具</h2><p>用npm安装一个推送工具，将本地项目推到仓库上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h2 id="3-3-创建文章及推送"><a href="#3-3-创建文章及推送" class="headerlink" title="3.3 创建文章及推送"></a>3.3 创建文章及推送</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new 测试文章 <span class="hljs-comment"># 1.创建新文章，&#x27;测试文章&#x27;为文件名，文章格式为markdown，新文章在source/_posts目录下</span><br>hexo clean <span class="hljs-comment"># 2.此命令用于清除缓存(非必须但建议执行)</span><br>hexo g <span class="hljs-comment"># 3.hexo generate简写，即生成静态文件</span><br>hexo deploy <span class="hljs-comment"># 4. 推送到github</span><br></code></pre></td></tr></table></figure><p>注意: 只有推送到github后才能通过域名方式访问，否则只能在本地localhost:4000(<code>hexo server</code> 命令启动本地server)查看</p><h1 id="4-域名绑定"><a href="#4-域名绑定" class="headerlink" title="4. 域名绑定"></a>4. 域名绑定</h1><h2 id="4-1-域名购买"><a href="#4-1-域名购买" class="headerlink" title="4.1 域名购买"></a>4.1 域名购买</h2><p>这里域名选择阿里云， 域名购买方式可自行百度</p><h2 id="4-2-域名解析"><a href="#4-2-域名解析" class="headerlink" title="4.2 域名解析"></a>4.2 域名解析</h2><p>域名购买后需解析，解析步骤及绑定github参考: <a href="https://www.cnblogs.com/yz0812/p/10392711.html">hexo绑定个人域名</a></p><p>具体解析记录可参考下面阿里云域名解析记录截图:<br><img src="https://i-blog.csdnimg.cn/direct/ae01ca2a1ec04d35a93e250dd7d3f1fd.png" alt="阿里云域名解析记录"></p><h1 id="5-使用域名访问博客"><a href="#5-使用域名访问博客" class="headerlink" title="5.使用域名访问博客"></a>5.使用域名访问博客</h1><p>上述步骤完成后即可通过域名方式博客<br><img src="https://i-blog.csdnimg.cn/direct/017782a0711c4aa487a59ff2cb177d5c.png" alt="使用域名访问博客"></p><h1 id="6-图床"><a href="#6-图床" class="headerlink" title="6.图床"></a>6.图床</h1><p>基于Gitee + Picgo</p><h2 id="6-1-下载Picgo"><a href="#6-1-下载Picgo" class="headerlink" title="6.1 下载Picgo"></a>6.1 下载Picgo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/Molunerfinn/PicGo/releases<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214016392.png" alt="下载Picgo"></p><h2 id="6-2-配置Picgo"><a href="#6-2-配置Picgo" class="headerlink" title="6.2 配置Picgo"></a>6.2 配置Picgo</h2><h3 id="6-1-gitee新建仓库"><a href="#6-1-gitee新建仓库" class="headerlink" title="6.1 gitee新建仓库"></a>6.1 gitee新建仓库</h3><h3 id="6-2-生成Gitee令牌"><a href="#6-2-生成Gitee令牌" class="headerlink" title="6.2 生成Gitee令牌"></a>6.2 生成Gitee令牌</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214302660.png" alt="生成Gitee令牌"><br>进入设置 –&gt; 点击私人令牌 –&gt; 点击生成新令牌</p><h3 id="6-3-Picgo安装gitee插件"><a href="#6-3-Picgo安装gitee插件" class="headerlink" title="6.3 Picgo安装gitee插件"></a>6.3 Picgo安装gitee插件</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214356514.png" alt="Picgo安装gitee插件"></p><h3 id="6-4-配置Picgo图床设置"><a href="#6-4-配置Picgo图床设置" class="headerlink" title="6.4 配置Picgo图床设置"></a>6.4 配置Picgo图床设置</h3><p><img src="https://gitee.com/zhangphh/images-collections/raw/master/20250526214523988.png" alt="配置Picgo图床设置"></p><p>更详细内容参考：<a href="https://blog.csdn.net/m0_69326428/article/details/147326688">Hexo+Github+gitee图床零成本搭建自己的专属博客</a></p><h1 id="7-其他问题"><a href="#7-其他问题" class="headerlink" title="7.其他问题"></a>7.其他问题</h1><h2 id="7-1-markdown图片失效问题"><a href="#7-1-markdown图片失效问题" class="headerlink" title="7.1 markdown图片失效问题"></a>7.1 markdown图片失效问题</h2><p>有种原因是图床存在防盗链，会报403禁止访问，此种问题解决方案可参考: <a href="https://juejin.cn/post/7368276508136505407">外链图片不显示</a></p><h2 id="7-2-GitHub配置自定义域名新推送失效问题"><a href="#7-2-GitHub配置自定义域名新推送失效问题" class="headerlink" title="7.2 GitHub配置自定义域名新推送失效问题"></a>7.2 GitHub配置自定义域名新推送失效问题</h2><p>域名绑定后已经能通过个人域名访问托管在github的博客了，但存在一个问题,就是每次hexo d重新部署后,配置的 GitHub Pages 自定义域名消失<br>解决方案也很简单就在<code>source</code> 目录下新建一个CNAME文件，将个人域名填进去即可，可参考: <a href="https://cloud.tencent.com/developer/article/2446582">为HEXO绑定自己的域名</a></p>]]></content>
    
    
    <categories>
      
      <category>造轮子-工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
